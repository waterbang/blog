<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2024年终总结</title>
    <link href="/2024/12/21/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2024/12/21/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是我的自拍照，小黄</p><div  align="center" style="width: 100px; height: 100px; border-radius: 50%;"><img src="./my.png" /></div></br><p>写于2024年的圣诞节前夕，今年的主题是 “”” 打破舒适区 “””</p><p>今年总共产出了4篇文章，鸽了一个 奇门遁甲系列只写了两篇，有空的时候再继续写，但是代码游戏视频一直在勾引我。</p><blockquote><p><a href="https://www.bilibili.com/video/BV1ytkbYvEk5/?spm_id_from=333.337.search-card.all.click&vd_source=5a551b309f4cee1aa97066b4d520cef5">2024 发生了什么</a>。</p></blockquote><p>今年的的物理学基本规律还没有产生实质性的突破，AI 依然是最火热的主题。<br>当前 AI 编程已经颠覆传统的开发方式，AI 淘汰的不会是所有程序员，但一定会淘汰只能付出体力劳动的程序员，以当前的发展节奏5年以后人人都是程序员不是问题。<br>需要要和AI互相学习，互相融合，然后千万要多思考，不要让ai 牵着鼻子走，你得先知道能这么写，才能去指导ai去完成。因此接下来知识的广度很重要。</p><h2 id="代码相关"><a href="#代码相关" class="headerlink" title="代码相关"></a>代码相关</h2><p>因为换了公司，今年开始尝试编写 Flutter 代码了，为了融入团队，需要进一步的了解整个团队的技术架构和代码风格。<br>但是后续应该会尝试swiftUI 编写体验和整个的动画流畅度，应用体积也会优化很多，并且可以为当前公司小组的app编写一些原生的SDK，去优化一些动画或者交互。</p><p>学习Flutter 一个月 也产出了第一个应用，这个程序也当作学习机器学习方面的铺垫，当前是公司的核心技术是AI,因此对机器学习的学习和一些理解也是未来学习的重点。</p><p>Typescript是永恒的主题，但是距离真正的大佬@Gaubee写的代码还是差距非常大，并且当前达到瓶颈无法突破，还需要多多Review 大佬们的代码。</p><p>今年Kotlin 和 Rust 在前半年写得比较多，今年后半年就都在写TS了，并且在新公司入坑了微信小程序，虽然比以前好多了，但是问题还是挺多的。<br>由于有了AI这个好老师，也敢开始尝试C++相关的工作了，公司的大佬都是使用C++编写代码，因此也需要多多向大佬们学习一些编程思想。</p><p><img src="/./code.png" alt="github map"></p><p>今年的后端重心也准备逐步转移到Golang 但是还是需要多多学习，虽然Golang的语法糖比较少，但是协程的坑还是很多的。</p><p>给大家看看 什么叫做反复入门 🤣 2024年了依然在刷杨旭老师的视频。</p><p><img src="/./go.png" alt="golang"></p><h2 id="书籍相关"><a href="#书籍相关" class="headerlink" title="书籍相关"></a>书籍相关</h2><p>今年的书读得比较少，代码打得比较多了，主要是当前AI的爆发，颠覆了以前的学习方式，导致目前有不断尝试新语言，新框架，新方向想法，并且这个过程非常有趣。</p><p>今年读了一本渤海小吏写的 《两晋悲歌》 还没读完，总共3本书。</p><p>然后在厦门图书馆快速过了一遍 《Rust语言编程实战》 还有一本 《深入理解Go并发编程》还没读完，放回去了。</p><p>还有一本卡尔卡根的 《暗淡蓝点》 这本年度最佳，下面是里面的一句话。</p><blockquote><p>On it everyone you love, everyone you know, everyone you ever heard of, every human being who ever was, lived out their lives.<br>在它上面，有你爱的每个人、你认识的每个人、你听说过的每个人。历史上的每一个人，都在它上面度过了自己的一生。</p></blockquote><p><img src="/./earth.jpg" alt="earth"></p><h2 id="讲座相关"><a href="#讲座相关" class="headerlink" title="讲座相关"></a>讲座相关</h2><p>最近也去听了一场厦门教授的讲座，公司大佬邀请过来的，非常厉害，科研氛围很好老师人也很有趣，给了机器学习和CV的一些新颖观点。<br>可惜没能拿到PPT,老师ppt也写得很好，20年的功力。</p><p><img src="/./lambda.png" alt="lambada"></p><p>然后还去参加了2024的前端日，今年的主题是AI加持下的前端，大家都在做什么，见到了许多传说中的大佬，感觉很平易近人感觉很好。</p><h2 id="开源相关"><a href="#开源相关" class="headerlink" title="开源相关"></a>开源相关</h2><p>开源才是未来的发展，封闭无法推动社会的整体进步，也是得益于开源社区，能让我们非常方便的欣赏到大佬们的代码。</p><p>如果有兴趣一起学习欢迎加入我们的分布式网络学习小组。一起学习，这里鼓励采用最激进的技术，进行一些想法的实现。</p><p><img src="/./dweb.png" alt="dweb-channel"></p><p>以下开源项目由社区小伙伴共建：</p><ol><li><a href="https://github.com/dweb-channel/screenshot">screenshot</a> 这是一个快速实现的app截图工具，当前还非常原始。</li><li><a href="https://github.com/dweb-channel/ctf">ctf</a> 这是一个网络安全手册。</li><li><a href="https://github.com/dweb-channel/wasm-template">rust-wasm-temp</a> 这是rust的wasm启动模版,用于快速输出包含wasm的npm包。</li><li><a href="https://github.com/dweb-channel/PromiseOut-rust">promise-out</a> 这是promise的rust版本。</li><li><a href="https://github.com/dweb-channel/Auto-i18n">Auto-i18n</a> 这提供了使用 ChatGPT 自动将 Markdown 文件批量翻译为多语言的能力用于快速构建文档。</li></ol><h2 id="许愿2025"><a href="#许愿2025" class="headerlink" title="许愿2025"></a>许愿2025</h2><ol><li>2025希望能突破一些技术上的瓶颈，跟公司的大佬们学习更多的AI技术和算法，进一步产生自己的产出，为公司多做一些贡献。</li><li>希望知识能继续构建成体系，遵循教授的话，多读书，形成自己的思考模式。然后继续学英语。</li><li>带老婆出去玩</li><li>希望能去爬一座山</li><li>希望能有健身时间</li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>有一句话说得很好，没有什么是永恒的，最大的能力就是学习能力，所以希望能保持持续的输入和输出。</p><p><img src="/./communism.jpg" alt="Communism"></p>]]></content>
    
    
    
    <tags>
      
      <tag>年度总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第七届-FEDAY</title>
    <link href="/2024/12/07/FEDAY/"/>
    <url>/2024/12/07/FEDAY/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>以下内容为个人回忆记录，可能会有疏漏，可在评论区补充。</p></blockquote><p>今年的前端圈基本都是关于 AI 的分享，10场只有3场是关于，前端框架或者工具的。本来个人是有点抵触的，但是后来就想通了，既然 编码的目的是解放生产力 为什么不能 <code>ai for all</code> 呢？</p><p>大家都是一群爱折腾、有好奇心的人,前端技术日新月异，好玩的东西层出不穷，这次的主题就是编码想要有AI的加持，应该怎么玩？</p><p> ai 想要落地，前端开发者的挑战也是不小的。比如： 模型的本地优先如何实现，因为想要真正的落地，比如视频追色，把每一帧都搞到服务器上给模型解析再返回到客户端，费用将会异常的恐怖。</p><p>再比如，如何利用wasm加速ai模型推理，如何保证用户隐私，如何避免 ai 投毒，想想就非常有趣。</p><p><img src="/FEDAY/js.jpg" alt="js"></p><h2 id="使用-Gradio-和-Transformers-构建-Web-AI应用"><a href="#使用-Gradio-和-Transformers-构建-Web-AI应用" class="headerlink" title="使用 Gradio 和 Transformers 构建 Web AI应用"></a>使用 Gradio 和 Transformers 构建 Web AI应用</h2><p>分享嘉宾：Yuichiro</p><p>Yuichiro 是专门从日本来的嘉宾，就职于 Hugging Face, 是一个很有趣的人，演讲的时候可能有点紧张，说的英语在颤抖。</p><p>他主要分享了前端如何借助 WebAssembly 去吃到 Python AI生态系统的成果。</p><blockquote><p><a href="https://pyodide.org/en/stable/">Pyodide</a>, 是一个基于 WebAssembly 的浏览器和 Node.js 的 Python 发行版。</p></blockquote><p>然后还分享了 如何利用 <a href="https://www.gradio.app/guides/gradio-lite-and-transformers-js">Gradio-lite and Transformers.js</a>去构建无服务的前端应用。（震惊 🤯 竟然在HTML写 Python 代码，是个狠人）</p><blockquote><p>这里有关于演讲的示例演示：</p><ol><li><a href="https://github.com/whitphx/transformers.js.py?tab=readme-ov-file">https://github.com/whitphx/transformers.js.py?tab=readme-ov-file</a></li><li><a href="https://www.gradio.app/guides/gradio-lite">https://www.gradio.app/guides/gradio-lite</a></li></ol></blockquote><h2 id="Ling：AI-流式结构化输出解决方案"><a href="#Ling：AI-流式结构化输出解决方案" class="headerlink" title="Ling：AI 流式结构化输出解决方案"></a>Ling：AI 流式结构化输出解决方案</h2><p>分享嘉宾：月影</p><p>月影老师是如雷贯耳的老前辈，从事开发已经二十几年了，他最近也在进行关于 ai 的创业，是专注于教学儿童方面的，提供的载体是微信小程序，叫做 波波熊学伴，体验了一下，感觉挺好的，只需要提供故事名，就能完整的构造一个故事流程，可以方便的学习英语。</p><p>他这次分享的是关于 <a href="https://ling.bearbobo.com/">AI 流式响应框架 Ling </a>，并且分享了JSON作为模型的输入输出，是有多么的高效，第一次见确实长见识了，特别对构建 AI 工作流非常有帮助。</p><p>大模型的流式输出是非常重要的，但是因为 JSON 是一种封闭的数据结构，导致流式输出之后到前端，开发者很难处理这些数据，所以就有了  Ling 这个工具，它的核心是一个实时解析 JSON Token 的解析器，将实时解析的内容立即以 Stream 的方式返回。让整个流程更加高效。</p><p>这场学习到了各个大模型之间互相协作的可能性，见识到了模型对 JSON 理解程度之强，以后感觉不用再傻傻的写一堆提示词了。</p><h2 id="如何打造属于自己的-Cursor"><a href="#如何打造属于自己的-Cursor" class="headerlink" title="如何打造属于自己的 Cursor"></a>如何打造属于自己的 Cursor</h2><p>分享嘉宾：谢俊鸿</p><p>这位嘉宾是来自蚂蚁集团云研发团队的技术专家，OpenSumi 负责人。他主要分享的是当前的 AI 编码辅助，如何突破 VS Code 的瓶颈，突破他的局限性进一步的发展，因此他们推出了 <a href="https://opensumi.com/zh">opensumi</a> ，用来快速的搭建本地的 IDE。并且演示了一些插件如何开发，整个文档也是写得非常详细非常好，是个很厉害的团队。还推出了在 web 上就能体验到的AI编辑器 <a href="https://codeblitz.opensumi.com/en">Codeblitz</a>.</p><p>编写 AI 编辑器这个需求比较少，但是如果需要，这个项目将提供极大的帮助，并且提供的一些API调用范式也非常符合直觉。</p><p>详细用过的都能领略到Ai编辑器的强大，我最近也一直在使用 windSurf 对于整个生产力的提升不是一点半点，但是也有一定的弊端，容易出现以下情况:</p><p><img src="/%E7%AC%AC%E4%B8%83%E5%B1%8A-FEDAY/bike-ai.jpg" alt="code from ai"></p><h2 id="2024-年的-Web-AI：现代-Web-应用的超级能力"><a href="#2024-年的-Web-AI：现代-Web-应用的超级能力" class="headerlink" title="2024 年的 Web AI：现代 Web 应用的超级能力"></a>2024 年的 Web AI：现代 Web 应用的超级能力</h2><p>分享嘉宾： Jason Mayes</p><p>Jason Mayes 也是老面孔了，他是谷歌 Web AI 主管，之前学习 tensorflow.js 的时候就一直看见他在宣传。他这次也是在推广 AI模型在本地优先领域的应用。</p><h2 id="Web3D-开发中-AIGC-的探索及工作流实践"><a href="#Web3D-开发中-AIGC-的探索及工作流实践" class="headerlink" title="Web3D 开发中 AIGC 的探索及工作流实践"></a>Web3D 开发中 AIGC 的探索及工作流实践</h2><p>分享嘉宾:慎思</p><p>他是蚂蚁集团 Galacean 的团队技术专家、渲染和数字人方向负责人，他主要分享了一个通过AI大模型加持的 Web3D 互动图形引擎,也就是Galacean，他们正在探索将图片生成一个 Web3D 的场景的能力，可以简单直接的拖放到场景中，去解决一些简单的需求。</p><p>他们还在探索一些预测下一步行为的模型,类似下面的运动扩散模型，这样可以更好的生成随机动画，进一步提高效率.</p><p>这个运动扩散模型，在进行AI照片修复也拥有非常强大的应用前景。</p><video style="width: 100%;" controls>  <source src="./xx.mp4" type="video/mp4"></video><p>并且探索了 AIGC 在编辑器中如何建模、贴图、动画和脚本等环节进行简化，甚至直接交给AI的探索，也是能颠覆未来 3D 从业人员的领域。最近 Google 也发布了一个，通过大模型来生成基础世界的研究，感觉非常厉害，可以想象，大模型才出来两年就有这么强的应用，以后必将更进一步的解放生产力。</p><blockquote><p><a href="https://deepmind.google/discover/blog/genie-2-a-large-scale-foundation-world-model/">Genie 2: A large-scale foundation world model</a></p></blockquote><h2 id="Midscene-js-用-AI-构建下一代-e2e-测试工具"><a href="#Midscene-js-用-AI-构建下一代-e2e-测试工具" class="headerlink" title="Midscene.js 用 AI 构建下一代 e2e 测试工具"></a>Midscene.js 用 AI 构建下一代 e2e 测试工具</h2><p>分享嘉宾：周晓</p><p>这位是字节跳动 Web infra 团队成员，微前端技术方向负责人，他带来的是颠覆测试工具的一个运用自然语言编写测试的项目。直接看两个图更加的直观。</p><p><img src="/FEDAY/ai-test-1.jpg" alt="ai-test-1"><br><img src="/FEDAY/ai-test-2.jpg" alt="ai-test-2"></p><p>通过自然语言来对抗页面UI的变化，过程不输出任何的代码，并且能进行结果断言，这个项目实在是前途无量。其通过自然语言的编写测试用例的方式极大的提升了测试用例的可维护性和编写成本。</p><p>这个项目可以配置open AI 的key,也提供了自定义模型的服务,可以借助 ollama 进行本地模型推理，在公司内网部署一个，感觉会非常不错。</p><blockquote><p><a href="https://midscenejs.com/">https://midscenejs.com/</a></p></blockquote><h2 id="基于端-云打造-AI-应用"><a href="#基于端-云打造-AI-应用" class="headerlink" title="基于端+云打造 AI 应用"></a>基于端+云打造 AI 应用</h2><p>分享嘉宾：谢亚东</p><p>东哥是Lepton AI 创始成员，他们公司主要提供 AI云服务，可以帮助用户去快速构建 AI应用。</p><p>主要通过展示一些 AI 在硬件或者软件运用的示例。<br>比如：<a href="https://github.com/vthinkxie/ai-recorder">ai-recorder</a>。这个模型对声音和噪音的感知挺厉害的，就是裁剪过的版本对中文支持不太友好。<br>这个让我们直观的感受到AI 在端侧和云侧的互相配合，并且展示了如何使用 ServerWorker 的 Cache 等手段，对端侧的AI模型进行优化，去做到本地优先，进一步减少成本。</p><h2 id="Qwik-Resumability-可恢复性-将引领时代"><a href="#Qwik-Resumability-可恢复性-将引领时代" class="headerlink" title="Qwik: Resumability(可恢复性) 将引领时代"></a>Qwik: Resumability(可恢复性) 将引领时代</h2><p>分享嘉宾：毛雨乐（Maïeul）</p><p>毛雨乐来自法国，是个很友善的人,结束之后还发Qwik贴纸，给大家看他 PPT 开头。</p><p><img src="/./halou.jpg" alt="hello"></p><p>他虽然是法国人，但是全程使用中文进行演讲，非常厉害。他这次是他第一次演讲，带来的是Qwik.js。</p><p>Qwik.js 的核心理念是 “Resumability”（可恢复性），不像传统框架那样在客户端完成全面的重新渲染（hydration）不需要在客户端重新初始化组件，而是直接恢复服务器渲染的状态。这种机制可以显著减少页面加载时间。按照他来说加载速度确实极快，</p><p>简单来说就是不用在服务端渲染一次，然后再客户端在进行重新渲染。如果您最求极致的性能Qwik确实是一个选择，就是不知道跟Svelte没有运行时开销的框架对比起来咋样。</p><p>Qwik现在的缺点是生态还在发展中，并且有一些<code>$</code>新式的API.</p><h2 id="微信端内网页远程调试及断点原理"><a href="#微信端内网页远程调试及断点原理" class="headerlink" title="微信端内网页远程调试及断点原理"></a>微信端内网页远程调试及断点原理</h2><p>分享嘉宾：邱焱坤</p><p>这位大佬是来自腾讯微信公众号团队高级前端工程师，他分享的是 基于Chrome DevTools Protocol实现了纯前端的调试工具 <a href="https://github.com/wechatjs/mprdev">mprdev</a>,通过websocket 等形式将调试信息发送至Chrome DevTools中来进行调试。很大程度上提升了调试能力。</p><p>并且还抽象出了断点工具<a href="https://github.com/wechatjs/vdebugger">vDebugger</a>,以支持在JSCore等非浏览器环境下进行断点调试。</p><h2 id="ESLint-One-for-All-Made-Easy"><a href="#ESLint-One-for-All-Made-Easy" class="headerlink" title="ESLint One for All Made Easy"></a>ESLint One for All Made Easy</h2><p>分享嘉宾：Anthony Fu</p><p>Anthony Fu 大家应该都认识，是一个狂热的开源爱好者，前端都或多或少使用过他开发的工具。</p><p>这是他参与的开源项目，还做了很多帖子发，真好。</p><p><img src="/FEDAY/fu-sticker.jpg" alt="Anthony Fu"></p><p>他主要介绍了 ESLint 的<a href="https://eslint.org/blog/2024/04/eslint-config-inspector/">可视化配置检查器</a></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">eslint --inspect-config<br></code></pre></div></td></tr></table></figure><p>并且带来了ESLint<a href="https://nuxt.com/blog/eslint-module">扁平化的配置指南</a>。确实 <code>eslint.config.js</code>的写法更加的符合直觉，对代码的掌控也更加好。</p><p>还解决我一个痛点就是可恶的红色波浪线。只需要如下配置：</p><p><img src="/FEDAY/eslint.jpg" alt="eslint"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>AI 最后将会变成和空气一样的存在，因为我们的最终目的是解放生产力，解放生产力才能更好的去实现共产主义。<br>但是也不能过度的去依赖AI，我们需要借助AI去干一些繁琐的事情，我们才有时间去做一些有创造性有趣的事情和挑战。因此保持学习和思考是当前AI浪潮下，我们需要做的。</p><p>最后放一个大合照。</p><p><img src="/FEDAY/all.jpg" alt="owner"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust的特性备忘</title>
    <link href="/2024/05/16/rust%E7%9A%84%E7%89%B9%E6%80%A7%E5%A4%87%E5%BF%98/"/>
    <url>/2024/05/16/rust%E7%9A%84%E7%89%B9%E6%80%A7%E5%A4%87%E5%BF%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于个人学习的知识学一门忘一门，因此在这里总结一些比较容易忘记的细节内容，以备复习。</p><blockquote><p>参考 ：杨旭&lt;&lt;Rust 编程语言中级教程&gt;&gt; ,《Rust for Rustaceans》</p></blockquote><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>rust 提供的引用是指针的一种高级抽象。引用就是指针。</p><ul><li>引用始终引用的是有效数据</li><li>引用与 usize 的倍数对齐</li><li>引用可以动态大小的类型提供上述保障</li></ul><p>引用会保证在内存中对齐，没有对齐的部分会填充字节，从而不会影响代码的运行速度。</p><p>例如：i32 类型在内存中占用的空间为 4 字节。</p><blockquote><p>rust 会把不没有固定长度的类型存储在内部指针的附近,这样可以让程序永远不会超出程序在内存中运行的空间，产生溢出漏洞，</p></blockquote><h2 id="Raw-Pointers（原始指针）"><a href="#Raw-Pointers（原始指针）" class="headerlink" title="Raw Pointers（原始指针）"></a>Raw Pointers（原始指针）</h2><p>原始指针是没有 Rust 标准保障的内存地址，即本质上都是需要 unsafe 块包裹的。<br>它的速度极快，但是不安全。</p><ul><li>不可变 Raw Pointer： <code>*const T</code></li><li>可变的 Raw Pointer：<code>*mutT</code></li></ul><blockquote><p>注意： <code>*constT</code>，这三个标记放在一起表示的是一个类型</p><p>例子： <code>*const String</code></p></blockquote><p><code>*const T</code> 和 <code>*mutT</code> 之间差异很小，可以互相转换。</p><p>Rust 的引用（&amp;mutT 和 &amp;T ）会编译为原始指针。这意味着无需冒险进入 unsafe 块，就可以获得原始指针的性能。</p><h3 id="例子：把引用转为原始指针"><a href="#例子：把引用转为原始指针" class="headerlink" title="例子：把引用转为原始指针"></a>例子：把引用转为原始指针</h3><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>:<span class="hljs-type">i64</span> = <span class="hljs-number">42</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">a_ptr</span>: *<span class="hljs-keyword">const</span> <span class="hljs-type">i64</span> = &amp;a <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i64</span>;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a: &#123;&#125; (&#123;:p&#125;)&quot;</span>,a,a_ptr);<br>&#125;<br><span class="hljs-comment">// ouput=&gt; a: 42 (0x7ff7bd530670)</span><br></code></pre></div></td></tr></table></figure><blockquote><p>{:p} 可以打印指针地址</p></blockquote><p>解引用 （dereference）：通过指针从 RAM 内存提取数据的过程 叫做对指针进行解引用</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: <span class="hljs-type">i64</span> = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a_ptr</span>: *<span class="hljs-keyword">const</span> <span class="hljs-type">i64</span> = &amp;a <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i64</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a_addr</span>: <span class="hljs-type">usize</span> = <span class="hljs-keyword">unsafe</span> &#123; std::mem::<span class="hljs-title function_ invoke__">transmute</span>(a_ptr) &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a: &#123;&#125; (&#123;:p&#125;... 0x&#123;:x&#125;)&quot;</span>, a, a_ptr, a_addr + <span class="hljs-number">7</span>);<br>&#125;<br><span class="hljs-comment">// output=&gt; a: 42 (0x7ff7bacca370... 0x7ff7bacca377)</span><br></code></pre></div></td></tr></table></figure><blockquote><p>std::mem::transmute :将一种类型的值的位重新解释为另一种类型。两种类型必须具有相同的大小。如果不能保证这一点，编译将失败。</p></blockquote><h3 id="重要的提示-🔥"><a href="#重要的提示-🔥" class="headerlink" title="重要的提示 🔥"></a>重要的提示 🔥</h3><ul><li>在底层，引用（&amp;T 和 &amp;mutT）被实现为原始指针。但引用带有额外的保障，应该始终作为首选使用</li><li>访问 原始指针 的值总是 unsafe 的</li><li>原始指针 不拥有值的所有权</li><li>在访问时编译器不会检查数据的合法性</li><li>允许多个 原始指针 指向同一数据</li><li>Rust 无法保证共享数据的合法性</li></ul><h4 id="什么时候可以使用原始指针"><a href="#什么时候可以使用原始指针" class="headerlink" title="什么时候可以使用原始指针"></a>什么时候可以使用原始指针</h4><ul><li>某些 OS 或第三方库需要使用，例如与 C 交互。</li><li>共享对某些内容的访问至关重要，运行时性能要求高。</li></ul><h2 id="Smart-Pointer（智能指针）"><a href="#Smart-Pointer（智能指针）" class="headerlink" title="Smart Pointer（智能指针）"></a>Smart Pointer（智能指针）</h2><p>智能指针倾向于包装原始指针，附加更多的能力，不仅仅是对内存地址解引用。</p><h3 id="Box"><a href="#Box" class="headerlink" title="Box&lt;T&gt;"></a><code>Box&lt;T&gt;</code></h3><p>可以把任何东西都放在 Box 里。可接受几乎任何类型的长期存储。新的安全编程时代的主力军。</p><ul><li>优点：将值集中存储在 Heap。</li><li>缺点：大小增加。</li></ul><h3 id="Rc"><a href="#Rc" class="headerlink" title="Rc&lt;T&gt;"></a><code>Rc&lt;T&gt;</code></h3><p><code>Rc&lt;T&gt;</code>是 Rust 的能干而吝啬的簿记员。它知道谁借了什么，何时借了什么。</p><ul><li>优点：对值的共享访问。</li><li>缺点：大小增加。运行时成本增加，线程不安全。</li></ul><h3 id="Arc"><a href="#Arc" class="headerlink" title="Arc&lt;T&gt;"></a><code>Arc&lt;T&gt;</code></h3><p><code>Arc&lt;T&gt;</code>是 Rust 的大使。它可以跨线程共享值，保证这些值不会相互干扰。</p><ul><li>优点：对值的共享访问，线程安全。</li><li>缺点：大小增加,运行时成本增加。</li></ul><h3 id="Cell"><a href="#Cell" class="headerlink" title="Cell&lt;T&gt;"></a><code>Cell&lt;T&gt;</code></h3><p>变态专家，具有改变不可变值的能力。</p><ul><li>优点：内部可变性。</li><li>缺点：大小增加,性能降低。</li></ul><h3 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell&lt;T&gt;"></a><code>RefCell&lt;T&gt;</code></h3><p>对不可变引用执行改变的能力，但有代价。</p><ul><li>优点：内部可变性，可与仅接受不可变引用的 <code>Rc</code>、<code>Arc</code> 嵌套使用。</li><li>缺点：大小增加，运行时成本增加，缺乏编译时保障。</li></ul><h3 id="Cow"><a href="#Cow" class="headerlink" title="Cow&lt;T&gt;"></a><code>Cow&lt;T&gt;</code></h3><p>封闭并提供对借用数据的不可变访问，并在需要修改所有权时延迟克隆数据。</p><ul><li>优点：当只是只读访问时可以避免写入。</li><li>缺点：大小可能会增加.</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a><code>String</code></h3><p>可处理可变长度的文本，展示了如何构建安全的抽象。</p><ul><li>优点：动态按需增长，在运行时保证正确编码。</li><li>缺点：过度分配内存大小。</li></ul><h3 id="Vec"><a href="#Vec" class="headerlink" title="Vec&lt;T&gt;"></a><code>Vec&lt;T&gt;</code></h3><p>程序最常用的存储系统；它在创建和销毁值时保持数据有序。</p><ul><li>优点：动态按需增长。</li><li>缺点：过度分配内存大小。</li></ul><h3 id="RawVec"><a href="#RawVec" class="headerlink" title="RawVec&lt;T&gt;"></a><code>RawVec&lt;T&gt;</code></h3><p>是<code>Vec&lt;T&gt;</code>和其它动态大小类型的基石，知道如何按需给你的数据提供一个家。</p><ul><li>优点：动态按需增长。与内存分配器一起配合寻找空间。</li><li>缺点：代码上一般用不到。</li></ul><h3 id="Unique"><a href="#Unique" class="headerlink" title="Unique&lt;T&gt;"></a><code>Unique&lt;T&gt;</code></h3><p>作为值的唯一所有者，可保证拥有完全控制权。</p><ul><li>优点：需要独占值的类型（如 String）的基础.</li><li>缺点：代码上一般用不到。</li></ul><h3 id="Shared"><a href="#Shared" class="headerlink" title="Shared&lt;T&gt;"></a><code>Shared&lt;T&gt;</code></h3><p>分享所有权。</p><ul><li>优点：共享所有权,可以将内存与 T 的宽度对齐，即使是空的时候。</li><li>缺点：代码上一般用不到。</li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>有 3 个比较重要的内存区域<code>stack</code>,<code>heap</code>,<code>static</code>。</p><ul><li>stack 比较快，在内存中比较整齐。</li><li>heap 比较慢，在内存中比较混乱。</li></ul><h2 id="stack-栈内存"><a href="#stack-栈内存" class="headerlink" title="stack 栈内存"></a>stack 栈内存</h2><p>Stack 是一段内存. 其调用顺序是 LIFO（后进先出）的。<br>程序把它作为一个暂存空间，用于函数调用,main 函数就接近 Stack 底部。</p><p>想把数据放在 Stack，编译器必须知道类型的大小。</p><blockquote><p>首选使用 Stack,也就是实现了 Sized 的类型。</p></blockquote><h3 id="Stack-Frame"><a href="#Stack-Frame" class="headerlink" title="Stack Frame"></a>Stack Frame</h3><p>Stack Frame 与 rust 的声明周期相关。</p><p>每个函数都拥有自己的 Frame 当函数返回时，它的 Frame 就被回收了,构成函数本地变量值的那些字节不会立即擦除， 但访问它们也是不安全的。</p><p>因为它们可能被后续的函数调用所重写（如果后续函数调用的 Frame 与回收的这个有重合的话）。</p><p>但即使没有被重写，它们也可能包含无法合法使用的值。例如函数返回后被移动的值。</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>当一个函数即需要兼容 <code>&amp;str</code>和 <code>String</code>的参数。</p><blockquote><p>$str 存在 Stack 上，String 存储在 Heap 上。</p></blockquote><p><code>AsRef&lt;T&gt;</code> 要求参数实现到 T 这个类型的引用，即使参数不是这样的类型。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_strong</span>&lt;T: <span class="hljs-built_in">AsRef</span>&lt;<span class="hljs-type">str</span>&gt;&gt;(password:T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>  password.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">len</span>() &gt; <span class="hljs-number">6</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>Into&lt;String&gt;</code> 要求参数转化为 String 这个类型。但是会涉及比较多的步骤。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_strong</span>&lt;T: <span class="hljs-built_in">Into</span>&lt;<span class="hljs-type">String</span>&gt;&gt;(password:T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>  password.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">len</span>() &gt; <span class="hljs-number">6</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Heap-堆内存"><a href="#Heap-堆内存" class="headerlink" title="Heap 堆内存"></a>Heap 堆内存</h2><p>Heap 在内存中是混乱的，它是一个内存池，并没有绑定到当前程序的调用栈，是为在编译时没有已知大小的类型准备的。</p><p>例如：</p><ul><li>切片类型 [T]</li><li>随着程序运行动态改变的 String,Vec<T></li><li>trait 对象，它允许程序员来模拟一些动态语言的特性：通过允许将多个类型放进一个容器</li><li>一些类型的大小不会改变，但是无法告诉编译器需要分配多少内存</li></ul><p>Heap 允许你显式的分配连续的内存块。当这么做时，你会得到一个指针，它指向内存块开始的地方。</p><p>Heap 内存中的值会一直有效，直到你对它显式的释放。如果你想让值活得比当前函数 frame 的生命周期还长，就很有用。</p><h3 id="Heap-线程安全"><a href="#Heap-线程安全" class="headerlink" title="Heap 线程安全"></a>Heap 线程安全</h3><p>如果想把值送到另一个线程，当前线程可能根本无法与那个线程共享 stack frames，你就可以把它存放在 heap 上。</p><p>因为函数返回时 heap 上的分配并不会消失，所以你在一个地方为值分配内存，把指向它的指针传给另一个线程，就可以让那个线程继续安全的操作于这个值。</p><p>换一种说法：当你分配 heap 内存时，结果指针会有一个无约束的生命周期，你的程序让它活多久都行。</p><h3 id="Heap-机制"><a href="#Heap-机制" class="headerlink" title="Heap 机制"></a>Heap 机制</h3><p>Heap 上面的变量必须通过指针访问。Rust 里与 Heap 交互的首要机制就是 Box 类型。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>:<span class="hljs-type">i32</span> = <span class="hljs-number">40</span>; <span class="hljs-comment">// Stack</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>:<span class="hljs-type">Box</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">60</span>); <span class="hljs-comment">// Heap</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span>:<span class="hljs-type">i32</span> = a + *b; <span class="hljs-comment">// 用指针访问。</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>当<code>Box:new（value）</code>时，值就会放在 heap 上，返回的<code>Box&lt;T&gt;</code>就是指向 heap 上该值的指针。当 box 被丢弃时，内存就被释放。</p><p>如果忘记释放 heap 内存，就会导致内存泄漏<br>有时你就想让内存泄露。</p><p>例子：在生命周期没有结束的时候手动释放。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = *a + *b;<br>    <span class="hljs-title function_ invoke__">drop</span>(a);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="如何让内存泄露-🔥"><a href="#如何让内存泄露-🔥" class="headerlink" title="如何让内存泄露 🔥"></a>如何让内存泄露 🔥</h4><p>例如有一个只读的配置，整个程序都需要访间它。就可以把它分配在 heap 上。</p><p>通过 Box:leak 得到一个’static 引用，从而显式的让其进行泄露。</p><h2 id="Static-静态内存"><a href="#Static-静态内存" class="headerlink" title="Static 静态内存"></a>Static 静态内存</h2><ul><li>static 内存实际是一个统称，它指的是程序编译后的文件中几个密切相关的区域。<ul><li>当程序执行时，这些区域会自动加载到你程序的内存里。</li></ul></li><li>static 内存里的值在你的程序的整个执行期间会一直存活。</li><li>程序的 static 内存是包含程序二进制代码的（通常映射为只读的）。<ul><li>随着程序的执行，它会在本文段的二进制代码中挨个指令进行遍历，而当函数被调用时就进行跳跃。</li></ul></li><li>static 内存会持有使用 static 声明的变量的内存，也包括某些常量值， 例如字符串。</li></ul><h3 id="‘static"><a href="#‘static" class="headerlink" title="‘static"></a>‘static</h3><p>‘static 是特殊的生命周期,它的名字就是来自于 static 内存区，它将引用标记为只要 static 内存还存在（程序关闭前），那么引用就合法。</p><p>static 变量的内存在程序开始运行时就分配了，到 static 内存中变量的引用，按定义来说，就是’static 的，因为在程序关闭前它不会被释放。</p><p>一旦你创建了一个’static 生命周期的引用，就程序的其余部分而言，它所指向的内容都可能在 static 内存中，因为程序想要使用它多久就可以使用多久。</p><h4 id="T-static"><a href="#T-static" class="headerlink" title="T:&#39;static"></a><code>T:&#39;static</code></h4><p>其表示类型 T 可以存活我们想要的任何时长（直到程序关闭），同时这也要求 T 是拥有所有权的和自给自足的。</p><p>要求这个类型不借用其他的值，要么借用的值也都是<code>‘static</code>的。</p><h3 id="const-与-static-的区别"><a href="#const-与-static-的区别" class="headerlink" title="const 与 static 的区别"></a>const 与 static 的区别</h3><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> x:<span class="hljs-type">i32</span> = <span class="hljs-number">123</span>;<br></code></pre></div></td></tr></table></figure><ul><li>const 关键字会把紧随它的东西声明为常量</li><li>常量可在编译时完全计算出来。</li><li>在编译期间，任何引用常量的代码会被替换为常量的计算结果值</li><li>常量没有内存或关联其它存储（因为它不是一个地方）</li><li>可以把常量理解为某个特殊值的方便的名称</li></ul><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><p>Rust 内存模型的核心思想：所有的值都只有一个所有者。</p><p>只有一个位置（通常是作用域）来负责释放每个值。</p><ul><li>这是通过借用检查器来实现的。</li><li>如果值移动了（赋值新变量、推到 Vec、置于 Heap），其所有者也变成新的位置了。</li></ul><p>有些类型不遵守这个规则。</p><ul><li>如果值的类型实现了 Copy trait，重新赋值时到新内存地址时发生的是复制，而不是移动。</li><li>大多数原始类型，例如整数、浮点类型等，都实现了 Copy。</li></ul><h3 id="如何实现-Copy"><a href="#如何实现-Copy" class="headerlink" title="如何实现 Copy"></a>如何实现 Copy</h3><p>实现 Copy trait 必须可以按位（bit）来复制值,不包括以下类型。</p><ol><li>含有 non-Copy 类型的类型</li><li>拥有这类资源的类型：当类型的值被丢弃时，必须被释放该资源。</li></ol><p>假设 Box 是 Copy 的，并且进行赋值 <code>box1 = box2</code><br>那么它们在走出内存的时候，都会认为在 Heap 上，有一段内存是属于自己的。<br>都会去释放这个内存，这样就会产生问题。</p><h2 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h2><h3 id="T-共享引用（不可变的引用）"><a href="#T-共享引用（不可变的引用）" class="headerlink" title="&amp;T 共享引用（不可变的引用）"></a>&amp;T 共享引用（不可变的引用）</h3><p>共享引用背后的值不可变，因此又叫不可变引用。</p><p><code>&amp;T</code>就是可以共享的指针，可以同时存在任意数量的引用的引用指向同一个值，每个共享的引用都实现了 Copy.</p><h3 id="mut-T-可变引用"><a href="#mut-T-可变引用" class="headerlink" title="&amp;mut T 可变引用"></a>&amp;mut T 可变引用</h3><p>可变引用都是单一线程独占的,可变引用只允许你修改引用所指向的内存地址。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>:<span class="hljs-type">i32</span> = <span class="hljs-number">42</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">y</span>: &amp;<span class="hljs-type">i32</span> = &amp;x;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">z</span>:&amp;<span class="hljs-keyword">mut</span> &amp;<span class="hljs-type">i32</span> = &amp;<span class="hljs-keyword">mut</span> y; <span class="hljs-comment">//  可以通过z来修改y的值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>y 前面有 mut 关键字，因此也可以修改成其他值的引用，简单来说就是 y 可以修改成其他值，但是不可以通过 y 来修改 x 的值。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">y</span>: &amp;<span class="hljs-type">i32</span> = &amp;x;<br></code></pre></div></td></tr></table></figure><p>z 前面没有 mut 关键字，因此 z 不能持有其它的引用，只能持有 y 的引用。<br>但是可以通过 z 来修改 y 的值。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">z</span>:&amp;<span class="hljs-keyword">mut</span> &amp;<span class="hljs-type">i32</span> = &amp;<span class="hljs-keyword">mut</span> y;<br></code></pre></div></td></tr></table></figure><h3 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h3><p>类型可以通过共享引用来修改值。主要分为两种。</p><h4 id="通过共享引用获得可变引用"><a href="#通过共享引用获得可变引用" class="headerlink" title="通过共享引用获得可变引用"></a>通过共享引用获得可变引用</h4><p>有<code>Mutex</code>,<code>RefCell</code> ，它们如果对某个值提供了可变引用，那么同时只会存在一个可变引用。</p><p>依赖 <code>UnsafeCell</code>类型，这是通过共享引用修改值的唯一方式。</p><h4 id="通过共享引用可以替换值"><a href="#通过共享引用可以替换值" class="headerlink" title="通过共享引用可以替换值"></a>通过共享引用可以替换值</h4><p><code>std:syn:atomic</code>,<code>srd::cell::Cell</code>,它们没有提供可变引用到内部值，提供的是就地操作值的方法。</p><blockquote><p>例：无法获得到 usize 或 i32 的直接引用，但是可以读取和替换值</p></blockquote><h3 id="Cell-类型"><a href="#Cell-类型" class="headerlink" title="Cell 类型"></a>Cell 类型</h3><p>Cell 提供对值的整体替换，返回值的副本，其无法跨线程共享，内部值不会发生并发修改，即便是通过共享引用发生的修改。</p><p>不会提供到 Cell 内部的值的引用，因此可以一直移动它。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Rust 里每个引用都有生命周期，它就是引用保持合法的作用域， 大多数时候是隐式和推断出来的。<br>对某个变量取得引用时生命周期开始，当变量移动或离开作用域时生命周期结束。</p><h3 id="借用检查器-（Borrow-Checker）"><a href="#借用检查器-（Borrow-Checker）" class="headerlink" title="借用检查器 （Borrow Checker）"></a>借用检查器 （Borrow Checker）</h3><p>每当具有某个生命周期 a 的引用被使用，借用检查器都会检查‘a<br>是否还存活,流程如下：</p><ol><li>追踪路径直到‘a 开始（获得引用）的地方</li><li>从这开始，检查沿着路径是否存在冲突</li><li>保证引用指向一个可安全访问的值</li></ol><h4 id="生命周期重启-（生命周期更新）"><a href="#生命周期重启-（生命周期更新）" class="headerlink" title="生命周期重启 （生命周期更新）"></a>生命周期重启 （生命周期更新）</h4><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span>:<span class="hljs-type">Box</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">z</span> =  &amp;x; <span class="hljs-comment">// z的生命周期开始了</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span> &#123;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,z);<br>  x = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(i); <span class="hljs-comment">// x的生命周期在这里被更新了</span><br>  z = &amp;x; <span class="hljs-comment">// 这里必须更新z的生命周期，也就是更新了x的引用,不更新引用将会报错，因为x一直处于被z借用的状态，无法被重新赋值。</span><br>&#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,z);<br></code></pre></div></td></tr></table></figure><p>借用检测器是保守的，如果不确定某个借用是否合法，借用检查器就会拒绝该借用。</p><p>借用检查器有时需要帮助来理解某个借用为什么是合法的，这也是 Unsafe Rust 存在的部分原因。</p><h2 id="泛型生命周期"><a href="#泛型生命周期" class="headerlink" title="泛型生命周期"></a>泛型生命周期</h2><p>主要是为了借用检查器能检查一些在类型中存储引用的生命周期。<br>例如：在该类型方法中返回引用，且存活比 self 的长。</p><p>rust 允许你基于一个或多个生命周期将类型的定义泛型化。但是这会让类型签名更加的复杂，因此需要遵循以下两点：</p><ul><li>只有类型包含多个引用时，你才应该使用多个生命周期参数</li><li>它方法返回的引用只应绑定到其中一个引用的生命周期</li></ul><p>多个类型引用示例</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StrSplit</span>&lt;<span class="hljs-symbol">&#x27;s</span>, <span class="hljs-symbol">&#x27;p</span>&gt; &#123;<br>    delimiter: &amp;<span class="hljs-symbol">&#x27;p</span> <span class="hljs-type">str</span>, <span class="hljs-comment">// 第二个泛型生命周期</span><br>    document: &amp;<span class="hljs-symbol">&#x27;s</span> <span class="hljs-type">str</span>,  <span class="hljs-comment">// 第一个泛型生命周期</span><br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;s</span>, <span class="hljs-symbol">&#x27;p</span>&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">StrSplit</span>&lt;<span class="hljs-symbol">&#x27;s</span>, <span class="hljs-symbol">&#x27;p</span>&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = &amp;<span class="hljs-symbol">&#x27;s</span> <span class="hljs-type">str</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>        todo!()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">str_before</span>(s: &amp;<span class="hljs-type">str</span>, c: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">str</span>&gt; &#123;<br>    StrSplit &#123;<br>        document: s,<br>        delimiter: &amp;c.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-comment">// 这里的生命周期是比较短的，是当前函数所拥有的</span><br>    &#125;<br>    .<span class="hljs-title function_ invoke__">next</span>()<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="生命周期扩展-（Variance）"><a href="#生命周期扩展-（Variance）" class="headerlink" title="生命周期扩展 （Variance）"></a>生命周期扩展 （Variance）</h3><p>如果 A 是 B 的子类，那么 A 至少和 B 一样有用。这跟其他类型的继承或者叫扩展是相同的。</p><p>比如：如果函数接收 &amp;’a str 的参数，那么就可以传入 &amp;’static str 的参数。因为’static 是 a 的“子类”，‘static 至少跟任何‘a 存活的一样长。</p><h4 id="三种-Variance"><a href="#三种-Variance" class="headerlink" title="三种 Variance"></a>三种 Variance</h4><ul><li><p>covariant(协变)： 某类型只能用“子类型”替代</p><ul><li>例如：&amp;’staticT 可替代 &amp;’aT</li></ul></li><li><p>invariant(不变)：必须提供指定的类型</p><ul><li>例如：&amp;mutT，对于 T 来说就是 invariant 的</li></ul></li><li><p>contravariant(逆变)：函数对参数的要求越低，参数可发挥的作用越大</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x1</span> : &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 更有用一些</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x2</span>: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_fun1</span>(&amp;<span class="hljs-symbol">&#x27;static</span> str1) <span class="hljs-comment">// 限制更大</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_fun2</span>(&amp;<span class="hljs-symbol">&#x27;a</span> str2) <span class="hljs-comment">// 限制宽松</span><br></code></pre></div></td></tr></table></figure><p>如上所示，在函数中，限制更宽松将会更有用一些，而在外部的话，存活得更久则更有用一些。</p><p>下面的示例为什么只有一个字段却使用两个生命周期呢？</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MutStr</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt; &#123;<br>    s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">r</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br>    *MutStr &#123; s: &amp;<span class="hljs-keyword">mut</span> r &#125;.s = <span class="hljs-string">&quot;world&quot;</span>; <span class="hljs-comment">// 对外部的r创建了一个可变的引用</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r); <span class="hljs-comment">// 打印 world</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述示例中，<code>&#39;a</code>是可变的，<code>&#39;b</code>是不可变的。而在</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">*MutStr &#123; s: &amp;<span class="hljs-keyword">mut</span> r &#125;.s = <span class="hljs-string">&quot;world&quot;</span>;<br></code></pre></div></td></tr></table></figure><p>的时候，对创建的 s 进行了修改，其对应的就是<code>&#39;a</code>这个生命周期。</p><p>而 <code>*MutStr</code>结构体里面的 s 是静态的，因为 r 的生命周期是静态的，因此对于着 <code>&#39;b</code> 这个不可变的生命周期。</p><h2 id="内存对齐-repr-transparent"><a href="#内存对齐-repr-transparent" class="headerlink" title="内存对齐 repr(transparent)"></a>内存对齐 repr(transparent)</h2><h3 id="repr-C"><a href="#repr-C" class="headerlink" title="#[repr(C)]"></a><code>#[repr(C)]</code></h3><p>C 的对齐方案编译较快，但是运行较慢。</p><p>这个对齐方式在内存中有一定的限制，需要将所有字段按原 struct 定义的顺序放置。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[repr(C)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>  tiny:<span class="hljs-type">bool</span>, <span class="hljs-comment">// 1byte 填充3个，和normal组成8个</span><br>  normal:<span class="hljs-type">u32</span>, <span class="hljs-comment">// 4bytes</span><br>  small:<span class="hljs-type">u8</span>, <span class="hljs-comment">// 1 byte  填充 7个对齐8个</span><br>  long:<span class="hljs-type">u64</span>, <span class="hljs-comment">// 8bytes</span><br>  short:<span class="hljs-type">u16</span>, <span class="hljs-comment">// 2bytes 填充6个进行对齐</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个结构体最大的是 long 拥有 8bytes，因此 tiny 后面将会填充 3 个字节，跟 normal4 个字节组合成 8 个字节。</p><p>而 small 拥有 1 个字节，它将继续填充 7 个字节，跟 8 字节对齐。</p><p>后面的 short 也将继续填充 6 字节，跟 8 字节对齐。一共 32 字节。</p><h3 id="repr-Rust"><a href="#repr-Rust" class="headerlink" title="#[repr(Rust)]"></a><code>#[repr(Rust)]</code></h3><p><code>repr(Rust)</code>允许重新对字段排序，可按大小递减的顺序排列。</p><p>对于 Foo 例子来说就不需要填充了：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[repr(Rust)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>  long:<span class="hljs-type">u64</span>, <span class="hljs-comment">// 8bytes</span><br>  normal:<span class="hljs-type">u32</span>, <span class="hljs-comment">// 4bytes // 下面组成8字节，跟上面的对齐</span><br>  short:<span class="hljs-type">u16</span>, <span class="hljs-comment">// 2bytes</span><br>  small:<span class="hljs-type">u8</span>, <span class="hljs-comment">// 1 byte</span><br>  tiny:<span class="hljs-type">bool</span>, <span class="hljs-comment">// 1byte</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>直接把最大的字段放前面，这样一下子就知道需要对齐到多少字节。一共 16bytes。</p><p>对布局的保证少了，编译器有余地进行重新安排，代码会更高效。但是编译时间会长一点。</p><h3 id="repr-packed-无填充布局"><a href="#repr-packed-无填充布局" class="headerlink" title="$[repr(packed)] 无填充布局"></a><code>$[repr(packed)]</code> 无填充布局</h3><p>可以告诉编译器字段之间无需任何填充，但是需要承担不对齐访问的性能损失，并且可能会导致代码运行速度慢.<br>极端情况下，如果 CPU 仅支持对齐操作，可导致程序崩溃。</p><p>什么场景下使用：</p><ul><li>内存有限，类型实例较多</li><li>通过低带宽网络连接发送内存表示</li></ul><h3 id="repr-align-n-给特定字段或类型更大的对齐"><a href="#repr-align-n-给特定字段或类型更大的对齐" class="headerlink" title="#[repr(align(n))] 给特定字段或类型更大的对齐"></a><code>#[repr(align(n))]</code> 给特定字段或类型更大的对齐</h3><p>这个主要是用来避免伪共享。</p><blockquote><p>伪共享 （false sharing）：两个不同的 CPU 访问共享同一个缓存行的不同变量时， 就发生了伪共享。理论上它们可以并行操作，但最终它们都争相更新缓存中的同一个条目。它可导致并发类程序中的巨大性能降级。</p></blockquote><h2 id="Sized-类型和宽指针"><a href="#Sized-类型和宽指针" class="headerlink" title="Sized 类型和宽指针"></a>Sized 类型和宽指针</h2><h3 id="Sized"><a href="#Sized" class="headerlink" title="Sized"></a>Sized</h3><p>rust 中除了两个常见的类型 Trait 对象和切片(slice)类型，大多数类型自动实现了 Sized,它的大小在编译时就已知了。</p><p>自定义的 Type Bound 自动包含<code>T:Sized</code>，除非你写明<code>T:?Sized</code>。</p><h3 id="宽指针-Wide-Pointer"><a href="#宽指针-Wide-Pointer" class="headerlink" title="宽指针(Wide Pointer)"></a>宽指针(Wide Pointer)</h3><p>宽指针就是普通指针，附加了一个字大小(word-sized)的字段。</p><p>如果需要接收 DST（trait 对象，切片等）类型就需要宽指针，当引用 DST 时，编译器就会自动为你组建一个宽指针。</p><p>通过将非 Sized 类型放在宽指针后边，就可弥补 Sized 和非 Sized 类型间的差距。</p><p>例如：切片 slice, 它的附加信息就是切片的长度。</p><blockquote><p>备注：Box 和 Arc 都支持存储宽指针，所以它们都支持<code>T:?Sized</code></p></blockquote><h2 id="编译和分派"><a href="#编译和分派" class="headerlink" title="编译和分派"></a>编译和分派</h2><h3 id="静态分派-static-dispatch"><a href="#静态分派-static-dispatch" class="headerlink" title="静态分派 (static dispatch)"></a>静态分派 (static dispatch)</h3><p>静态分派的意思是需要为每个类型复制一份（方法体），每份都有自己的地址，可用来跳转。</p><p>编译器会复制泛型类型以及所有的实现块。并把每个实例的泛型参数使用具体类型替换。</p><p>例如：Vec<i32>，就是对 Vec 做一个完整的复制，所有遇到的 T 都换成 i32。</p><blockquote><p>注意：编译器其实不会做完整的复制粘贴，它只复制你用的代码.</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">String</span> &#123;<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">contains</span>(&amp;<span class="hljs-keyword">self</span>,p <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Pattern</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>    p.<span class="hljs-title function_ invoke__">is_contained_in</span>(<span class="hljs-keyword">self</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>p 参数是 <code>impl Pattern</code>类型，针对不同的 Pattern 类型，该方法都会复制一遍。</p><p>因为我们需要知道 is_contained_in 方法的地址，以便进行调用。CPU 需要知道在哪跳转和继续执行。<br>对于任何给定的 Pattern，编译器知道那个地址是 Pattern 类型实现 Trait 方法的地址。<br>不存在一个可给任意类型用的通用地址。</p><h4 id="单态化-monomorphization"><a href="#单态化-monomorphization" class="headerlink" title="单态化 (monomorphization)"></a>单态化 (monomorphization)</h4><p>从一个泛型类型到多个非泛型类型的过程叫做单态化。当编译器开始优化代码时，就好像根本没有泛型！</p><ul><li>每个实例都是单独优化的，具有了所有的已知类型</li><li>所以 is_contained_in 方法调用的执行效率就如同 Trait 不存在一样</li><li>编译器对涉及的类型完全掌握，甚至可以将它进行 inline 实现</li></ul><p>但是单态化也是有代价的</p><ul><li>所有的实例需要单独编译，编译时间增加（如果不能优化编译）</li><li>每个单态化的函数会有自己的一段机器码，让程序更大</li><li>指令在泛型方法的不同实例间无法共享，CPU 的指令缓存效率降低，因为它需要持有相同指令的多个不同副本</li></ul><h3 id="动态分派-dynamic-dispatch"><a href="#动态分派-dynamic-dispatch" class="headerlink" title="动态分派 (dynamic dispatch)"></a>动态分派 (dynamic dispatch)</h3><p>动态分派，使代码可以调用泛型类型上的 trait 方法，而无需知道具体的类型。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">String</span> &#123;<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">contains</span>(&amp;<span class="hljs-keyword">self</span>,p &amp;<span class="hljs-keyword">dyn</span> Pattern) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>    p.<span class="hljs-title function_ invoke__">is_contained_in</span>(&amp;*<span class="hljs-keyword">self</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>它只要求调用者提供两个信息：</p><ol><li>Pattern 的地址</li><li>is_contained_in 的地址</li></ol><h4 id="vtable"><a href="#vtable" class="headerlink" title="vtable"></a>vtable</h4><p>调用者会提供指向一块内存的指针，它叫做虚方法表（virtual method table）或叫 vtable。它持上例该类型所有的 trait 方法实现的地址，其中一个就是 is_contained_in。</p><p>当代码想调用提供类型的一个 trait 方法时，就会从 vtable 查询 is_contained_in 方法的实现地址，并调用，这允许我们使用相同的函数体，而不关心调用者想要使用的类型。</p><p>每个 vtable 还包含具体类型的布局和对齐信息</p><h4 id="保证对象安全"><a href="#保证对象安全" class="headerlink" title="保证对象安全"></a>保证对象安全</h4><ul><li>trait 所有的方法都不能是泛型的，也不可以使用 Self</li><li>trait 不可拥有静态方法（我们无法知道在哪个实例上调用的方法）</li></ul><p>动态分派的优点是，编译时间减少提升 CPU 指令缓存效率。</p><p>缺点是，编译器无法对特定类型优化,只能通过 vtable 调用。<br>函数直接调用方法的开销增加。trait object 上的每次方法调用都需要查 vtable。</p><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>在 library 中使用静态分派，因为无法知道用户的需求,这样用户可自行选择,如果使用动态分派，用户也就没有选择。</p><p>在 binary 中使用动态分派,  因为 binary 是最终代码，并且动态分派使代码更整洁（省去了泛型参数），编译更快,但是以边际性能为代价。</p><h2 id="Trait-泛型方式"><a href="#Trait-泛型方式" class="headerlink" title="Trait 泛型方式"></a>Trait 泛型方式</h2><p>有两种：</p><ul><li>泛型类型参数：<code>trait Foo&lt;T&gt;</code></li><li>关联类型：<code>trait Foo &#123;type Bar;&#125;</code></li></ul><p>区别</p><ul><li>使用关联类型：对于指定类型的 trait 只有一个实现</li><li>使用泛型类型参数：多个实现</li></ul><p>简单来说可以的话尽量使用关联类型。</p><h3 id="泛型-类型参数-Trait"><a href="#泛型-类型参数-Trait" class="headerlink" title="泛型 (类型参数) Trait"></a>泛型 (类型参数) Trait</h3><p>泛型 Trait 必须指定所有的泛型类型参数，并重复写这些参数的 Bound，维护较难。<br>如果添加泛型类型参数到某个 Trait，该 Trait 的所有用户必须都进行更新代码。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PartialEq</span>&lt;BookFormat&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Book</span><br>Fromlterator::&lt;U32&gt;::from_iter<br></code></pre></div></td></tr></table></figure><h3 id="关联类型-Trait"><a href="#关联类型-Trait" class="headerlink" title="关联类型 Trait"></a>关联类型 Trait</h3><p>编译器只需要知道实现 Trait 的类型。</p><p>Bound 可完全位于 Trait 本身，不必重复使用，未来再添加 关联类型 也不影响用户使用。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Contains</span> &#123;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">A</span>;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">B</span>;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">contains</span>(&amp;<span class="hljs-keyword">self</span>, _: &amp;<span class="hljs-keyword">Self</span>::A, _: &amp;<span class="hljs-keyword">Self</span>:B) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>具体的类型会决定 Trait 内关联类型的类型，无需使用消除歧义的函数。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Contains</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Container</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">A</span> = <span class="hljs-type">i32</span>;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">B</span> = <span class="hljs-type">i32</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">contains</span>(&amp;<span class="hljs-keyword">self</span>, num_1: &amp;<span class="hljs-type">i32</span>, num_2: &amp;<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        (&amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> == num_1) &amp;&amp; (&amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">1</span> == num_2)<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">first</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123; <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">last</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123; <span class="hljs-keyword">self</span>.<span class="hljs-number">1</span> &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意：</p><ul><li>不可以对多个 Target 类型来实现 Deref</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Deref</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span>: ?<span class="hljs-built_in">Sized</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Target;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>不可以使用多个 Item 来实现 Iterator</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Interator</span> &#123;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="孤儿规则-orphan-rule"><a href="#孤儿规则-orphan-rule" class="headerlink" title="孤儿规则 (orphan rule)"></a>孤儿规则 (orphan rule)</h2><p>定义：对于给定的类型和方法，只会有一个正确的选择，用于该方法对该类型的实现。</p><p>只要 trait 或者 类型在你本地的 crate，那就可以为该类型实现该 trait。</p><p>可以为你的类型实现 Debug；可以为 bool 实现 MyTrait，不能为 bool 实现 Debug。</p><h3 id="Blanket-Implementation-一揽子的实施"><a href="#Blanket-Implementation-一揽子的实施" class="headerlink" title="Blanket Implementation (一揽子的实施)"></a>Blanket Implementation (一揽子的实施)</h3><p><code>impl&lt;T&gt;MyTrait for T where T：</code></p><p>例如：<code>impl&lt;T: Display&gt; ToString for T｛｝</code></p><p><code>where T</code>实现一系列的类型,不局限于一个特定的类型，而是应用于更广泛的类型。<br>只有定义 trait 的 crate 允许使用 Blanket Implementation。</p><p>注意：添加 Blanket Implementation 到现有 trait 属于破坏性变化。</p><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>目前包括，<code>&amp;</code>,<code>&amp;mut</code>,<code>Box</code>,它们被标记为<code>#[fundamental]</code>,并且因为太基础了，需要允许任何人在它们上实现 trait（即使违反孤儿规则）。因此在孤儿规则检查前，它们就会被抹除。</p><h3 id="Covered-Implementation-覆盖实施"><a href="#Covered-Implementation-覆盖实施" class="headerlink" title="Covered Implementation (覆盖实施)"></a>Covered Implementation (覆盖实施)</h3><p>有时需要为外部类型实现外部 trait。</p><p>例如：<code>impl From&lt;MyType&gt; for Vec&lt;i32&gt;</code></p><p>孤儿规则制定了一个狭窄的豁免：允许在非常特定的情况下为外来类型实现外来 trait。</p><p>例如：<code> impl&lt;Pi..=Pn&gt; ForeignTrait&lt;Ti..=Tn&gt; for T0</code></p><p>只在以下条件被允许：</p><ul><li>至少有一个 Ti 是本地类型。</li><li>没有 T 在第一个这样的 Ti 前（T 是指泛型类型 PI.&#x3D;Pn 中的一个）。</li><li>泛型类型参数 Ps 允许出现在 TO..Ti，只要它们被某种中间 （intermediate）类型所 cover。</li></ul><p>如果 T 作为其他类型（例 Vec<T>）的类型参数出现，那就说 T 被 cover 了。而 T 只作为本身，或者位于基础类型后（例 &amp;T），就无法被覆盖了。</p><p>例子：</p><ul><li>符合的：</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;T&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyType</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;T&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyType</span>&lt;T&gt;<br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;MyType&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Vec</span>&lt;T&gt;<br><span class="hljs-keyword">impl</span>&lt;T&gt; ForeignTrait&lt;MyType, T&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Vec</span>&lt;T&gt;<br></code></pre></div></td></tr></table></figure><ul><li>不符合的：</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; ForeignTrait <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;T&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;<span class="hljs-type">Vec</span>&lt;T&gt;&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;MyType&lt;T&gt;&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;T&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Vec</span>&lt;T&gt;<br><span class="hljs-keyword">impl</span>&lt;T&gt; ForeignTrait&lt;T, MyType&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Vec</span>&lt;T&gt;<br></code></pre></div></td></tr></table></figure><ul><li>为现有 trait 添加新的实现，且至少包含一个新的本地类型，该本地类型<br>满足豁免条件，这就是非破坏性的变化</li><li>为现有 trait 添加的实现不满足上述要求，就是破坏性变化</li></ul><p>注意：</p><ul><li><p><code>impl&lt;T&gt; ForeignTrait&lt;LocalType, T&gt; for ForeignType</code>，本地类型出现在前面，是合法的。</p></li><li><p><code>impl&lt;T&gt;ForeignTrait&lt;T, LocalType&gt; for ForeignType</code>，T 出现在本地类型前面是非法的。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奇门遁甲-排盘</title>
    <link href="/2024/01/03/%E5%A5%87%E9%97%A8%E9%81%81%E7%94%B2-%E6%8E%92%E7%9B%98/"/>
    <url>/2024/01/03/%E5%A5%87%E9%97%A8%E9%81%81%E7%94%B2-%E6%8E%92%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>奇门遁甲是以历史上的九宫八卦阵演变而来。<br>九宫八卦是以空间为主要特征的全息符号，六十甲子（十天干 与十二地支的组合）是以时间为主要特征的全息符号。奇门遁甲就 是将这二者巧妙地组合在一起，<br>构成一个融时空为一体，包括天、地、人、神（自然界基种神秘力量）在内，多维立体的动态宇宙思维 模型，并以提取时间信息为主，<br>进行系统思维、辨识，从而达到预测 万事万物、选择有利时空进行趋吉避内的古典数术学、预测学，或眼预测术、预测方法，均可。</p><div class="note note-secondary">            <p>时间和空间的融合，听起来很神奇,但是实践是检验真理的唯一标准。文章内容参考自《神奇之门》。</p>          </div><h2 id="十天干"><a href="#十天干" class="headerlink" title="十天干"></a>十天干</h2><p>甲、乙、丙，丁,戊，已、庚、辛、壬、癸，这十个天干符号，在奇门遁甲排兵布阵中，代表着军事上的特定事物。</p><h3 id="遁甲"><a href="#遁甲" class="headerlink" title="遁甲"></a>遁甲</h3><p>甲为元帅为主将，他经常隐蔽在阵中，所以叫遁甲。甲为阳木。</p><h3 id="三奇-🌞🌛✨"><a href="#三奇-🌞🌛✨" class="headerlink" title="三奇 🌞🌛✨"></a>三奇 🌞🌛✨</h3><p>乙、丙、丁为三奇。<br>只需记住：乙为日奇，丙为月奇，丁为星奇。乙(甲的妹妹)为阴木，丙为阳火，丁(玉女，有女生含义)为阴火</p><h3 id="六仪-🚩"><a href="#六仪-🚩" class="headerlink" title="六仪 🚩"></a>六仪 🚩</h3><p>戊、己、庚、辛、壬、癸，为六面旗帜。<br>戊为阳土（正黄旗），己为阴土（镶黄旗），庚为阳金（正白旗），辛为阴金（镶白旗），壬为阳水（正黑旗），癸为阴水（镶黑旗）。</p><h2 id="时辰六旬与遁甲"><a href="#时辰六旬与遁甲" class="headerlink" title="时辰六旬与遁甲"></a>时辰六旬与遁甲</h2><p>甲为元帅，需要仓于各自的旗帜下面，这是固定搭配，此为遁甲。</p><p><font color="rgb(236,174,0)">甲子旬</font>: 甲子 乙丑 丙寅 丁卯 戊辰 己巳 庚午 辛未 壬申 癸酉 (戌亥空亡)<br><font color="rgb(236,174,0)">甲戌旬</font>: 甲戌 乙亥 丙子 丁丑 戊寅 己卯 庚辰 辛巳 壬午 癸未 (申酉空亡)<br><font color="rgb(236,174,0)">甲申旬</font>: 甲申 乙酉 丙戌 丁亥 戊子 己丑 庚寅 辛卯 壬辰 癸巳 (午未空亡)<br><font color="rgb(236,174,0)">甲午旬</font>: 甲午 乙未 丙申 丁酉 戊戌 己亥 庚子 辛丑 壬寅 癸卯 (辰巳空亡)<br><font color="rgb(236,174,0)">甲辰旬</font>: 甲辰 乙巳 丙未 丁未 戊申 己酉 庚戌 辛亥 壬子 癸丑 (寅卯空亡)<br><font color="rgb(236,174,0)">甲寅旬</font>: 甲寅 乙卯 丙辰 丁巳 戊午 己未 庚申 辛酉 壬戌 癸亥 (子丑空亡)</p><p>我们可以看到，每一旬个有一个甲，正好遁于六仪之下。</p><p><font color="rgb(236,174,0)">甲子戊、甲戌己、甲申庚、甲午辛、甲辰壬、甲寅癸</font> 这几个需要背，需要知道藏的是什么甲。</p><p><font color="rgb(236,174,0)">戊己庚辛壬癸乙丙丁</font> 是九宫队形，也需要背。</p><blockquote><p>今年正好是甲辰龙。</p></blockquote><h3 id="阴遁几局和阳遁几局"><a href="#阴遁几局和阳遁几局" class="headerlink" title="阴遁几局和阳遁几局"></a>阴遁几局和阳遁几局</h3><p>具体面言，所谓阳遁，就是从一宫到九宫，按戊、己、庚、辛、壬、癸、丁、丙、乙这个顺序顺排。<br>所谓阴遁，就是从九官到一宫，按着这个顺序逆排。<br>还有就是<font color="rgb(236,174,0)">元帅甲子戊遁在几宫，就是奇门遁甲的几局</font>。<br>即阳遁时，甲子戊在一宫时，就是阳遁一局：甲子戊在二宫<br>时，就是阳遁二局。依次类推。阴遁时，甲子戊在九宫，就是阴遁九局，在八宫，就是阴遁八局，依次类推。</p><h2 id="阳遁九局，阴遁九局"><a href="#阳遁九局，阴遁九局" class="headerlink" title="阳遁九局，阴遁九局"></a>阳遁九局，阴遁九局</h2><p>八卦的顺序为:<font color="rgb(236,174,0)">戴九履一 左三右七 四二为肩 八六为足</font>。<br>并且从一到九按戊、己、庚、辛、壬、癸、丁、丙、乙这个顺序顺排，是为阳遁。这个顺序需要背诵。</p><p>就看甲子戊，落再哪一宫，就是几局。</p><h3 id="阳遁"><a href="#阳遁" class="headerlink" title="阳遁"></a>阳遁</h3><p>阳遁九局。</p><div class="grid-parent">    <div class="grid-box">      <div >辛(4)</div>      <div >乙(9)</div>      <div >己(2)</div>      <div >庚(3)</div>      <div >壬(5)</div>      <div >丁(7)</div>      <div >丙(8)</div>      <div class="earth" >戊(1)</div>      <div >癸(6)</div>  </div>  <div class="grid-box">      <div >庚(4)</div>      <div >丙(9)</div>      <div class="earth">戊(2)</div>      <div >己(3)</div>      <div >辛(5)</div>      <div >癸(7)</div>      <div >丁(8)</div>      <div >乙(1)</div>      <div >壬(6)</div>  </div>   <div class="grid-box">      <div >己(4)</div>      <div >丁(9)</div>      <div >乙(2)</div>      <div class="earth">戊(3)</div>      <div >庚(5)</div>      <div >壬(7)</div>      <div >癸(8)</div>      <div >丙(1)</div>      <div >辛(6)</div>  </div>  <div class="grid-box">      <div class="earth">戊(4)</div>      <div >癸(9)</div>      <div >丙(2)</div>      <div >乙(3)</div>      <div >己(5)</div>      <div >辛(7)</div>      <div >壬(8)</div>      <div >丁(1)</div>      <div >庚(6)</div>  </div>    <div class="grid-box">      <div >乙(4)</div>      <div >壬(9)</div>      <div >丁(2)</div>      <div >丙(3)</div>      <div class="earth">戊(5)</div>      <div >庚(7)</div>      <div >辛(8)</div>      <div >癸(1)</div>      <div >己(6)</div>  </div>    <div class="grid-box">      <div >丙(4)</div>      <div >辛(9)</div>      <div >癸(2)</div>      <div >丁(3)</div>      <div >乙(5)</div>      <div >己(7)</div>      <div >庚(8)</div>      <div >壬(1)</div>      <div class="earth">戊(6)</div>  </div>      <div class="grid-box">      <div >丁(4)</div>      <div >庚(9)</div>      <div >壬(2)</div>      <div >癸(3)</div>      <div >丙(5)</div>      <div class="earth">戊(7)</div>      <div >己(8)</div>      <div >辛(1)</div>      <div >乙(6)</div>  </div>    <div class="grid-box">      <div >癸(4)</div>      <div >己(9)</div>      <div >辛(2)</div>      <div >壬(3)</div>      <div >丁(5)</div>      <div >乙(7)</div>      <div class="earth">戊(8)</div>      <div >庚(1)</div>      <div >丙(6)</div>  </div>    <div class="grid-box">      <div >壬(4)</div>      <div class="earth">戊(9)</div>      <div >庚(2)</div>      <div >辛(3)</div>      <div >癸(5)</div>      <div >乙(7)</div>      <div >己(8)</div>      <div >丙(1)</div>      <div >丁(6)</div>  </div></div><br/><h3 id="阴遁"><a href="#阴遁" class="headerlink" title="阴遁"></a>阴遁</h3><p>阴遁九局，下面是 3 局，大家可以自行往下推演。</p><div class="grid-parent"> <div class="grid-box">    <div >丁(4)</div>    <div >己(9)</div>    <div >乙(2)</div>    <div >丙(3)</div>    <div >癸(5)</div>    <div >辛(7)</div>    <div >庚(8)</div>    <div class="earth">戊(1)</div>    <div >壬(6)</div></div><div class="grid-box">    <div >丙(4)</div>    <div >庚(9)</div>    <div class="earth">戊(2)</div>    <div >乙(3)</div>    <div >丁(5)</div>    <div >壬(7)</div>    <div >辛(8)</div>    <div >己(1)</div>    <div >癸(6)</div></div><div class="grid-box">    <div >乙(4)</div>    <div >辛(9)</div>    <div >己(2)</div>    <div class="earth">戊(3)</div>    <div >丙(5)</div>    <div >癸(7)</div>    <div >壬(8)</div>    <div >庚(1)</div>    <div >丁(6)</div></div></div><br/><p>戊、己、庚、辛、壬、癸、丁、丙、乙 和八卦顺序倒着来，即为阴遁。</p><p>这就是奇门开盘的第一步，我们需要知道这是几局。</p><h2 id="起局"><a href="#起局" class="headerlink" title="起局"></a>起局</h2><p>我们已经明白了规则，那么接下来就是学习，我们应该如何起，是阳遁还是阴遁。</p><h3 id="前置需要了解的"><a href="#前置需要了解的" class="headerlink" title="前置需要了解的"></a>前置需要了解的</h3><p>月：<font color="rgb(0,133,66)">寅月 卯月 辰月</font> <font color="rgb(175,17,0)">巳月 午月 未月</font> <font color="rgb(218,218,218)">申月 酉月 戌月</font> <font color="rgb(73,130,180)">亥月 子月 丑月</font><br>节：<font color="rgb(0,133,66)">立春 惊蛰 清明</font> <font color="rgb(175,17,0)">立夏 芒种 小暑</font> <font color="rgb(218,218,218)">立秋 白露 寒露</font> <font color="rgb(73,130,180)">立冬 大雪 小寒</font><br>气：<font color="rgb(0,133,66)">雨水 春分 谷雨</font> <font color="rgb(175,17,0)">小满 夏至 大暑</font> <font color="rgb(218,218,218)">处暑 秋分 霜降</font> <font color="rgb(73,130,180)">小雪 东至 大寒</font></p><ul><li>一个节气共有十五天。</li><li>一天有 24 小时，十二个时辰，十二组干支</li><li>因此 5 天为六十甲子，一个六十甲子为一元。</li><li>因此一个节气有三元，前五天为上元，中间为中元，后五天为下元。</li></ul><h3 id="如何起局"><a href="#如何起局" class="headerlink" title="如何起局"></a>如何起局</h3><p>下面这张图片，只需要知道算什么时辰，就能快速的看出，应该起什么局。</p><div class="grid-box-1">    <div class="yin"> <p>立夏上4中1下7</p> <p>小满上5中2下8</p><p>芒种上6中3下9</p> </div>    <div > <p>夏至上9中3下6</p> <p>小暑上8中2下5</p> <p>大暑上7中1下4</p> </div>    <div ><p>立秋上2中5下8</p> <p>处暑上1中4下7</p> <p>白露上9中3下6</p></div>    <div class="yin"><p>春分上3中9下6</p> <p>清明上4中1下7</p> <p>谷雨上5中2下8</p></div>    <div ><p class="yin">绿色阳遁</p> <p>白色阴遁</p></div>    <div ><p>秋分上7中1下4</p> <p>寒露上6中9下3</p> <p>霜降上5中8下2</p></div>    <div class="yin"><p>立春上8中5下2</p> <p>雨水上9中6下3</p> <p>惊蛰上1中7下4</p></div>    <div class="yin"><p>东至上1中7下4</p> <p>小寒上2中8下5</p> <p>大寒上3中9下6</p></div>    <div ><p>立冬上6中9下3</p> <p>小雪上5中8下2</p> <p>大雪上4中7下1</p></div></div></br><p>举例，当前 1 月 12 号，在小寒（1 月 6 号）的中元，起阴遁八局。</p><h3 id="符头-旬首"><a href="#符头-旬首" class="headerlink" title="符头 旬首"></a>符头 旬首</h3><p>这里也挺重要的，这里主要是排盘需要倒推符头，和旬首，需要知道是怎么回事。</p><p>上元：甲<font color="rgb(0,133,66)">子</font> 乙丑 丙寅 丁卯 戊辰<br>中元：已<font color="rgb(73,130,180)">巳</font> 庚午 辛未 壬申 癸酉<br>下元：甲<font color="rgb(218,162,3)">戌</font> 乙亥 丙子 丁丑 戊寅</p><p>上元：已<font color="rgb(0,133,66)">卵</font> 庚辰 辛巳 壬午 癸未<br>中元：甲<font color="rgb(73,130,180)">申</font> 乙酉 丙戌 丁亥 戊子<br>下元：已<font color="rgb(218,162,3)">丑</font> 庚寅 辛卯 壬辰 癸巳</p><p>上元：甲<font color="rgb(0,133,66)">午</font> 乙未 丙申 丁酉 戊戌<br>中元：已<font color="rgb(73,130,180)">亥</font> 庚子 辛丑 壬寅 癸卯<br>下元：甲<font color="rgb(218,162,3)">辰</font> 乙巳 丙午 丁未 戊申</p><p>上元：已<font color="rgb(0,133,66)">酉</font> 庚戌 辛亥 壬子 癸丑<br>中元：甲<font color="rgb(73,130,180)">寅</font> 乙卯 丙辰 丁巳 戊午<br>下元：已<font color="rgb(218,162,3)">未</font> 庚申 辛酉 壬戌 癸亥</p><p>五天为一元，一个节气有三元。<br>每一元的第一天的天干，不是甲就是己，古人把这个元头，称为符头。即符头只有二个，不是甲，就是己。</p><div class="hljs code-wrapper"><pre><code class="hljs">日干找符头，时干找旬首。</code></pre></div><blockquote><p>旬首为上一篇文章 六十甲子那边，往前倒推，甲开头即为旬首，比如：戊戌的旬首则为甲午。这里只需要知道，下面排盘会使用到。</p></blockquote><ul><li>上元第一天的地支总是子午卯酉中的一个</li><li>中元第一天的地支总是寅申巳亥中的一个</li><li>下元第一天的地支总是辰戌丑未中的一个</li></ul><p>一个季节三个月<br>古人把寅、申、巳、亥称为四孟，即春秋夏冬每季的第一个月。<br>把子、午、卯、酉称为四仲，即春夏春秋冬个季节的中间一个月。<br>把辰、戌、丑、未称为四季，即春秋经夏冬季最末一月。</p><p>从五行寄生十二宫来讲，<br>子、午、卯、酉均为帝旺之月，<br>寅、申、已、亥均为长生之月，<br>辰、戌、丑、未均为四库之月。</p><p>按照规律去找是比较麻烦的，偷懒的做法就是看图，或者代码写。</p><h3 id="飞布-和-转布"><a href="#飞布-和-转布" class="headerlink" title="飞布 和 转布"></a>飞布 和 转布</h3><p>飞和转是两个顺序概念，属于排盘方式，这是前置知识，按照后天八卦的顺序，如下面图一，是为逆飞（阴遁）。<br>第二个图，就是转，顺时针旋转，是正转。</p><div class="grid-parent"> <div class="grid-box">    <div >丁(4)</div>    <div >己(9)</div>    <div >乙(2)</div>    <div >丙(3)</div>    <div >癸(5)</div>    <div >辛(7)</div>    <div >庚(8)</div>    <div class="earth">戊(1)</div>    <div >壬(6)</div></div><div class="grid-box">    <div >四</div>    <div >五</div>    <div >六</div>    <div >三</div>    <div > </div>    <div >七</div>    <div >二</div>    <div >一</div>    <div >八</div></div></div><p>下面就是重点内容了。</p><h2 id="排盘"><a href="#排盘" class="headerlink" title="排盘"></a>排盘</h2><p>奇门排盘为旬仪加时干。需要根据当前的时间，得出当前的年干，月干，日干，时干。<br>比如：<br>我现在的时间公历：2024 年 1 月 14 日 19 点 30 分<br>为：癸卯年 乙丑月 丁丑日 庚戌时</p><h3 id="推理时干（时柱）"><a href="#推理时干（时柱）" class="headerlink" title="推理时干（时柱）"></a>推理时干（时柱）</h3><p>最简单的是直接 google，或者查表，但是流传最广的是一首诗。</p><div class="hljs code-wrapper"><pre><code class="hljs">甲己还生甲，乙庚丙作初，丙辛寻戊起，丁壬庚子居，戊癸何方发，壬子是真途。</code></pre></div><p>这首诗的意思是：甲日或己日，时辰的天干从甲起子时，即：甲子、乙丑、丙寅、丁卯、戊辰、己巳、庚午、辛未、壬伸、癸酉 ······顺推下去<br>乙日或庚日，时柱的天干从丙起子时，即：丙子、丁丑、戊寅、己卯、······<br>丙日或辛日，时柱的天干从戊起子时，即：戊子、己丑、庚寅、辛卯、······<br>丁日或壬日，时柱的天干从庚起子时，即：庚子、辛丑、壬寅、癸卯、甲辰、乙巳、丙午、丁未、戊伸、己酉、庚戌······<br>戊日或癸日，时柱的天干从壬起子时，即：壬子、癸丑</p><p>所以只需记住这首诗，就能知道，当前时柱是什么时候。</p><h3 id="九星-八门-八神"><a href="#九星-八门-八神" class="headerlink" title="九星 八门 八神"></a>九星 八门 八神</h3><p>这个是很重要的盘排知识，需要背诵。主要运用的时候是排盘的时候根据时间，需要知道，当前是什么星，什么门。<br>并且五宫寄二宫，阳顺阴逆。这句有个印象就好。</p><div class="grid-box-1 earth">    <div> <p>天辅</p> <p>杜门</p> </div>    <div> <p>天英</p> <p>景门</p>  </div>    <div><p>天芮(禽)</p> <p>死门</p> </div>    <div><p>天冲</p> <p>伤门</p></div>    <div><p>天禽</p></div>    <div><p>天柱</p> <p>惊门</p></div>    <div><p>天壬</p> <p>生门</p> </div>    <div><p>天蓬</p> <p>休门</p> </div>    <div><p>天心</p> <p>开门</p></div></div></br><div class="earth">八神：值符 腾蛇 太阴 六合 白虎 玄武 九地 九天</div><p>我们已经了解了大量的基础知识，接下来还是用当前的时间进行排盘。</p><div class="hljs code-wrapper"><pre><code class="hljs">公历：2024年1月14日19点30分为：癸卯(年干) 乙丑(月干) 丁丑(日干) 庚戌(时干)</code></pre></div><ol><li>第一步，确定阳遁或者阴遁几局。</li></ol><p>根据当前时间和日历，可以查出应该起什么局，比如当前就是小寒的下元，起局阳遁 5 局。</p><ol start="2"><li>确定符头和旬首</li></ol><p>日干找符头，时干找旬首。<br>就比如：当前的时干为<code>庚戌</code>,根据之前所学，它的旬首则为<code>甲辰壬</code>。（甲辰藏于壬天干）<br>而符头，也是往前推，当前是<code>丁丑</code>，根据符头是一元的头一天，并且不是甲，就是己，往前倒推符头着为<code>甲戌</code>。</p><ol start="3"><li>确定值符和值使，并且需要把旬首与值符星加于时干之上</li></ol><p>时干的旬首所在的地盘宫位，<span class="earth">本宫位的星为值符，本宫位的门为值使。</span><br>比如：当前为<code>甲辰壬</code>，那么需要把<code>壬</code>加于<code>庚</code>之上，并且当前的值符星位天英，也需要移动到<code>庚</code>所属地宫。如下图绿色。</p><ol start="4"><li>九星和天盘干都顺时针转布，八神转布，阳遁顺时间转，阴遁逆时针转（阳顺阴逆）</li></ol><p>比如下图：九星顺时针为：天英，天芮(禽)，天柱，天心，天蓬，天任，天冲，天辅。<br>天盘干也是：壬，丁，庚，己，癸，辛，丙，乙。</p><ol start="5"><li>确定值使门位置<div class="earth">值使门每个时辰变动一次，按照阳顺阴逆的飞布九宫</div>比如：示例当前值使门为景门，当前旬首为甲辰壬，当前时干为庚戌，那么从壬(位置9)顺时针从甲飞宫数到庚(位置6)。那么飞宫六的位置则填上景门，如下图所示。找到景门之后，也是按照阳顺阴逆的转布，排列八门：景，死，惊，开，休，生，伤，杜。</li></ol><blockquote><p>还有一种情况，如果景门落在五宫，则寄到二宫。</p></blockquote><ol start="6"><li>空亡和马星，它们都是需要时干去找</li></ol><p>空亡：示例为甲辰旬，寅卯空亡，那么按飞宫算，三宫和八宫标记为空。</p><p>马星：寅午戌马在申 亥卯未马在巳 巳酉丑马在亥 申子辰马在寅<br>示例当前时干为 庚戌，因此马星为申。</p><!-- ![转盘](./zhuan.jpeg) --><div class="img"><img src="./zhuan.jpeg"  /></div></br><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>最近收集了2.8G的奇门遁甲，丢给大模型微调，如果可行，岂不是变相提纯道士门槛？<br>因为模型必然会出现局限性，能点出问题的才是易学大佬。</p><style>.img {  display: flex;  justify-content: center; } .img > a {  width:50%;  height:70%; }.grid-box-1 {  flex: 1 0 33.33%;  grid-template-columns: min-content min-content min-content;   margin:10px 0;  display: grid;  padding: 5px;  align-items: center;}.grid-box-1 div {  border: 1px solid rgba(0, 0, 0, 0.8);  width:150px;  height:150px;  display:flex;  justify-content: center;  flex-direction: column;  align-items: center;}.yin{  color:rgb(0,133,66)}.grid-parent {  display:flex;  flex-wrap: wrap;}.grid-box {  flex: 1 0 33.33%;  margin:10px 0;  width:240px;  height:240px;  display: grid;   grid-template-columns: min-content min-content min-content;   padding: 5px;  align-items: center;}.grid-box div {  width:80px;  height:80px;  border: 1px solid rgba(0, 0, 0, 0.8);  display:flex;  justify-content: center;  align-items: center;}.earth {  color:rgb(218,162,3)}</style>]]></content>
    
    
    
    <tags>
      
      <tag>奇门遁甲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奇门遁甲-术数基础</title>
    <link href="/2023/12/31/%E5%A5%87%E9%97%A8%E9%81%81%E7%94%B2-%E6%9C%AF%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/12/31/%E5%A5%87%E9%97%A8%E9%81%81%E7%94%B2-%E6%9C%AF%E6%95%B0%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>奇门遁甲个人认为是一门集自然，天文，人文，记法的推测密码学，本章节为基础所记内容。</p><h2 id="五行"><a href="#五行" class="headerlink" title="五行"></a>五行</h2><p>五行为<font color="rgb(218,218,218)">金</font>，<font color="rgb(0,133,66)">木</font>，<font color="rgb(73,130,180)">水</font>，<font color="rgb(175,17,0)">火</font>，<font color="rgb(218,162,3)">土</font>。指物质的五种性质，而不是单单的字面意思。</p><p>金：杀伐，木：曲直，火：升腾，土：承载</p><p>举例：我们喝的水，当承载船的时候，性质属土，当加压变成水刀的时候，性质属金。</p><h3 id="相生"><a href="#相生" class="headerlink" title="相生"></a>相生</h3><p><font color="rgb(0,133,66)">木</font>生<font color="rgb(175,17,0)">火</font>: 木头点燃生火</p><p><font color="rgb(175,17,0)">火</font>生<font color="rgb(218,162,3)">土</font>: 火熄灭化为灰烬变为土状态</p><p><font color="rgb(218,162,3)">土</font>生<font color="rgb(218,218,218)">金</font>: 金产于山脉</p><p><font color="rgb(218,218,218)">金</font>生<font color="rgb(73,130,180)">水</font>: 金融化后变为液体</p><p><font color="rgb(73,130,180)">水</font>生<font color="rgb(0,133,66)">木</font>: 水滋养树木生长</p><h3 id="相克"><a href="#相克" class="headerlink" title="相克"></a>相克</h3><p><font color="rgb(0,133,66)">木</font>克<font color="rgb(218,162,3)">土</font>: 树木破土而出</p><p><font color="rgb(218,162,3)">土</font>克<font color="rgb(73,130,180)">水</font>: 兵来将挡 水来土掩</p><p><font color="rgb(73,130,180)">水</font>克<font color="rgb(175,17,0)">火</font>: 水能将火熄灭</p><p><font color="rgb(175,17,0)">火</font>克<font color="rgb(218,218,218)">金</font>: 火能融化金子</p><p><font color="rgb(218,218,218)">金</font>克<font color="rgb(0,133,66)">木</font>: 斧子砍断树木</p><p>这里只需要记牢，相生相克的顺序就好了。</p><h2 id="阴阳"><a href="#阴阳" class="headerlink" title="阴阳"></a>阴阳</h2><p>阴阳为一对，单独不能称为阴阳。其为相对概念，不是绝对概念。<br>简单来说就是得有参照物。</p><p>比如：</p><p>阳:高 天 尊 动 快 显 热 奇</p><p>阴:低 地 卑 静 慢 隐 冷 偶</p><div class="hljs code-wrapper"><pre><code class="hljs">阳：-------    阴： --- ---</code></pre></div><h2 id="天干地支"><a href="#天干地支" class="headerlink" title="天干地支"></a>天干地支</h2><h3 id="十天干"><a href="#十天干" class="headerlink" title="十天干"></a>十天干</h3><p>五行分阴阳。</p><p>木：甲乙。火：丙丁。土：戊己。金：庚辛。水：壬癸。</p><p>即：</p><p>五阳干：甲丙戊庚壬<br>五阴干：乙丁己辛癸</p><blockquote><p>十天干：甲（jiǎ）、乙（yǐ）、丙（bǐng）、丁（dīng）、戊（wù）、己（jǐ）、庚（gēng）、辛（xīn）、壬（rén）、癸（guǐ）</p></blockquote><h3 id="十二地支"><a href="#十二地支" class="headerlink" title="十二地支"></a>十二地支</h3><p>地支同样被五行划分为阴阳。</p><p><font color="rgb(73,130,180)">子</font> <font color="rgb(218,162,3)">丑</font> <font color="rgb(0,133,66)">寅</font><font color="rgb(0,133,66)">卯</font> <font color="rgb(218,162,3)">辰</font> <font color="rgb(175,17,0)">巳</font><font color="rgb(175,17,0)">午</font> <font color="rgb(218,162,3)">未</font> <font color="rgb(218,218,218)">申</font><font color="rgb(218,218,218)">酉</font> <font color="rgb(218,162,3)">戌</font> <font color="rgb(73,130,180)">亥</font></p><p><font color="rgb(73,130,180)">水</font>：亥子为水 子为阳水 亥为阴水<br><font color="rgb(0,133,66)">木</font>：寅卯为木 寅为阳木 卯为阴木<br><font color="rgb(175,17,0)">火</font>：巳午为火 午为阳火 巳为阴火<br><font color="rgb(218,218,218)">金</font>：申酉为金 申为阳金 戌为阴金<br><font color="rgb(218,162,3)">土</font>：辰戌丑未为土 辰戌为阳土 丑未为阴土</p><p>六阳支： 子寅辰午申戌<br>六阴支： 丑卯巳未酉亥</p><blockquote><p>子(zǐ)、丑（chǒu）、寅（yín）、卯（mǎo）、辰（chén）、巳（sì）、午（wǔ）、未（wèi）、申（shēn）、酉（yǒu）、戌（xū）、亥（hài）。</p></blockquote><h4 id="四季"><a href="#四季" class="headerlink" title="四季"></a>四季</h4><p>十二地支也对应着四季，春天属木，夏天属火，秋天属金，冬天属水。四季被土分割，起到一个过度的作用。</p><h4 id="时辰"><a href="#时辰" class="headerlink" title="时辰"></a>时辰</h4><p>一个时辰两小时，逢奇数换时辰。</p><p>子时：11 时-1 时<br>丑时：1 时-3 时<br>寅时：3 时-5 时<br>卯时：5 时-7 时<br>辰时：7 时-9 时<br>巳时：9 时-11 时<br>午时：11 时-13 时<br>未时：13 时-15 时<br>伸时：15 时-17 时<br>酉时：17 时-19 时<br>戌时：19 时-21 时<br>亥时：21 时-23 时</p><p>时辰的飞宫顺序。</p><div class="grid-box">    <div class="item wood">辰、巳</div>    <div class="item fire">午</div>    <div class="item earth">未、申</div>    <div class="item wood">卯</div>    <div class="item "> </div>    <div class="item gold">酉</div>    <div class="item earth">丑、寅</div>    <div class="item water">子</div>    <div class="item gold">戌、亥</div></div><h3 id="二十四节气，月令"><a href="#二十四节气，月令" class="headerlink" title="二十四节气，月令"></a>二十四节气，月令</h3><p>二十四节气，其分为十二节令和十二中气，一个节气十五天。</p><p><font color="rgb(0,133,66)">寅月 卯月 辰月</font> <font color="rgb(175,17,0)">巳月 午月 未月</font> <font color="rgb(218,218,218)">申月 酉月 戌月</font> <font color="rgb(73,130,180)">亥月 子月 丑月</font><br><font color="rgb(0,133,66)">立春 惊蛰 清明</font> <font color="rgb(175,17,0)">立夏 芒种 小暑</font> <font color="rgb(218,218,218)">立秋 白露 寒露</font> <font color="rgb(73,130,180)">立冬 大雪 小寒</font><br><font color="rgb(0,133,66)">雨水 春分 谷雨</font> <font color="rgb(175,17,0)">小满 夏至 大暑</font> <font color="rgb(218,218,218)">处暑 秋分 霜降</font> <font color="rgb(73,130,180)">小雪 东至 大寒</font></p><h2 id="六十甲子"><a href="#六十甲子" class="headerlink" title="六十甲子"></a>六十甲子</h2><p>天干十个配十二地支，通称六十甲子。</p><p><font color="rgb(236,174,0)">甲</font>乙<font color="rgb(236,174,0)">丙</font>丁<font color="rgb(236,174,0)">戊</font>已<font color="rgb(236,174,0)">庚</font>辛<font color="rgb(236,174,0)">壬</font>癸<br><font color="rgb(236,174,0)">子</font>丑<font color="rgb(236,174,0)">寅</font>卯<font color="rgb(236,174,0)">辰</font>巳<font color="rgb(236,174,0)">午</font>未<font color="rgb(236,174,0)">申</font>酉<font color="rgb(236,174,0)">戌</font>亥</p><p><font color="rgb(236,174,0)">甲子旬</font>: 甲子 乙丑 丙寅 丁卯 戊辰 己巳 庚午 辛未 壬申 癸酉 (戌亥空亡)<br><font color="rgb(236,174,0)">甲戌旬</font>: 甲戌 乙亥 丙子 丁丑 戊寅 己卯 庚辰 辛巳 壬午 癸未 (申酉空亡)<br><font color="rgb(236,174,0)">甲申旬</font>: 甲申 乙酉 丙戌 丁亥 戊子 己丑 庚寅 辛卯 壬辰 癸巳 (午未空亡)<br><font color="rgb(236,174,0)">甲午旬</font>: 甲午 乙未 丙申 丁酉 戊戌 己亥 庚子 辛丑 壬寅 癸卯 (辰巳空亡)<br><font color="rgb(236,174,0)">甲辰旬</font>: 甲辰 乙巳 丙未 丁未 戊申 己酉 庚戌 辛亥 壬子 癸丑 (寅卯空亡)<br><font color="rgb(236,174,0)">甲寅旬</font>: 甲寅 乙卯 丙辰 丁巳 戊午 己未 庚申 辛酉 壬戌 癸亥 (子丑空亡)</p><p>当配到下一轮甲子的时候，正好六十对。十个为一旬，空亡为轮空的意思。</p><p>六十年为一甲子，六十天为一甲子，六十时辰为一甲子。</p><h2 id="四柱八字"><a href="#四柱八字" class="headerlink" title="四柱八字"></a>四柱八字</h2><p>假设：公历 2023 年 12 月 31 日 4:00-4:59 时</p><p>对应的八字则为： 癸卯年（兔年） 甲子月 癸亥日 甲寅时</p><p>癸(阴) 甲(阳) 癸(阴) 甲(阳) – 天干<br>卯(阴) 子(阳) 亥(阴) 寅(阳) – 地支</p><p>阴对阴，阳对阳，天干对地支。</p><h2 id="八卦"><a href="#八卦" class="headerlink" title="八卦"></a>八卦</h2><p>八卦分先天和后天，一般用后天八卦。</p><h3 id="先天八卦"><a href="#先天八卦" class="headerlink" title="先天八卦"></a>先天八卦</h3><p>乾一兑二 离三震四<br>巽五坎六 艮七坤八</p><div class="grid-box">    <div class="item gold">兑</div>    <div class="item gold">乾</div>    <div class="item wood">巽</div>    <div class="item fire">离</div>    <div class="item "> </div>    <div class="item water">坎</div>    <div class="item wood">震</div>    <div class="item earth">坤</div>    <div class="item earth">艮</div></div><h3 id="后天八卦"><a href="#后天八卦" class="headerlink" title="后天八卦"></a>后天八卦</h3><p>戴九履一 左三右七<br>四二为肩 八六为足</p><div class="grid-box">    <div class="item wood">巽</div>    <div class="item fire">离</div>    <div class="item earth">坤</div>    <div class="item wood">震</div>    <div class="item "> </div>    <div class="item gold">兑</div>    <div class="item earth">艮</div>    <div class="item water">坎</div>    <div class="item gold">乾</div></div><h3 id="相合，相冲"><a href="#相合，相冲" class="headerlink" title="相合，相冲"></a>相合，相冲</h3><p>同性为冲,阴阳相合。</p><h4 id="天干"><a href="#天干" class="headerlink" title="天干"></a>天干</h4><p>子丑相合  子午相冲<br>寅亥相合  卯酉相冲<br>卯戌相合  寅申相冲<br>辰酉相合  巳亥相冲<br>巳申相合  辰戌相冲<br>平未相合  丑未相冲</p><h4 id="地支"><a href="#地支" class="headerlink" title="地支"></a>地支</h4><p>甲己合化士:中正之和<br>乙庚合化金:仁义之合<br>两辛合化水:威制之台<br>丁壬合化木:淫匿之合<br>戊癸合化火:无情之合</p><p>甲庚相冲<br>乙辛相冲<br>丙壬相冲<br>丁癸相冲<br>戊已不参与冲</p><blockquote><p>看到这里，应该也能猜到，这些算命是如何推理的。不过忒难背了，需要科技算命。</p></blockquote><style>.grid-box {    display: grid;     grid-template-columns: auto auto auto;     padding: 10px;}.item {    border: 1px solid rgba(0, 0, 0, 0.8);     padding: 20px;     font-size: 30px;     text-align: center;}.gold {    color:rgb(218,218,218)}.fire {    color: rgb(175,17,0);}.wood {    color: rgb(0,133,66);}.earth {    color="rgb(218,162,3)"}.water {    color: rgb(73,130,180);}</style>]]></content>
    
    
    
    <tags>
      
      <tag>奇门遁甲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023年终总结</title>
    <link href="/2023/12/25/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2023/12/25/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>写于 2023 年的圣诞节，冷飕飕。今年的主题是！ “生活一分钟，快乐 60 秒！”</p><blockquote><p><a href="https://www.bilibili.com/video/BV1vb4y137gh/?spm_id_from=333.999.0.0">2023 发生了什么</a>。</p></blockquote><h2 id="2023-🎄-🧧"><a href="#2023-🎄-🧧" class="headerlink" title="2023 🎄 🧧"></a>2023 🎄 🧧</h2><p>2023 世界大事频发。</p><ol><li>巴以冲突继续激化，以色列进攻加沙地带，哈马斯奋起反抗，巴勒斯坦人民的一生浓缩成了 出生-成为哈马斯-战死。</li><li>小日本排放核废水。</li><li>俄乌冲突第二年。</li><li>重大电信诈骗。</li><li>GPT 诞生，生成式 AI(AIGC)大规模爆发，个人生产力大幅提高。（首页的图片就是 ai 生成），在基础科学停滞的年代，这是令人非常兴奋的！</li></ol><h3 id="代码相关"><a href="#代码相关" class="headerlink" title="代码相关"></a>代码相关</h3><p>感觉今年的代码量少了，但是也精简了，总体的质量有在提升。但是宏观来说没有一些突破。</p><p>今年的业余时间搞代码的时间都少了，做的一些项目也都弃坑当中，从今年的 commit 可以看出，如果放假了基本没有在打代码了，不利于进步。（工作日没提交是难题卡住了）</p><p><img src="/./git.png" alt="commit"></p><p>今年是出成果的一年，gaubee 带领整个团队并推动了整个项目的更新。 <a href="https://github.com/BioforestChain/dweb_browser">dweb_browser</a>，这整个项目的 commit<br>来到了 3000 个的关口。</p><p>陆续发布了 ios 和 Android，接下来桌面端也将迁移到<code>kotlin multiplatform</code>，不过坑确实多，很多库现在还不完善，需要依靠 rust 去实现，或者做一些牺牲。</p><p>新的一年还得继续耕耘，为了区块链基础建设平台努力。</p><h3 id="书籍相关"><a href="#书籍相关" class="headerlink" title="书籍相关"></a>书籍相关</h3><p>读完了 《生死疲劳》，《我的地坛》，《理想国》,《两晋悲歌》只读完了第一本 3 分之一。<br>今年读的书也比较少，生死疲劳还是在公司举行读书会读的，不然回到宿舍都懒得读。</p><blockquote><p>不行了以后约会得约在图书馆，不然一躺玩手机，一天就过去了。</p></blockquote><h3 id="运动相关"><a href="#运动相关" class="headerlink" title="运动相关"></a>运动相关</h3><p>今年参加了人生第一次半程马拉松。嘎嘎，跑了 2 小时 31 分钟，差一点就进预定目标的 20 小时 30 分钟了，人太多了，尿尿还要排半天，我裤带关键时候还解开解半天难受。</p><h3 id="生活相关"><a href="#生活相关" class="headerlink" title="生活相关"></a>生活相关</h3><p>今年养了兔子，去抓了 4 只，只剩两只，小灰和小白。他两正好是一公一母，生了好几胎。嘎嘎。最近担心生太多了，公的放一边母的放一边，导致公的那边非常不安分。天天上演二人转！</p><p><img src="/./tz.jpg" alt="兔子"></p><p>也陆续噶了几只，有一只蛋蛋掉了噶了，一只蛋蛋掉了，这次狠心剪掉，现在还是活蹦乱跳的，小小灰也拉肚子，吃药没作用噶了，新的一年希望小兔子们也平平安安的。</p><h2 id="2024-taget"><a href="#2024-taget" class="headerlink" title="2024 taget"></a>2024 taget</h2><ol><li>希望公司的项目能够闭环，整个基础建设能全部完成，需要做的工作内容还要很多，希望能在2024年接入网络层，变成完全体。</li><li>爬一座名山。</li><li>参加一次半马。</li><li>多读点书。</li><li>输出一些分支项目，期望能有所盈利。（有好的想法，欢迎联系我）</li><li>在代码架构的编写中有所精进，而不是像无头苍蝇。 需要输出自己的见解。</li><li>开始kmp&#x2F;ios，swiftUI&#x2F;compose，ArkUI的编写，或者达到能写的程度。</li><li>天天开心。</li></ol><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>奇怪了，今年咋感觉没干啥就过去了，2333.</p><p>分享一个，用到最好用的ai <a href="https://www.coze.com/space/7314878406460653569/bot/7314879339231723521">coze</a></p><p>公告：</p><div class="hljs code-wrapper"><pre><code class="hljs">敬以《地球OL》所有玩家，2023赛季即将结束，请所有玩家做好迎接2024新赛季的准备。</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>年度总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何编写符合用户直觉的rust代码</title>
    <link href="/2023/07/12/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E7%AC%A6%E5%90%88%E7%94%A8%E6%88%B7%E7%9B%B4%E8%A7%89%E7%9A%84rust%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/07/12/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E7%AC%A6%E5%90%88%E7%94%A8%E6%88%B7%E7%9B%B4%E8%A7%89%E7%9A%84rust%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我们编写一些 rust 代码的时候，应该遵循一些原则，来保证开发者调用的时候，符合他的直觉，用起来不会感到意外。</p><p>以下文章主要讨论实现一些常用的 Trait,来保证用户的代码进行正常工作，以及如何让我们的代码能符合用户正常的预期。</p><p><a href="https://rust-lang.github.io/api-guidelines/checklist.html">rust 官方的 api 指南</a>主要声明的四点原则。</p><ul><li>可预测性</li><li>灵活性</li><li>可预见，显而易见。</li><li>受约束</li></ul><h2 id="积极实现大部分标准的-Trait"><a href="#积极实现大部分标准的-Trait" class="headerlink" title="积极实现大部分标准的 Trait"></a>积极实现大部分标准的 Trait</h2><p>我们在编写接口的时候，我们应该为用户去实现一些常用的标准 Trait，让用户开发的时候不会感到意外。<br>因为你的库对用户来说是外部类型，用户无法为外部类型实现外部的 Trait。<br>比如：</p><ul><li>期望每个类型都是 Clone 的。</li><li>可以发送任意的东西到另外的线程。</li><li>可以使用 {:?} 打印任意类型。</li></ul><p>以下将讨论建议实现的 Trait。</p><h3 id="Debug-Trait"><a href="#Debug-Trait" class="headerlink" title="Debug Trait"></a>Debug Trait</h3><p>几乎所有的类型都应该去实现 Debug Trait,使用<code>#[derive(Debug)]</code>是最佳实践。</p><blockquote><p>注意:派生的 Trait 会为任意范型参数添加相同的约束 (bound)</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-built_in">Debug</span>;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    a: T,<br>    b: T,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pair</span>: Pair&lt;<span class="hljs-type">i32</span>&gt; = Pair &#123; a: <span class="hljs-number">5</span>, b: <span class="hljs-number">10</span> &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;pair: &#123;:?&#125;&quot;</span>, pair);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意，这里的 a 和 b 都是范型 T,因此也要求，a 和 b 都实现 Debug Trait。</p><p>我们也可以利用<code>fmt::Formatter</code> 来提供各种 <code>debug_xxx</code>辅助方法的手动实现。</p><ul><li>debug_struct</li><li>debug_tuple</li><li>debug_list</li><li>debug_set</li><li>debug_map</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    a: T,<br>    b: T,<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T:fmt::<span class="hljs-built_in">Debug</span>&gt; fmt::<span class="hljs-built_in">Debug</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> &#123;<br>        f.<span class="hljs-title function_ invoke__">debug_struct</span>(<span class="hljs-string">&quot;Pair&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">field</span>(<span class="hljs-string">&quot;a&quot;</span>, &amp;<span class="hljs-keyword">self</span>.a)<br>        .<span class="hljs-title function_ invoke__">field</span>(<span class="hljs-string">&quot;b&quot;</span>, &amp;<span class="hljs-keyword">self</span>.b)<br>        .<span class="hljs-title function_ invoke__">finish</span>()<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pair</span>: Pair&lt;<span class="hljs-type">i32</span>&gt; = Pair &#123; a: <span class="hljs-number">5</span>, b: <span class="hljs-number">10</span> &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;pair: &#123;:?&#125;&quot;</span>, pair);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里主要实现了<code>debug_struct</code>,输出效果跟上面是一样的。</p><h3 id="Send-和-Sync"><a href="#Send-和-Sync" class="headerlink" title="Send 和 Sync"></a>Send 和 Sync</h3><p>自己实现 Send 和 Sync 是非常麻烦的，因为需要程序员自己保证内存安全，如果一个类型的所有成员都实现了这些 Trait,那么该类型也会自动实现这些 Trait。</p><h4 id="Send"><a href="#Send" class="headerlink" title="Send"></a>Send</h4><p>如果不是 Send 的类型无法放在 Mutex 中，也不能在包合线程池的应用程序中传递使用。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>(*<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>);<br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Send</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&#123;&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span> () &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">mb</span> = <span class="hljs-title function_ invoke__">MyBox</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">into_raw</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>)));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>);<br>    std::thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,x);<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以上代码会报错：<code>Rc&lt;i32&gt;</code> cannot be sent between threads safely。因为<code>Rc&lt;i32&gt;</code>并没有实现 send Trait，而我们的 MyBox 实现了 send Trait，<br>因此我们只要把 x 替换为 mb，代码就不会报错了。</p><h4 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h4><p>如果不是 Sync 的类型无法通过 Arc 共享，也无法被放置在静态变量中。<br>比如下面这段代码，x 没有实现 Sync Trait 在线程中共享也是不允许的。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;sync::Arc, cell::RefCell&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>));<br>    std::thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span> = x.<span class="hljs-title function_ invoke__">borrow_mut</span>();<br>        *x += <span class="hljs-number">1</span>;<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果我们没有实现以上 Trait 需要在文档说明。</p><h3 id="Clone-和-Default"><a href="#Clone-和-Default" class="headerlink" title="Clone 和 Default"></a>Clone 和 Default</h3><p>这两个都是比较常用的类型，他们的最佳声明实践是直接通过 derive 去声明。</p><ul><li>#[derive(Clone)]</li><li>#[derive(Default)]</li></ul><h3 id="PartialEq-PartialOrd-Hash-Eq-Ord"><a href="#PartialEq-PartialOrd-Hash-Eq-Ord" class="headerlink" title="PartialEq,PartialOrd,Hash,Eq,Ord"></a>PartialEq,PartialOrd,Hash,Eq,Ord</h3><h4 id="partialEq"><a href="#partialEq" class="headerlink" title="partialEq"></a>partialEq</h4><p>这个 Trait 比较常用，是用来比较类型的两个实例,以下这个例子就可以直观的感受到。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug, PartialEq)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">point1</span> = Point &#123; x: <span class="hljs-number">1</span>, y: <span class="hljs-number">2</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">point2</span> = Point &#123; x: <span class="hljs-number">1</span>, y: <span class="hljs-number">2</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">point3</span> = Point &#123; x: <span class="hljs-number">1</span>, y: <span class="hljs-number">3</span> &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;point1 == point2: &#123;&#125;&quot;</span>, point1 == point2);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;point1 == point3: &#123;&#125;&quot;</span>, point1 == point3);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="PartialOrd-和-Hash"><a href="#PartialOrd-和-Hash" class="headerlink" title="PartialOrd 和 Hash"></a>PartialOrd 和 Hash</h4><p>它们两个相对专门化。<br>如果需要将类型作为 Map 中的 Key。则需要实现 PartialOrd，以便进行 Key 的比较。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::BTreeMap;<br><br><span class="hljs-meta">#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ages</span>: BTreeMap&lt;Person, &amp;<span class="hljs-type">str</span>&gt; = BTreeMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">person1</span> = Person &#123;<br>        name: <span class="hljs-string">&quot;A&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>(),<br>        age: <span class="hljs-number">25</span>,<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">person2</span> = Person &#123;<br>        name: <span class="hljs-string">&quot;B&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>(),<br>        age: <span class="hljs-number">26</span>,<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">person3</span> = Person &#123;<br>        name: <span class="hljs-string">&quot;C&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>(),<br>        age: <span class="hljs-number">27</span>,<br>    &#125;;<br>    ages.<span class="hljs-title function_ invoke__">insert</span>(person1.<span class="hljs-title function_ invoke__">clone</span>(), <span class="hljs-string">&quot;A &#x27;s age&quot;</span>);<br>    ages.<span class="hljs-title function_ invoke__">insert</span>(person2.<span class="hljs-title function_ invoke__">clone</span>(), <span class="hljs-string">&quot;B &#x27;s age&quot;</span>);<br>    ages.<span class="hljs-title function_ invoke__">insert</span>(person3.<span class="hljs-title function_ invoke__">clone</span>(), <span class="hljs-string">&quot;C &#x27;s age&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (person, description) <span class="hljs-keyword">in</span> &amp;ages &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125; - &#123;:?&#125;&quot;</span>, person.name, person.age, description);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>而如果要使用 std::collection 的集合类型进行去重的类型，则需要实现 Hash 以便进行哈希计算。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;<br>    collections::HashSet,<br>    hash::&#123;Hash, Hasher&#125;,<br>&#125;;<br><br><span class="hljs-meta">#[derive(Debug, PartialEq, Eq, Clone)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">u32</span>,<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Hash</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hash</span>&lt;H: Hasher&gt;(&amp;<span class="hljs-keyword">self</span>, state: &amp;<span class="hljs-keyword">mut</span> H) &#123;<br>        <span class="hljs-keyword">self</span>.name.<span class="hljs-title function_ invoke__">hash</span>(state);<br>        <span class="hljs-keyword">self</span>.age.<span class="hljs-title function_ invoke__">hash</span>(state);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">persons</span>: HashSet&lt;Person&gt; = HashSet::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">person1</span> = Person &#123;<br>        name: <span class="hljs-string">&quot;A&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>(),<br>        age: <span class="hljs-number">25</span>,<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">person2</span> = Person &#123;<br>        name: <span class="hljs-string">&quot;B&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>(),<br>        age: <span class="hljs-number">26</span>,<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">person3</span> = Person &#123;<br>        name: <span class="hljs-string">&quot;C&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>(),<br>        age: <span class="hljs-number">27</span>,<br>    &#125;;<br>    persons.<span class="hljs-title function_ invoke__">insert</span>(person1.<span class="hljs-title function_ invoke__">clone</span>());<br>    persons.<span class="hljs-title function_ invoke__">insert</span>(person2.<span class="hljs-title function_ invoke__">clone</span>());<br>    persons.<span class="hljs-title function_ invoke__">insert</span>(person3.<span class="hljs-title function_ invoke__">clone</span>());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Persons &#123;:?&#125;&quot;</span>, persons);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们的 Person 类型就是实现了 Hash Trait。</p><h4 id="Eq-和-Ord"><a href="#Eq-和-Ord" class="headerlink" title="Eq 和 Ord"></a>Eq 和 Ord</h4><p>Eq 和 Ord 有额外的语意要求，相当于是 PartialEq 和 PartialOrd 的扩展。</p><p>Eq 一些额外的要求：</p><ul><li>反身性 (Reflexivity) : 对于任何对象 X，X &#x3D; X 必须为真。</li><li>对称性 (Symmetry) : 对于任何对 X 和 Y，如 X &#x3D; Y 为真，则 Y &#x3D;&#x3D; X 也必须为真。</li><li>传递性 (Transitivity) : 对于对象 X、Y 和 Z 如 X &#x3D;&#x3D; Y 为，并且 Y &#x3D;&#x3D; Z 为真，则 X &#x3D;&#x3D; Z 也必真。</li></ul><p>Ord 一些额外的要求：</p><ul><li>自反性 (Reflexivity) : 对于任何对象 X，X &gt;&#x3D; X 和 X &lt;&#x3D; X 必须为真。</li><li>反对称性 (Antisymmetry) : 对于任何对象 X 和 Y，如 X &lt;&#x3D; Y 和 Y &gt;&#x3D; X 都为真，则 Y &#x3D; X 必须为真。</li><li>传递性 (Transitivity) : 对于任何对象 X、Y 和 Z,如果 X &lt;&#x3D; Y 和 Y &lt;&#x3D; Z 都为真则 X &lt;&#x3D; Z 必须为真。</li></ul><h3 id="serde-下的-Serialize-和-Deserialize"><a href="#serde-下的-Serialize-和-Deserialize" class="headerlink" title="serde 下的 Serialize 和 Deserialize"></a>serde 下的 Serialize 和 Deserialize</h3><p>他妈负责一些序列化和反序列化的。而 serde derive (crate) 提供了机制，可以覆盖单个字段或枚举变体的序列化，<br>由于 serde 是第三方库，用户可能不希望强制添加对它的依赖。<br>大多数库选择提供一个 serde 功能(feature) ，只有当用户选择启用该功能时才添加对 serde 的支持。</p><p>比如，我们的库的 cargo.toml 可以这样写：</p><figure class="highlight toml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">serde</span> = &#123; version = <span class="hljs-string">&quot;1.0&quot;</span>, optional = <span class="hljs-literal">true</span> &#125;<br><br><span class="hljs-section">[features]</span><br><span class="hljs-attr">serde</span> = [<span class="hljs-string">&quot;serde&quot;</span>]<br></code></pre></div></td></tr></table></figure><p>这样让我们的<code>serde</code>是可选的，然后在 features 里面取一个名，也叫<code>serde</code>，这样用户在使用的时候就可以选择的去开启。</p><p>别人用的时候就可以这样子引用(我们的库叫 mylib)：</p><figure class="highlight toml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">mylib</span> = &#123; version = <span class="hljs-string">&quot;0.1&quot;</span> features = [<span class="hljs-string">&quot;serde&quot;</span>]&#125;<br></code></pre></div></td></tr></table></figure><p>用户在使用的时候，就可以自由选择，看是否开启<code>serde</code>。</p><h3 id="不建议实现-Copy"><a href="#不建议实现-Copy" class="headerlink" title="不建议实现 Copy"></a>不建议实现 Copy</h3><p>我们通常不期望类型是 Copy 的,如果想要两个副本，通常希望调用 clone，因为 Copy 是隐性的，<br>用户在使用的时候，可能忘记他使用的类型已经被复制了。<br>并且 Copy 改变了移动给定类型值的语义，可能让开发者感到意外。</p><p>Copy 类型受到很多限制，一个最初简单的类型很容易变得不再满足 Copy 的要求。<br>例如持有了 String 或者其他非 Copy 的类型就会导致不得不移除 Copy，进而引发大的修改。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug, Copy, Clone)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">point1</span> = Point &#123; x: <span class="hljs-number">10</span>, y: <span class="hljs-number">20</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">point2</span> = point1; <span class="hljs-comment">// 这里发生的是复制，而不是移动。</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;point1: &#123;:?&#125;&quot;</span>, point1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;point2: &#123;:?&#125;&quot;</span>, point2);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="实现更舒适的-Trait"><a href="#实现更舒适的-Trait" class="headerlink" title="实现更舒适的 Trait"></a>实现更舒适的 Trait</h2><p>rust 不会自动为实现 Trait 的类型的引用，提供对应的实现。<br>比如：<br>Bar 实现了 Trait ,但是不能将 &amp;Bar 传递给 <code>fn foo&lt;T: Trait&gt;(t:T)</code>。<br>因为 Trait 可能包含接受 &amp;mut self 或 self 的方法，而这些方法无法在&amp;Bar 上调用。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>&lt;T: MyTrait&gt;(t: T) &#123;&#125;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">MyTrait</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bar</span>;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">MyTrait</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Bar</span> &#123;&#125;<br><br><span class="hljs-comment">//你可以这样使用</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">bar</span> = Bar;<br><span class="hljs-title function_ invoke__">foo</span>(bar);<br><span class="hljs-comment">//但无法这样使用</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">bar</span> = Bar!<br><span class="hljs-keyword">let</span> <span class="hljs-variable">bar_ref</span> = &amp;bar;<br><span class="hljs-title function_ invoke__">foo</span>(bar_ref);<br></code></pre></div></td></tr></table></figure><p>这对于看到 Trait 只有 &amp;self 方法的用户来说，非常难受。<br>因此我们在定义新的 Trait 的时候，通常需要提供下列相应的全局实现</p><ul><li>&amp;T where T: Trait</li><li>&amp;mut T where T: Trait</li><li>Box<T> where T: Trait</li></ul><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">MyTrait</span> <span class="hljs-keyword">for</span> &amp;T<br><span class="hljs-keyword">where</span><br>  T: MyTrait<br>&#123;&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">MyTrait</span> <span class="hljs-keyword">for</span> &amp;<span class="hljs-keyword">mut</span> T<br><span class="hljs-keyword">where</span><br>  T: MyTrait<br>&#123;&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">MyTrait</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Box</span>&lt;T&gt;<br><span class="hljs-keyword">where</span><br>  T: MyTrait<br>&#123;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>对于任何可迭代的类型，考虑为 &amp;MyType 和 &amp;mut MyType 实现 IntoIterator<br>这样在循环中可直接使用借用实例，符合用户预期。</p><h3 id="包装类型（Wrapper-Types）"><a href="#包装类型（Wrapper-Types）" class="headerlink" title="包装类型（Wrapper Types）"></a>包装类型（Wrapper Types）</h3><p>如果我们提供了相对透明的类型 (例 Arc),我们可以实现 Deref 和 AsRef 来对类型进行一定转换。</p><ul><li>实现 Deref 允许你的包装类型在使用点运算符时，自动解引用为内部类型，从而可以直接调用内部类型的方法。</li><li>如果访问内部类型不需要任何复杂或潜在的低效逻辑，应考虑实现 AsRef，这样用户可以轻松地将 &amp;WrapperType 作为 &amp;InnerType 使用。</li><li>对于大多数包装类型，还应该在可能的情况下实现 From<InnerType>和 Into<InnerType>，以便用户可轻松地添加或移除包装。</li></ul><p>例如：</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Deref;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wrapper</span>(<span class="hljs-type">String</span>);<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Deref</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Wrapper</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = <span class="hljs-type">String</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Target &#123;<br>        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">AsRef</span>&lt;<span class="hljs-type">str</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Wrapper</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">as_ref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">String</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Wrapper</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-title function_ invoke__">Wrapper</span>(value)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;Wrapper&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(wrapper: Wrapper) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        wrapper.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">wrapper</span> = Wrapper::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;water&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());<br><br>    <span class="hljs-comment">// 使用. 运算符调用内部字符串类型的方法</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Length: &#123;&#125;&quot;</span>, wrapper.<span class="hljs-title function_ invoke__">len</span>());<br><br>    <span class="hljs-comment">// 使用 as_ref 方法 转换为 &amp;str 类型</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">inner_ref</span>: &amp;<span class="hljs-type">str</span> = wrapper.<span class="hljs-title function_ invoke__">as_ref</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Inner: &#123;&#125;&quot;</span>, inner_ref);<br><br>    <span class="hljs-comment">// 将 Wrapper 转换为内部类型 String</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">inner_string</span>: <span class="hljs-type">String</span> = wrapper.<span class="hljs-title function_ invoke__">into</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Inner String: &#123;&#125;&quot;</span>, inner_string);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Deref 和 AsRef 适用于广泛的实现类型可以充当的情况。</p><h3 id="Borrow-Trait"><a href="#Borrow-Trait" class="headerlink" title="Borrow Trait"></a>Borrow Trait</h3><p>Borrow 与 Deref 和 AsRef 有些类似，它针对了更狭窄的使用情况进行了定制，</p><ul><li>允许调用者提供同一类型多个本质相同的变体的其中一个（Equivalent）。</li></ul><p>例如：对于一个 HashSet<String>，Borrow 允许调用者提供 &amp;str 或 &amp;String。<br>虽然使用 AsRef 也可以实现类似的效果，但如果没有 Borrow 的额外要求，这种实现是不安全的，<br>因为 Borrow 要求目标类型实现的 Hash、Eq 和 Ord 必须与实现类型完全相同。</p><ul><li>Borrow 还为 Borrow<T>, &amp;T 和 &amp;mut T 提供了通用实现。这使得在 Trait 约束中使用它来接受给定类型的拥有值或引用值非常方便</li></ul><blockquote><p>注意： Borrow 仅适用当你的类型本质上与另一个类型等价时。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::borrow::Borrow;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_length</span>&lt;S&gt;(string: S)<br><span class="hljs-keyword">where</span><br>    S: Borrow&lt;<span class="hljs-type">str</span>&gt;,<br>&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Length: &#123;&#125;&quot;</span>, string.<span class="hljs-title function_ invoke__">borrow</span>().<span class="hljs-title function_ invoke__">len</span>());<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str1</span>: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span>: <span class="hljs-type">String</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;World&quot;</span>);<br><br>    <span class="hljs-title function_ invoke__">print_length</span>(str1);<br>    <span class="hljs-title function_ invoke__">print_length</span>(string1);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>参数类型 S 是 Borrow<str>的，本质上是字符串的两个变体，因此这样传递是没问题的。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这些内容很好的理清了开发一个库的时候，我们应该去实现哪些 Trait，这会让我们的代码变得更加的符合用户直觉。</p><p>参考见：</p><ul><li><a href="https://www.bilibili.com/video/BV1Pu4y1Z7dT?p=1&vd_source=5a551b309f4cee1aa97066b4d520cef5">杨旭老师教程</a></li><li><a href="https://rust-lang.github.io/api-guidelines/predictability.html">rust 官方的 api 指南</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>减少内耗，提升维度。</title>
    <link href="/2023/04/13/%E5%87%8F%E5%B0%91%E5%86%85%E8%80%97%EF%BC%8C%E6%8F%90%E5%8D%87%E7%BB%B4%E5%BA%A6%E3%80%82/"/>
    <url>/2023/04/13/%E5%87%8F%E5%B0%91%E5%86%85%E8%80%97%EF%BC%8C%E6%8F%90%E5%8D%87%E7%BB%B4%E5%BA%A6%E3%80%82/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇为黄山培训总结，在3天的培训当中向大家学习了很多思想哲学性的东西。<br>学习到大家的处世技巧和精神内涵，吸收到了大家的能量。<br>怕忘了，写篇文章记录一下。以下仅为个人理解和对小伙伴思想的分析，如有疑问请讨论区讨论。</p><p>当一个技术团队，在讨论精神层面的问题，那么这个团队就像掌握了光速航行的技术。</p><p>先来几张好看的风景照哈哈。</p><p><img src="/./huangshan1.jpeg" alt="黄山"></p><p><img src="/./huangshan2.jpeg" alt="云海"></p><p><img src="/./water.JPG" alt="新安江山水画廊"></p><h2 id="放松，放下"><a href="#放松，放下" class="headerlink" title="放松，放下"></a>放松，放下</h2><p>放松和放下的核心讲究的是一个超脱于自身的观物处世行为特征，想庄子一样分为“认知”和“肉身”。<br>当遇到事情，采取第三者或者高维度的思想去看待问题，有道是：“旁观者清”。</p><p>当你在高维俯视低维所有问题的本质将暴露在你的眼中（跟进入三体中的四维气泡折跃点一样），透过现象看本质，问题也再将不是问题了。<br>前提我们遇到事情要学会放松，并且放下一些执念，这将是我们分析和看清事物本质的两个前提。</p><p>当我们学会放松和放下，那么外界就极少能再牵动我们的精神内心，这也是打坐修行的目的，去悟一些东西，实现精神世界的提升。<br>所以遇到事情跳出来，比如：你生孩子和不生孩子，对整个人类文明和整个宇宙没有任何影响。<br>或者一些其他更微小层面的问题，比如：今天你看出了某人一直吹牛，但是你知道他是错的。你今天遇到的问题无法解决，不要让它一直缠绕着你。<br>当我们看待事物从更高维度的时候，你的幸福指数就能获得提升，有一张图能体现放下的特征，但是我现在没有只能文字表述一下，大家自行脑补哈哈。<br><code>以前听说1+1=3，我xxxx,现在听说1+1=3 对的你说得对！.jpg</code></p><p>并且我们在对事情进行谈论的时候，会下意识的使用，<code>我觉得</code> 当这三个字出来的时候，我们就已经深陷其中了。因此跳出三界外，不在五行中，这是一种非常高深的境界。</p><p>不过，介于当今社会的道德观问题，彻底的放下是不科学的，比如一些违法犯罪的事。所以法律的约束是我们放下的尺度。</p><h2 id="web3-元宇宙"><a href="#web3-元宇宙" class="headerlink" title="web3 元宇宙"></a>web3 元宇宙</h2><blockquote><p>注： 以下个人愚见。</p></blockquote><p>简单用两个语句先概括一下吧。</p><ul><li>web3是一个很大的课题。是第三代互联网。</li><li>元宇宙是web3的一种表现形式，主要在虚拟现实技术。</li></ul><p>web1的时代，是一个中心不断的向我们传递消息，就比如早期的新闻网站。<br>web2时代，就是类似于淘宝的出现，用户开始参与内容的生产，抖音是整个web2时代辉煌的标志。<br>web3时代，每个个体都是一个中心，数据属于你个人，个体的权重不断增加这是整个时代的基调，也是整个文明进步的标志。<br>当每个人开始独立思考，开始提升自己的修为，科技的爆发将会随之而来。<br>介于讨论结果web3时代来临，政府将成为一个服务性机构，为所有人服务，为每个个体服务，而不是像现在的资本主义，为某一些人服务，不为所有人服务的政府或者机构将不被拥护，被自然选择淘汰。<br>整个web3的路将会有很大的阻力，精神层面，社会层面，乃至政治层面，可以预见会有某一部人人为了维护利益或者固步自封而成为阻力。<br>这个web3的思想是超前的，受制于当前的社会生产力和文化层面的研究，所以在中国完全摆脱发展中国家的社会基调之前，web3的爆发只能在一些知识分子当中，他们往往有更高的精神需求和自我理解。<br>当然现在来看，web3技术的爆发将会是一个导火索，我们正在不断的努力，触发这个导火索，AI的技术爆发已经来临，web3的技术爆发在什么时候呢？<br>也许在2050年或者等我去世之后也看不到，因为人的生命非常短暂，但是这种想法是悲观的，但是我们的想法必须是激进的，我们将不断的向这个方向去努力。<br>一旦触发这个导火索，将引发整个社会变革。</p><p>我个人的技术角度发言是举了node和deno的变化，deno不在拥有包的概念,非常符合web3的思想，每个文件都是一个独立的个体，个体之间相互协作。</p><h2 id="贴标签，设围栏，拥抱变化"><a href="#贴标签，设围栏，拥抱变化" class="headerlink" title="贴标签，设围栏，拥抱变化"></a>贴标签，设围栏，拥抱变化</h2><p>讲这三个话题之前，先分享一个小伙伴的故事吧。</p><p>现在小伙伴们基本也都快有孩子了，很多家长在孩子小时候，会在客厅弄一个围栏保护孩子，同时也节省自己的时间，<br>经常看到很多人这样做，所以我们下意识默认这个是对的，但是当你给孩子设置一个舒适圈，一个界限，一个围栏，区分了安全和不安全，久而久之孩子的探索欲将被扼杀于婴儿时期。<br>当孩子接触到一些新鲜事物时，会本能退回舒适区，表现出厌恶，不愿意去学习新的东西，不愿意去拥抱变化。</p><p>也许当下许多人，也意识到了，我们处在自己设置的围栏当中，我们现在应该做的是不断的去拆除围栏，不断的扩展自己的深度和广度。<br>比如当前你在前端的栅栏里，那么就应该拆除这种栅栏，不断的去学习进步，提升自我价值，学习新的技术，拥抱新的变化。<br>当你不断的拆除栅栏，看到变化你讲不再恐惧，甚至非常兴奋，期待整个新变化的积极影响。</p><p>而贴标签，先从技术角度讲吧。</p><p>当前区分了前端，后端，全栈，python,js,rust，C++，软件，硬件。希望大家不要有这样的观念，给自己贴上某一个标签。<br>像各个职位，什么后端就做后端的事，前端做前端的事，这样子不断的给自己贴个标签，设置围栏，永远是无法实现超越的。<br>为什么好汉不提当年勇，因为真正的好汉，在死之前，只会越来越勇。当你开始满足于以前的荣誉，说明你已经在走下坡路了。<br>我们回忆过去的某件事情，应该更多的做一些复盘性的工作。<br>又比如语言，当前的业务什么语言合适就用什么语言（当然这需要有技术深度和广度，但是当你开始超越自己的时候基本也差不多了），<br>写底层用C++或者rust，web用ts，ai和数据分析用python。语言只是工具，别让职位的栅栏成为自己的标签。</p><p>而在生活角度，迫于某种原因，我们会习惯给某些人贴上标签，比如某些人犯了一些错误（不是违法行为），我们就会急急忙忙贴上一个标签，比如笨。<br>算了，给分析他人的标签不太好，也阻碍了两个人之间的交流，所以不要随便给他人贴标签就好了。<br>我们还是说说自己吧！骂自己不犯法，比如我非常内向，我就给自己贴了一个标签，当我想跟别人交流的时候，我内心的标签，就是我的阻碍，我会想，我是内向的要不算了。<br>这段说得不好，希望有小伙伴能帮忙总结自己的想法。</p><h2 id="知道和不知道"><a href="#知道和不知道" class="headerlink" title="知道和不知道"></a>知道和不知道</h2><blockquote><p>知之为知之 不知为不知 是知也</p></blockquote><p>关于知道和不知道，以上就是最好的总结，但是要做到却有一定难度。<br>主要的绊脚石是自己的尊严，面子，这方面我有时候也做得不好，需要不断去修正。<br>这个话题论点较少，小伙伴的故事又忘了，基本先这样吧哈哈。</p><h2 id="真人和假人"><a href="#真人和假人" class="headerlink" title="真人和假人"></a>真人和假人</h2><p>我们都需要学会当一个真人，不过我们大部分时间都在当假人，为什么我们跟另一半的矛盾有时候那么大呢？<br>因为我们在和对象相处的过程中，总是绝对真的，并不会特意的去掩盖自己的情绪价值。<br>而情绪和事物是最低维的价值输出，往上是共识，更高维的是默契的共识，然后就是总结出方法论等等</p><p>假人，大部分时间在隐藏自己，我们在工作和生活中，要学习当一个真人。我们所说的真人，不是有情绪就爆发，我们上面说了，<br>情绪是最低级的价值输出，所以我们要在做真人的途中，寻找共识，寻找更高维的共识，这样子在协作当中，1+1就不是等于2了，现在1+1&#x3D;11。</p><blockquote><p>随想： 冯·诺伊曼二进制的基本结构，有没有可能在本世纪完成突破？</p></blockquote><p>当我们学会当一个真人的时候，我们会收获更多的问题，更多的碰撞，而这也是前往更高维的必经之路，达成共识的必经之路。我们要善于把问题抛出来，<br>引起大家的关注，这样子会碰撞出更多的思维火花，创造出更好的成果，但是我们也需要有自己解决问题的能力，不要当个好奇宝宝，什么问题都问。</p><blockquote><p>你的火花点燃他的火花,他的火花点燃了一片火海</p></blockquote><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>这个话题是震撼我的，我以前都是用爱去处理事情和关系，抱着为他人着想的心去谈事情，这样子成功概率不高。<br>我需要不断的去学习这里面的内容，而且这里面的细节非常丰富，写成一本书是没有问题的，不知道有没有前人写过，如果读者知道，可以推荐一下。</p><p>比如你赚了钱要邀请你父母出去玩，我们是不是每次都以居高临下的态度，啊现在有钱了，带你们去享受，带你们出去玩。这种单方面的行为，一般都会被拒绝。<br>因为你只满足了自己回报父母的想法，没有考虑到父母的想法，让你省点钱，不想占用你时间，节俭，等等原因。因此这种直来直去是一种失败的交易。</p><p>成功的交易是一种双方都觉得自己占到了便宜的交易，这种交易非常容易达成，这也是一门很深的学问，举一个小伙伴的例子：<br>他买了所房子，远在外省的父母有较强的封建风水思想。（个人认为真正的风水是人与自然和谐共生），想请风水先生来看看，而小伙伴又不信这些，<br>就对他母亲讲：老家的风水大师在厦门不灵，我认识一个厦门的风水大师，当地的风水要请当地的大师，这样子才比较合适。他妈妈也就答应了。<br>这个交易，即满足了自己不信风水的需求，也满足了母亲对事情掌控的精神满足。</p><p>对父母我们也应该使用这种方式，我们已经在外面闯荡过，你的精神维度可能比父母高出了一个维度，<br>但是如果在交流当中，你还是高高在上，用指导的语气跟父母说话，可能会面临的一系列的问题，<br>因为父母早就习惯了你是个孩子，你突然站在高维度跟父母讨论一些问题，是不太合适的，所以我们要主动的回一个维度，满足父母的指导欲望，<br>因为当你在外面父母还能帮上忙，父母的精神世界将得到非常大的满足。</p><p>比如教育孩子，举个小伙伴教孩子背英语和学习的做法，<br>学校要求要背英语，有些家长就会边玩手机，边听孩子背诵英语，孩子就会下意识觉得，我在读书你凭什么在玩？<br>而家长会觉得，我幸苦一天了回家放松一下怎么了？小伙伴的做法是，陪着孩子一起背，先背一遍给孩子听，孩子就盯着家长犯错，会很高兴的指出家长的错误，然后孩子再背，<br>这样子一来一回，不过一会全部背完了。</p><p>比如要知道孩子每天学了什么？我们不能直接问你今天学习了什么内容啊？我们应该问今天学习了什么内容啊？能不能教给爸爸啊？这样子还在在上课的时候就会认真的听讲，<br>因为他现在也是个小老师，找到了自己的精神价值。</p><p>不仅仅是人跟人，我们也要学会跟自己达成交易，如何让自己做决定不委屈并且达成目标，这也是需要深入思考的。</p><p>所以这是一门很大的学问，还需要不断的学习。</p><h2 id="道和术"><a href="#道和术" class="headerlink" title="道和术"></a>道和术</h2><p>道就是路，术是方法论，两者的结合才能让自己走到更高的维度。</p><p>我们应该都听过木桶效应，一个木桶的盛水量取决于最短的那个，从现在开始我们需要打破认知，让所有的短板向最长的看齐。<br>现在团队中正在出现这种情况，得益于整个团队的web3管理模式，每个人都是一个独立的个体，没有领导区分，谁技术强谁说得算。<br>不断的向最厉害的人看齐，然后不断的共同进步。这是我们整个团队的道。</p><p>因此关于程序员35岁失业，如果不断的超越自己，这个失业是不可能存在的。</p><blockquote><p>但是现在技术领导人前瞻性的预见了一种情况，担心他就是我们的天花板，主要就是体现在技术方案上，我们无法反驳，<br>我们无法反驳的根本原因，我觉得啥两点一个是技术仍然有差距，二是尊敬带头人的决策，我们的代码会向他那边去靠齐。</p></blockquote><p>而关于术，就是怎么做，概括来讲就是站在巨人的肩膀上，然后不断的生长学习，就跟我们的生物链林一样，每个人都是土壤，<br>进而促使整个社区在土壤上不断的生长，然后结果。</p><p>关于这个议题个人理解不是很深，希望有小伙伴补充，或者等我悟到了再说。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>个人对小伙伴的例子记忆不清晰，只记得中心论点，有兴趣欢迎补充。<br>或者有其他想法，欢迎讨论。</p>]]></content>
    
    
    
    <tags>
      
      <tag>修行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>deno实现一个js语法解析器</title>
    <link href="/2023/02/12/deno%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAjs%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    <url>/2023/02/12/deno%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAjs%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>javascript</code>是解释型语言，在v8中，源代码需要经过词法和语法分析，转化为AST, 再进行语义分析，最后转化成字节码执行。</p><p>语法分析成AST可以在这里体验：<a href="https://esprima.org/demo/parse.html">https://esprima.org/demo/parse.html</a>。</p><p>本次deno 实现的源码在这里获取：<a href="https://github.com/HighValyrian/deno-ast.git">deno-ast</a>,开源学习随意复制。</p><h2 id="Parser-解析器"><a href="#Parser-解析器" class="headerlink" title="Parser(解析器)"></a>Parser(解析器)</h2><p>Parser分为Tokenizer(分词器),和parser（解析器）。</p><h3 id="Tokenizer"><a href="#Tokenizer" class="headerlink" title="Tokenizer"></a>Tokenizer</h3><p>分词器的最终目的是帮助我们将代码进行词法分析，分割成一个一个的小token，方便我们的parser去解析成AST.</p><p>我们先来测试一下我们<code>tokenizer</code>的效果。</p><p>把源码clone下来之后，运行：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">deno <span class="hljs-built_in">test</span> --filter <span class="hljs-string">&quot;tokenizerTest&quot;</span><br></code></pre></div></td></tr></table></figure><p><img src="/./tokenizer.png" alt="tokenizer"></p><p>这些就是我们生产的token，有了这些token,我们的parser才能转化为AST。<br><code>tokenizer</code>最核心的就是正则表达式，本质上就是用正则表达式去提取token。具体的正则定义可以查看<a href="https://github.com/HighValyrian/deno-ast/blob/main/src/Tokenizer.ts">Tokenizer.ts</a>文件。</p><h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><p>接下来继续看parser，里面主要的内容就是下面两个</p><ul><li>BNF（巴科斯范式）</li><li>Finite-state machine（有限状态机）</li></ul><h4 id="巴科斯范式"><a href="#巴科斯范式" class="headerlink" title="巴科斯范式"></a>巴科斯范式</h4><p>巴科斯范式我个人的理解是一种使用递归思想来描述计算机语言的定义规范。<br>想进一步学习可以查看<a href="http://sighingnow.github.io/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/bnf.html">bnf</a>等相关内容。<br>不过，个人觉得最值得学习的还是编译器的优化，这比较重要。</p><p>我们来看一个代码的结构声明。代码位于<a href="https://github.com/HighValyrian/deno-ast/blob/main/src/Parser.ts">parser</a></p><figure class="highlight ts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ReturnStatement</span><br><span class="hljs-comment"> *   : &#x27;return&#x27; OptExpression &#x27;;&#x27;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">ReturnStatement</span>() &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_eat</span>(<span class="hljs-string">&#x27;return&#x27;</span>); <span class="hljs-comment">// 吃掉当前的token</span><br>    <span class="hljs-keyword">const</span> argument =<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentToken</span>.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;;&#x27;</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">Expression</span>() : <span class="hljs-literal">null</span>; <span class="hljs-comment">// 这里的token已经是下一个的了</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_eat</span>(<span class="hljs-string">&#x27;;&#x27;</span>);<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ReturnStatement&#x27;</span>,<br>        argument,<br>    &#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面就是对return的一个声明，表示这个<code>ReturnStatement</code>需要以下结构：</p><blockquote><p>: ‘return’ OptExpression ‘;’<br>一个return关键字，加上可选择的表达(Expression在代码下面有进行结构声明)，然后结尾一个分号表示结束。</p></blockquote><p>而一些<code>Statement</code>状态的转移主要是依赖我们的Statement函数：</p><figure class="highlight ts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Statement</span><br><span class="hljs-comment"> *   : ExpressionStatement</span><br><span class="hljs-comment"> *   | BlockStatement</span><br><span class="hljs-comment"> *   | EmptyStatement</span><br><span class="hljs-comment"> *   | VariableStatement</span><br><span class="hljs-comment"> *   | IfStatement</span><br><span class="hljs-comment"> *   | IterationStatement</span><br><span class="hljs-comment"> *   | FunctionDeclaration</span><br><span class="hljs-comment"> *   | ClassDeclaration</span><br><span class="hljs-comment"> *   | ReturnStatement</span><br><span class="hljs-comment"> *   ;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Statement</span>(): <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">unknown</span>&gt; | <span class="hljs-literal">undefined</span> &#123;<br>  <span class="hljs-keyword">switch</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentToken</span>.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;;&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">EmptyStatement</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;if&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">IfStatement</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&#123;&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">BlockStatement</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;let&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">VariableStatement</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;fun&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">FunctionDeclaration</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;class&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">ClassDeclaration</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;return&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">ReturnStatement</span>();<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;while&quot;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;do&quot;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;for&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">IterationStatement</span>();<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">ExpressionStatement</span>();<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>他帮助我们把<code>tokeninzer</code>生成的token转移到各个具体的声明去，构造我们的抽象语法树。</p><h4 id="Finite-state-machine（有限状态机）"><a href="#Finite-state-machine（有限状态机）" class="headerlink" title="Finite-state machine（有限状态机）"></a>Finite-state machine（有限状态机）</h4><p>在我们的parser里，可以理解成一系列状态的转移，每个方法都是一个状态。<br>每个函数的调用可以看作是一个状态的转移。<br>比如<code>parser.ts</code>里状态的转移是：</p><blockquote><p>Program -&gt; StatementList -&gt; Statement …</p></blockquote><p>最终的状态都会在<code>Literal</code>结束。</p><h3 id="输出AST"><a href="#输出AST" class="headerlink" title="输出AST"></a>输出AST</h3><p>我们运行以下测试，就能得到我们要的结果：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">deno <span class="hljs-built_in">test</span> --filter <span class="hljs-string">&quot;parserTest&quot;</span><br></code></pre></div></td></tr></table></figure><p>这样我们就将代码转换为抽象语法树了。</p><figure class="highlight ts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">add</span> &#123;<br>  fun <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>  &#125;      <br><br>  fun <span class="hljs-title function_">calc</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><details><summary>AST</summary><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Program&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;body&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ClassDeclaration&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Point&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;superClass&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;body&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;BlockStatement&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;body&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-punctuation">&#123;</span><br>                        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FunctionDeclaration&quot;</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><br>                            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;constructor&quot;</span><br>                        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;params&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                            <span class="hljs-punctuation">&#123;</span><br>                                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><br>                                <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;x&quot;</span><br>                            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                            <span class="hljs-punctuation">&#123;</span><br>                                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><br>                                <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;y&quot;</span><br>                            <span class="hljs-punctuation">&#125;</span><br>                        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;body&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;BlockStatement&quot;</span><span class="hljs-punctuation">,</span><br>                            <span class="hljs-attr">&quot;body&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                                <span class="hljs-punctuation">&#123;</span><br>                                    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ExpressionStatement&quot;</span><span class="hljs-punctuation">,</span><br>                                    <span class="hljs-attr">&quot;expression&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;AssignmentExpression&quot;</span><span class="hljs-punctuation">,</span><br>                                        <span class="hljs-attr">&quot;operator&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;=&quot;</span><span class="hljs-punctuation">,</span><br>                                        <span class="hljs-attr">&quot;left&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MemberExpression&quot;</span><span class="hljs-punctuation">,</span><br>                                            <span class="hljs-attr">&quot;computed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                                            <span class="hljs-attr">&quot;object&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ThisExpression&quot;</span><br>                                            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                                            <span class="hljs-attr">&quot;property&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><br>                                                <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;x&quot;</span><br>                                            <span class="hljs-punctuation">&#125;</span><br>                                        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                                        <span class="hljs-attr">&quot;right&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><br>                                            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;x&quot;</span><br>                                        <span class="hljs-punctuation">&#125;</span><br>                                    <span class="hljs-punctuation">&#125;</span><br>                                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                                <span class="hljs-punctuation">&#123;</span><br>                                    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ExpressionStatement&quot;</span><span class="hljs-punctuation">,</span><br>                                    <span class="hljs-attr">&quot;expression&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;AssignmentExpression&quot;</span><span class="hljs-punctuation">,</span><br>                                        <span class="hljs-attr">&quot;operator&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;=&quot;</span><span class="hljs-punctuation">,</span><br>                                        <span class="hljs-attr">&quot;left&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MemberExpression&quot;</span><span class="hljs-punctuation">,</span><br>                                            <span class="hljs-attr">&quot;computed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                                            <span class="hljs-attr">&quot;object&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ThisExpression&quot;</span><br>                                            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                                            <span class="hljs-attr">&quot;property&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><br>                                                <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;y&quot;</span><br>                                            <span class="hljs-punctuation">&#125;</span><br>                                        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                                        <span class="hljs-attr">&quot;right&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><br>                                            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;y&quot;</span><br>                                        <span class="hljs-punctuation">&#125;</span><br>                                    <span class="hljs-punctuation">&#125;</span><br>                                <span class="hljs-punctuation">&#125;</span><br>                            <span class="hljs-punctuation">]</span><br>                        <span class="hljs-punctuation">&#125;</span><br>                    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-punctuation">&#123;</span><br>                        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FunctionDeclaration&quot;</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><br>                            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;calc&quot;</span><br>                        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;params&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;body&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;BlockStatement&quot;</span><span class="hljs-punctuation">,</span><br>                            <span class="hljs-attr">&quot;body&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                                <span class="hljs-punctuation">&#123;</span><br>                                    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ReturnStatement&quot;</span><span class="hljs-punctuation">,</span><br>                                    <span class="hljs-attr">&quot;argument&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;BinaryExpression&quot;</span><span class="hljs-punctuation">,</span><br>                                        <span class="hljs-attr">&quot;operator&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;+&quot;</span><span class="hljs-punctuation">,</span><br>                                        <span class="hljs-attr">&quot;left&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MemberExpression&quot;</span><span class="hljs-punctuation">,</span><br>                                            <span class="hljs-attr">&quot;computed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                                            <span class="hljs-attr">&quot;object&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ThisExpression&quot;</span><br>                                            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                                            <span class="hljs-attr">&quot;property&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><br>                                                <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;x&quot;</span><br>                                            <span class="hljs-punctuation">&#125;</span><br>                                        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                                        <span class="hljs-attr">&quot;right&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MemberExpression&quot;</span><span class="hljs-punctuation">,</span><br>                                            <span class="hljs-attr">&quot;computed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                                            <span class="hljs-attr">&quot;object&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ThisExpression&quot;</span><br>                                            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                                            <span class="hljs-attr">&quot;property&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                                                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span><br>                                                <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;y&quot;</span><br>                                            <span class="hljs-punctuation">&#125;</span><br>                                        <span class="hljs-punctuation">&#125;</span><br>                                    <span class="hljs-punctuation">&#125;</span><br>                                <span class="hljs-punctuation">&#125;</span><br>                            <span class="hljs-punctuation">]</span><br>                        <span class="hljs-punctuation">&#125;</span><br>                    <span class="hljs-punctuation">&#125;</span><br>                <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></div></td></tr></table></figure></details><p>我们可以看到，最外层包裹着<code>Program</code>，而class 的类型为<code>ClassDeclaration</code>。<br>而他的body里又包裹着两个<code>FunctionDeclaration</code>,也就是我们的函数声明<code>fun</code>。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>分享一个最近很喜欢的表情包哈哈</p><p><img src="/./expression.png" alt="哈哈"></p><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><ul><li><a href="https://github.com/AttackOnMorty/rdp">rdp</a></li><li><a href="https://esprima.org/demo/parse.html">https://esprima.org</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>deno javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在v8中给js内置函数</title>
    <link href="/2023/01/24/%E5%A6%82%E4%BD%95%E5%9C%A8v8%E4%B8%AD%E7%BB%99js%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    <url>/2023/01/24/%E5%A6%82%E4%BD%95%E5%9C%A8v8%E4%B8%AD%E7%BB%99js%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在v8中，内置的函数可以理解为在VM运行的一些内置的代码块，他们处在相同的作用域下。<br>如果您有ios(android)的<code>javascriptCore(interface/eventjavascript/more)</code>注入经验，或者其他的一些比较干净的<code>js</code>运行时的操作经验，您可以认为它们两者的共性是相同的。<br>那么建议您阅读英文的官方文档，本片文档仅用作个人入门使用。</p><h3 id="v8内置选择"><a href="#v8内置选择" class="headerlink" title="v8内置选择"></a>v8内置选择</h3><p>V8 的内置函数可以使用多种不同的方法来实现（每种方法都有不同的权衡）：</p><ol><li>Platform-dependent assembly language : 可以非常高效，但需要手动移植到所有平台并且难以维护。</li><li>C++：在风格上与运行时函数非常相似，可以使用 V8 强大的运行时功能，但通常不适合性能敏感的领域。</li><li>JavaScript：简洁易读的代码，访问快速内在函数，但频繁使用慢速运行时调用，由于类型污染导致不可预测的性能，以及围绕（复杂且不明显的）JS 语义的微妙问题。</li><li>CodeStubAssembler：提供非常接近汇编语言的高效低级功能，同时保持平台独立性和可读性。</li></ol><blockquote><p>Platform-dependent assembly language 即平台相关的汇编语言，<code>CodeStubAssembler</code>是更好的选择。</p></blockquote><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p><code>C++</code>的内置操作可以让您在<code>js</code>调用<code>C++</code>函数并且让<code>js</code>的对象能在<code>C++</code>上调用，适合C++程序员。</p><h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><ul><li>一个 isolate 是一个有自己堆的 VM 实例（从rusty_v8中能看到对isolate的操作）。</li><li>本地句柄是指向对象的指针。所有 V8 对象都使用句柄​​访问。由于 V8 垃圾收集器的工作方式，它们是必需的。</li><li>句柄范围可以被认为是任意数量句柄的容器。处理完句柄后，无需单独删除每个句柄，只需删除它们的作用域即可。</li><li>上下文是一个执行环境，它允许独立的、不相关的 JavaScript 代码在 V8 的单个实例中运行。您必须明确指定要运行任何 JavaScript 代码的上下文。</li></ul><blockquote><p>句柄包含一些持久化，不可复制之类的句柄，每次我们在js中new一个对象，就会在当前VM创建一个句柄。</p></blockquote><h4 id="inject-hello-world"><a href="#inject-hello-world" class="headerlink" title="inject hello world"></a>inject hello world</h4><p>直接来看这段代码，代码选自官方文档：<br><a href="https://chromium.googlesource.com/v8/v8/+/branch-heads/6.8/samples/hello-world.cc">https://chromium.googlesource.com/v8/v8/+/branch-heads/6.8/samples/hello-world.cc</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/libplatform/libplatform.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/v8.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  <span class="hljs-comment">// 初始化 V8。</span><br>  v8::V8::<span class="hljs-built_in">InitializeICUDefaultLocation</span>(argv[<span class="hljs-number">0</span>]);<br>  v8::V8::<span class="hljs-built_in">InitializeExternalStartupData</span>(argv[<span class="hljs-number">0</span>]);<br>  std::unique_ptr&lt;v8::Platform&gt; platform = v8::platform::<span class="hljs-built_in">NewDefaultPlatform</span>();<br>  v8::V8::<span class="hljs-built_in">InitializePlatform</span>(platform.<span class="hljs-built_in">get</span>());<br>  v8::V8::<span class="hljs-built_in">Initialize</span>();<br>  <span class="hljs-comment">// 创建一个新的 Isolate 并使其成为当前 Isolate。</span><br>  v8::Isolate::CreateParams create_params;<br>  create_params.array_buffer_allocator =<br>      v8::ArrayBuffer::Allocator::<span class="hljs-built_in">NewDefaultAllocator</span>();<br>  v8::Isolate* isolate = v8::Isolate::<span class="hljs-built_in">New</span>(create_params);<br>  &#123;<br>    v8::<span class="hljs-function">Isolate::Scope <span class="hljs-title">isolate_scope</span><span class="hljs-params">(isolate)</span></span>;<br>    <span class="hljs-comment">// 创建一个堆栈分配的句柄范围。</span><br>    <span class="hljs-function">v8::HandleScope <span class="hljs-title">handle_scope</span><span class="hljs-params">(isolate)</span></span>;<br>    <span class="hljs-comment">// 创建新的上下文.</span><br>    v8::Local&lt;v8::Context&gt; context = v8::Context::<span class="hljs-built_in">New</span>(isolate);<br>    <span class="hljs-comment">// 输入编译和运行 hello world 脚本的上下文。</span><br>    v8::<span class="hljs-function">Context::Scope <span class="hljs-title">context_scope</span><span class="hljs-params">(context)</span></span>;<br>    <span class="hljs-comment">// 创建一个包含 JavaScript 源代码的字符串。</span><br>    v8::Local&lt;v8::String&gt; source =<br>        v8::String::<span class="hljs-built_in">NewFromUtf8</span>(isolate, <span class="hljs-string">&quot;&#x27;Hello&#x27; + &#x27;, World!&#x27;&quot;</span>,<br>                                v8::NewStringType::kNormal)<br>            .<span class="hljs-built_in">ToLocalChecked</span>();<br>    <span class="hljs-comment">// 编译源代码。</span><br>    v8::Local&lt;v8::Script&gt; script =<br>        v8::Script::<span class="hljs-built_in">Compile</span>(context, source).<span class="hljs-built_in">ToLocalChecked</span>();<br>    <span class="hljs-comment">//运行脚本得到结果。</span><br>    v8::Local&lt;v8::Value&gt; result = script-&gt;<span class="hljs-built_in">Run</span>(context).<span class="hljs-built_in">ToLocalChecked</span>();<br>    <span class="hljs-comment">// 将结果转换为 UTF8 字符串并打印。</span><br>    v8::<span class="hljs-function">String::Utf8Value <span class="hljs-title">utf8</span><span class="hljs-params">(isolate, result)</span></span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, *utf8);<br>  &#125;<br>  <span class="hljs-comment">// 处理 isolate 并拆除 V8。</span><br>  isolate-&gt;<span class="hljs-built_in">Dispose</span>();<br>  v8::V8::<span class="hljs-built_in">Dispose</span>();<br>  v8::V8::<span class="hljs-built_in">ShutdownPlatform</span>();<br>  <span class="hljs-keyword">delete</span> create_params.array_buffer_allocator;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从上述的代码就能清楚的看到，本地句柄的创建，本地句柄保存在堆栈中，并在调用适当的析构函数时被删除。这些句柄的生命周期由句柄范围决定，通常在函数调用开始时创建。当 handle 作用域被删除时，垃圾收集器可以自由地释放 handle 作用域中 handle 先前引用的那些对象，前提是它们不再可以从 JavaScript 或其他 handle 访问。</p><h3 id="CodeStubAssembler"><a href="#CodeStubAssembler" class="headerlink" title="CodeStubAssembler"></a>CodeStubAssembler</h3><p>V8 的 CodeStubAssembler 是一个定制的、与平台无关的汇编器，它提供低级原语作为对汇编的精简抽象，但也提供了一个广泛的高级功能库。</p><h4 id="编写内置的CSA"><a href="#编写内置的CSA" class="headerlink" title="编写内置的CSA"></a>编写内置的CSA</h4><p>我们将编写一个简单的 CSA 内置函数，它接受一个参数，并返回它是否代表数字42。内置函数通过将其安装在Math对象上而暴露给 JS。</p><p>这个例子演示了：</p><ul><li>创建一个带有 JavaScript 链接的内置 CSA，它可以像 JS 函数一样被调用。</li><li>使用 CSA 实现简单逻辑：Smi 和堆编号处理、条件以及对 TFS 内置函数的调用。</li><li>使用 CSA 变量。</li><li>Math在对象上安装内置的 CSA 。</li></ul><h4 id="声明-MathIs42"><a href="#声明-MathIs42" class="headerlink" title="声明 MathIs42"></a>声明 <code>MathIs42</code></h4><p>在<code>src/builtins/builtins-definitions.h</code>声明如下内容：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUILTIN_LIST_BASE(CPP, API, TFJ, TFC, TFS, TFH, ASM, DBG)              \</span><br><span class="hljs-meta">  <span class="hljs-comment">// […snip…]</span></span><br>  <span class="hljs-built_in">TFJ</span>(MathIs42, <span class="hljs-number">1</span>, kX)                                                         \<br>  <span class="hljs-comment">// […snip…]</span><br></code></pre></div></td></tr></table></figure><p>可以看到内置函数在BUILTIN_LIST_BASE宏中声明，BUILTIN_LIST_BASE采用几个不同的宏来表示不同的内置类型。</p><ul><li>TFJ：JavaScript 链接。</li><li>TFS：存根链接。</li><li>TFC：需要自定义接口描述符的内置存根链接（例如，如果参数未标记或需要在特定寄存器中传递）。</li><li>TFH：用于 IC 处理程序的内置专用存根链接。</li></ul><blockquote><p>注意：如果定义了多个内置函数，需要注意他们的顺序。</p></blockquote><h4 id="定义MathIs42"><a href="#定义MathIs42" class="headerlink" title="定义MathIs42"></a>定义MathIs42</h4><p>在<code>src/builtins/builtins-math-gen.cc</code>编写如下内容，您也可以查看<code>src/builtins/builtins-*-gen.cc</code>这些文件，会找到很多熟悉的身影。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// TF_BUILTIN是一个方便的宏，用于创建给定对象的一个新子类</span><br><span class="hljs-comment">//幕后的汇编程序。</span><br><span class="hljs-built_in">TF_BUILTIN</span>(MathIs42, MathBuiltinsAssembler) &#123;<br>  <span class="hljs-comment">//加载当前函数上下文(每个存根的隐式参数)和X参数。注意，我们可以通过名称来引用参数.</span><br>  Node* <span class="hljs-type">const</span> context = <span class="hljs-built_in">Parameter</span>(Descriptor::kContext);<br>  Node* <span class="hljs-type">const</span> x = <span class="hljs-built_in">Parameter</span>(Descriptor::kX);<br><br>  <span class="hljs-comment">//在这一点上，x基本上可以是任何东西- Smi, HeapNumber，undefined，或任何其他任意JS对象。</span><br>  <span class="hljs-comment">// 让我们调用ToNumber，将x转换为我们可以使用的数字。</span><br>  <span class="hljs-comment">// CallBuiltin可以方便地调用任何CSA内置。</span><br>  Node* <span class="hljs-type">const</span> number = <span class="hljs-built_in">CallBuiltin</span>(Builtins::kToNumber, context, x);<br><br>  <span class="hljs-comment">//创建一个CSA变量来存储结果值。</span><br>  <span class="hljs-comment">//变量是kTagged，因为我们将只存储带标记的指针。</span><br>  <span class="hljs-built_in">VARIABLE</span>(var_result, MachineRepresentation::kTagged);<br><br>  <span class="hljs-comment">//我们需要定义两个标签作为跳转目标。</span><br>  <span class="hljs-function">Label <span class="hljs-title">if_issmi</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span>, <span class="hljs-title">if_isheapnumber</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span>, <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br><br>  <span class="hljs-comment">// ToNumber总是返回一个数字。我们需要区分Smis和堆号——在这里，我们检查number是否为Smi，并且是有条件跳转到相应的标签。</span><br>  <span class="hljs-built_in">Branch</span>(<span class="hljs-built_in">TaggedIsSmi</span>(number)， &amp;if_issmi， &amp;if_isheapnumber);<br><br>  <span class="hljs-comment">//绑定标签开始为它生成代码。</span><br>  <span class="hljs-built_in">BIND</span>(&amp;if_issmi);<br>  ｛<br>    <span class="hljs-comment">// SelectBooleanConstant返回JS的true/false值</span><br>    <span class="hljs-comment">//传递的条件是否为true/false。结果必然是我们的</span><br>    <span class="hljs-comment">// var_result变量，然后无条件跳转到out标签。</span><br>    var_result.<span class="hljs-built_in">Bind</span>(<span class="hljs-built_in">SelectBooleanConstant</span>(<span class="hljs-built_in">SmiEqual</span>(number, <span class="hljs-built_in">SmiConstant</span>(<span class="hljs-number">42</span>))));<br>    <span class="hljs-built_in">Goto</span>(&amp;out);<br>  &#125;<br><br>  <span class="hljs-built_in">BIND</span>(&amp;if_isheapnumber);<br>  ｛<br>    <span class="hljs-comment">// 只是为了确保ToNumber只能返回Smi或堆号。我们在这里添加一个断言，验证number实际上是堆号。</span><br>    <span class="hljs-built_in">CSA_ASSERT</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">IsHeapNumber</span>(number));<br>    <span class="hljs-comment">// 堆数包装浮点值。我们需要显式地提取此值，执行浮点比较。</span><br>    <span class="hljs-comment">// 然后再次绑定基于结果的var_result。</span><br>    Node* <span class="hljs-type">const</span> value = <span class="hljs-built_in">LoadHeapNumberValue</span>(number);<br>    Node* <span class="hljs-type">const</span> is_42 = <span class="hljs-built_in">Float64Equal</span>(value, <span class="hljs-built_in">Float64Constant</span>(<span class="hljs-number">42</span>));<br>    var_result.<span class="hljs-built_in">Bind</span>(<span class="hljs-built_in">SelectBooleanConstant</span>(is_42));<br>    <span class="hljs-built_in">Goto</span>(&amp;out);<br>  &#125;<br><br>  <span class="hljs-built_in">BIND</span>(&amp;out);<br>  &#123;<br>    Node* <span class="hljs-type">const</span> result = var_result.<span class="hljs-built_in">value</span>();<br>    <span class="hljs-built_in">CSA_ASSERT</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">IsBoolean</span>(result));<br>    <span class="hljs-built_in">Return</span>(result);<br>  &#125;<br>&#125;<br> <br></code></pre></div></td></tr></table></figure><h4 id="设置到js中"><a href="#设置到js中" class="headerlink" title="设置到js中"></a>设置到js中</h4><p>像Math这样的内置对象主要是在<code>src/bootstrapper.cc</code>中设置的。代码如下:</p> <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// 设置Math的现有代码，为了清晰起见包含在这里。</span><br>Handle&lt;JSObject&gt; math = factory-&gt;<span class="hljs-built_in">NewJSObject</span>(cons, TENURED);<br>JSObject::<span class="hljs-built_in">AddProperty</span>(global, name, math, DONT_ENUM);<br><span class="hljs-comment">// […snip…]</span><br><span class="hljs-built_in">SimpleInstallFunction</span>(math, <span class="hljs-string">&quot;is42&quot;</span>, Builtins::kMathIs42, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<span class="hljs-comment">//++</span><br></code></pre></div></td></tr></table></figure><p> 当设置完之后，就可以编译调用了。</p> <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"> $ </span><span class="language-bash">out/debug/d8</span><br><span class="hljs-meta prompt_">d8&gt; </span><span class="language-bash">Math.is42(42);</span><br>true<br><span class="hljs-meta prompt_">d8&gt; </span><span class="language-bash">Math.is42(<span class="hljs-string">&#x27;42.0&#x27;</span>);</span><br>true<br><span class="hljs-meta prompt_">d8&gt; </span><span class="language-bash">Math.is42(<span class="hljs-literal">true</span>);</span><br>false<br><span class="hljs-meta prompt_">d8&gt; </span><span class="language-bash">Math.is42(&#123; valueOf: () =&gt; 42 &#125;);</span><br>true<br></code></pre></div></td></tr></table></figure><p> 使用 TFS 构建内置函数是在编译时生成的，并包含在 V8 快照中，不会在isolate中占用大量的空间。</p><h4 id="为我们的内置函数编写测试代码"><a href="#为我们的内置函数编写测试代码" class="headerlink" title="为我们的内置函数编写测试代码"></a>为我们的内置函数编写测试代码</h4><p> 在<code>test/cctest/compiler/test-run-stubs.cc</code>编写内容如下：</p> <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">TEST</span>(MathIsHeapNumber42) &#123;<br>  HandleAndZoneScope scope;<br>  Isolate* isolate = scope.<span class="hljs-built_in">main_isolate</span>();<br>  Heap* heap = isolate-&gt;<span class="hljs-built_in">heap</span>();<br>  Zone* zone = scope.<span class="hljs-built_in">main_zone</span>();<br><br>  <span class="hljs-function">StubTester <span class="hljs-title">tester</span><span class="hljs-params">(isolate, zone, Builtins::kMathIs42)</span></span>;<br>  Handle&lt;Object&gt; result1 = tester.<span class="hljs-built_in">Call</span>(<span class="hljs-built_in">Handle</span>&lt;Smi&gt;(Smi::<span class="hljs-built_in">FromInt</span>(<span class="hljs-number">0</span>), isolate));<br>  <span class="hljs-built_in">CHECK</span>(result1-&gt;<span class="hljs-built_in">BooleanValue</span>());<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://v8.dev/docs">https://v8.dev/docs</a></li></ol><h3 id="叽里呱啦"><a href="#叽里呱啦" class="headerlink" title="叽里呱啦"></a>叽里呱啦</h3><p>欲吊文章太守，仍歌杨柳春风。<br>「西江月·平山堂」<br>苏轼</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>死亡不是终点，遗忘才是</title>
    <link href="/2022/12/31/%E9%81%97%E5%98%B1/"/>
    <url>/2022/12/31/%E9%81%97%E5%98%B1/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>史铁生说过，死亡是一件不必急于求成的事，是一场必将会降临的节日。他是一个真正意义上<br>乐观，伟大的人。<br>感觉这里应该会修修补补。能不能有个区块链应用把我的资产全部串起来，得研究一下，感觉有点边缘产业那味了。</p><h3 id="如果俺嘎了"><a href="#如果俺嘎了" class="headerlink" title="如果俺嘎了"></a>如果俺嘎了</h3><p>我的所有密码都是 chrome 浏览器推荐的密码，记不住，所以会有一个密码本，记录我所有的密码。<br>我在硬盘里存着一些加密的重要的东西，顺便也一起埋了吧。<br>家里的服务器如果没人能够维护，基本也是没啥用了，一些公益性的服务就会有的可惜，到时候直接开源出源代码啥的吧。</p><p>如果我嘎了，希望国内已经出现生态葬礼了，让微生物把我分解了之后，还给地球，可以用于种树，种花，当然，如果你不怕我的话哈哈哈哈。我保证我不会吓你的。</p><p>我会把这个域名续个几十年，好让大家知道我写的垃圾代码，虽然没人认识我哈哈。</p><p>以上的思考，属于吃饱了没事干，开始忽视乱想了。</p><h3 id="我的游戏资产"><a href="#我的游戏资产" class="headerlink" title="我的游戏资产"></a>我的游戏资产</h3><h4 id="QQ-游戏资产"><a href="#QQ-游戏资产" class="headerlink" title="QQ 游戏资产"></a>QQ 游戏资产</h4><p>最主要的就是 qq 号了，能代表个人身份的东西，还有就是小时候玩的 DNF 和 CF 了，当然现在这两个已经快凉了，没什么玩家了，都是一些主播啥的。</p><h4 id="steam"><a href="#steam" class="headerlink" title="steam"></a>steam</h4><p>steam 最方便，游戏都放一起了，直接继承。</p><h3 id="账号资产"><a href="#账号资产" class="headerlink" title="账号资产"></a>账号资产</h3><p>我的账号都会存在一个需要密码学知识解密的地方:<a href="https://waterbang.top/">入口</a></p><h3 id="钱财"><a href="#钱财" class="headerlink" title="钱财"></a>钱财</h3><p>人民币，股票，数字货币，的东西不好统计，现在也没钱，得以后补充哈哈哈。</p><h3 id="我的书籍-📚"><a href="#我的书籍-📚" class="headerlink" title="我的书籍 📚"></a>我的书籍 📚</h3><p>我的书籍会陆续免费寄给一些想要读书的小伙伴，或者是直接捐给图书馆，书籍和知识应该是流动的，而不是沾满灰尘。</p><h3 id="关于葬礼"><a href="#关于葬礼" class="headerlink" title="关于葬礼"></a>关于葬礼</h3><p>如果要放歌，从我的 QQ 音乐里找吧，我的音乐库都是积极健康向上的，我嘎了能让大家搓一顿，我还是很开心的。至于那些哭爹喊娘，坟头蹦迪，跪拜啊啥的，还是不要了，一切从简。</p><h3 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h3><p>我好像也没重要的东西了，我的骨灰盒（如果有，直接买最便宜的，或者帮我找个奶粉罐子装一下），但是应该不会有骨灰盒这东西了，装这些碳有啥用，直接帮我搞到深林里，当作 🌲 的养料吧。</p><blockquote><p>写于 2022 年 12 月 31 日，天气晴<br>更改与 2023 年 7 月 31 日，小雨</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>tag</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年终总结</title>
    <link href="/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>嘻嘻哈哈呼呼！2022过完了，这一年的收获非常多，进了一家好公司，小伙伴们都很好，学习到很多的东西。好好学习天天向上，好好学习天天向上。</p><h3 id="工作内容"><a href="#工作内容" class="headerlink" title="工作内容"></a>工作内容</h3><p>今年在编程上学到了许多东西，代码主线也没有在写业务了，所以对我个人半桶水的编程技巧是很大的考验，也是机遇。（还好有超级大佬和小伙伴们带一下，不然问题有点大</p><p>今年的工作主要是开源工作：</p><p><img src="/./github-commit.png" alt="git commit"></p><p>主要工作内容围绕着<a href="https://github.com/BioforestChain/plaoc">plaoc</a>和<a href="https://github.com/BioforestChain/bfsa-std">bfsa-std</a>。</p><blockquote><p>总结：做着做着不会了问大佬。</p></blockquote><p>在这里打个广告哈哈，想要加入这个<a href="https://github.com/HighValyrian">HighValyrian</a>的留言你的github ID 哈。(求求了</p><p>这个代码组织没有啥实际作用，可以搞一些学习时候的笔记，或者是喜欢的项目，不会对个人产生任何约束。</p><h3 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h3><p>今年的编程技巧是没有较大的提升的，主要提升的还是代码的认知能力和整体的逻辑判断。<br>也学习了很多新语言，比如说<code>rust</code>,<code>kotlin</code>,<code>swift</code>。也是一些跟项目相关的语言，ios并不熟悉，可以理解为只会<code>hello world</code>水平。</p><p>最难的是<code>rust</code>部分，接触的主要是<code>deno</code>源码和<code>rusty_v8</code>，后者是rust对v8的rust绑定。也是学得一知半解，针对这部分的优化，还需要好好学习一下。</p><h3 id="硬件内容"><a href="#硬件内容" class="headerlink" title="硬件内容"></a>硬件内容</h3><p>今年我的电烙铁就修了一个冰箱😂，还是买好的电路板回来换了一下，十分简单的操作，装了一波哈哈哈，（人在某个方面总是爱装的，难受）。</p><p>今年最主要的是搞了个树莓派，8g的，用来当作个人服务器，不然每次都租太贵了，主要用来开我的世界服务器（要一起玩的留言，服务器没什么人的，也可以直接加QQ群：711745023）。还有就是用来做文件存储。挂载一些服务。</p><p><img src="/./pi.jpg" alt="树莓派"></p><h3 id="书籍阅读"><a href="#书籍阅读" class="headerlink" title="书籍阅读"></a>书籍阅读</h3><p>今年读的内容偏小说向，把余华的小说基本都读完了，太丧的一本《第七天》就没读了，膈应人啊哥哥们。<br>最喜欢的是《活着》，《文城》，《兄弟》也还行，不过我前半段看不太懂，年代距离有点久远，无法理解一些行为和事件，还有最近在看的刘慈欣的《三体》三部，现在才看到第二部。</p><p>阎真的《沧浪之海》看了一半，看不下去了，不喜欢这种等级森严，处处小心的官场氛围。</p><blockquote><p>总结：今年没有读程序方面的书籍，都在看小说，小说能让人快速体验别人的一生，体验作者的第二人格。</p></blockquote><h3 id="叽里呱啦"><a href="#叽里呱啦" class="headerlink" title="叽里呱啦"></a>叽里呱啦</h3><p>写总结，是为了让自己明白，这一年在干嘛，有没有浪费了一年，等我50岁再来看，不知道会咋样，突然想给自己写份遗嘱了，现在写会不会🥺太早了，在线问，挺急的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>年度总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deno uses OP to call javaScript</title>
    <link href="/2022/08/10/Deno_uses_OP_to_call_javaScript/"/>
    <url>/2022/08/10/Deno_uses_OP_to_call_javaScript/</url>
    
    <content type="html"><![CDATA[<h2 id="preface"><a href="#preface" class="headerlink" title="preface"></a>preface</h2><blockquote><p>⚠️ This IS MY FIRST ATTEMPT TO write IN English. Please note that the following code may be wrong. It is still being modified.</p></blockquote><p><code>javascript</code> using <code>op</code> to call <code>rust</code> is relatively simple, and the <code>Deno</code> source code also has many examples.<br>This paper mainly focuses on how <code>deno</code> calls<code>javascript</code>, or in another way, how to give <code>deno</code> data to <code>javascript</code>.<br>The approach in this paper is to write polling functions in javascript that constantly ask rust for data. To achieve back pressure.</p><h3 id="How-to-write"><a href="#How-to-write" class="headerlink" title="How to write"></a>How to write</h3><p>The pseudocode is as follows.</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// Remember to register the OP function with the JS Runtime</span><br>[op]<br><span class="hljs-title function_ invoke__">op_rust_to_js_buffer</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;,AnyError&gt; &#123;<br> <span class="hljs-comment">// This DATA is a global static variable</span><br>  <span class="hljs-keyword">match</span> DATA &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(r)=&gt; &#123;<span class="hljs-title function_ invoke__">Ok</span>(r)&#125;，<br>    <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; &#123;deno_core::error::custom_error&#123;<br>      <span class="hljs-string">&quot;op_rust_to_js_buffer&quot;</span>,<br>      <span class="hljs-string">&quot;no Found data&quot;</span><br>    &#125;&#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">op_rust_to_js_buffer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> buffer = <span class="hljs-title class_">Deno</span>.<span class="hljs-property">core</span>.<span class="hljs-title function_">opSync</span>(<span class="hljs-string">&quot;op_rust_to_js_buffer&quot;</span>);  <span class="hljs-comment">// return Vec&lt;u8&gt; -&gt; Unit8Array</span><br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Textdecoder</span>().<span class="hljs-title function_">decode</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Unit8Array</span>(buffer));<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<span class="hljs-keyword">catch</span>(e) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handlerFactory</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">op_rust_to_js_buffer</span>(); <span class="hljs-comment">// server boom </span><br>    <span class="hljs-comment">//....</span><br>  &#125;);<br>&#125;<br><span class="hljs-title function_">handlerFactory</span>();<br></code></pre></div></td></tr></table></figure><p>I’ve tried the following, but it has a heap overflow.</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">op_rust_to_js_buffer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> buffer = <span class="hljs-title class_">Deno</span>.<span class="hljs-property">core</span>.<span class="hljs-title function_">opAsync</span>(<span class="hljs-string">&quot;op_rust_to_js_buffer&quot;</span>).<span class="hljs-title function_">then</span>();  <span class="hljs-comment">// return Vec&lt;u8&gt; -&gt; Unit8Array</span><br>      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Textdecoder</span>().<span class="hljs-title function_">decode</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Unit8Array</span>(buffer));<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>      <span class="hljs-title function_">resolve</span>(result)<br>    &#125;<span class="hljs-keyword">catch</span>(e) &#123;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">op_rust_to_js_buffer</span>())<br>&#125;<br></code></pre></div></td></tr></table></figure><p><a href="https://github.com/Gaubee">Gaubee</a>:</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/// 两个核心函数</span><br><span class="hljs-keyword">const</span> callRust = <span class="hljs-title class_">Deno</span>.<span class="hljs-property">core</span>.<span class="hljs-title function_">opSync</span>(<span class="hljs-string">&quot;op_js_to_rust&quot;</span>);<br><span class="hljs-keyword">const</span> waitRustBuffer = <span class="hljs-title class_">Deno</span>.<span class="hljs-property">core</span>.<span class="hljs-title function_">opAsync</span>(<span class="hljs-string">&quot;op_rust_to_js_buffer&quot;</span>);<br><br><span class="hljs-comment">/// 原始的调用</span><br><span class="hljs-keyword">let</span> acc_call_id = <span class="hljs-number">0</span>;<br>&#123;<br>  <span class="hljs-keyword">const</span> callId = acc_call_id++;<br>  <span class="hljs-title function_">callRust</span>(callId, ...some_args);<br><br>  <span class="hljs-keyword">const</span> buffer1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">waitRustBuffer</span>(callId);<br>  <span class="hljs-keyword">const</span> buffer2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">waitRustBuffer</span>(callId);<br>  <span class="hljs-keyword">const</span> buffer3 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">waitRustBuffer</span>(callId);<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">/// 深度封装</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyModule</span> &#123;<br>  private <span class="hljs-keyword">static</span> _acc_id = <span class="hljs-number">0</span>;<br>  private _id = <span class="hljs-title class_">MyModule</span>.<span class="hljs-property">_acc_id</span>++;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 第一种封装，使用 AsyncGenerator</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">async</span> *<span class="hljs-title function_">call1</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> callId = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>;<br>    <span class="hljs-title function_">callRust</span>(callId, ...args);<br><br>    <span class="hljs-keyword">do</span> &#123;<br>      <span class="hljs-keyword">const</span> buffer1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">waitRustBuffer</span>(callId);<br>      <span class="hljs-comment">/// 基于数据的规范，来定义什么时候结束</span><br>      <span class="hljs-keyword">if</span> (buffer1.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-comment">/// 返回数据</span><br>      <span class="hljs-keyword">yield</span> buffer1;<br>      <span class="hljs-comment">/// 这里是重点，使用 do-while ，替代 finally，可以避免堆栈溢出。</span><br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 第二种封装，手写 AsyncGenerator</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">call2</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> callId = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>;<br>    <span class="hljs-title function_">callRust</span>(callId, ...args);<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-keyword">async</span> <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">await</span> <span class="hljs-title function_">waitRustBuffer</span>(callId);<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">value</span>: buffer,<br>          <span class="hljs-attr">done</span>: buffer.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>,<br>        &#125;;<br>      &#125;,<br>      <span class="hljs-keyword">return</span>() &#123;<br>        <span class="hljs-comment">/// 这里可以手动控制异步迭代器被 “中止” 释放</span><br>      &#125;,<br>      <span class="hljs-keyword">throw</span>() &#123;<br>        <span class="hljs-comment">/// 这里可以手动控制异步迭代器被 “中止” 释放</span><br>      &#125;,<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>整理了一下：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loopRustBuffer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">let</span> buffer = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>        buffer = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Deno</span>.<span class="hljs-property">core</span>.<span class="hljs-title function_">opAsync</span>(<span class="hljs-string">&quot;op_rust_to_js_buffer&quot;</span>);<br>        <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>().<span class="hljs-title function_">decode</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buffer));<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;rust send message to deno_js:&quot;</span>, <span class="hljs-built_in">string</span>);<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>,<br>          <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>,<br>        &#125;;<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">value</span>: buffer,<br>          <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>,<br>        &#125;;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-keyword">return</span>() &#123;<br>      <span class="hljs-comment">/// Here you can manually control the asynchronous iterator to be &quot;aborted&quot; and released</span><br>    &#125;,<br>    <span class="hljs-keyword">throw</span>() &#123;<br>      <span class="hljs-comment">/// Here you can manually control the asynchronous iterator to be &quot;aborted&quot; and released</span><br>    &#125;,<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">async</span> *<span class="hljs-title function_">waterOverflow</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">await</span> <span class="hljs-title function_">loopRustBuffer</span>().<span class="hljs-title function_">next</span>();<br>        <span class="hljs-comment">/// Data-based specification to define when to end</span><br>        <span class="hljs-comment">// if (isWaitingData &gt; this.heightWaterMark) &#123;</span><br>        <span class="hljs-comment">//   console.log(</span><br>        <span class="hljs-comment">//     &quot;waterOverflow====&gt;&quot;,</span><br>        <span class="hljs-comment">//     isWaitingData,</span><br>        <span class="hljs-comment">//     heightWaterMark</span><br>        <span class="hljs-comment">//   );</span><br>        <span class="hljs-comment">//   break;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">if</span> (!buffer.<span class="hljs-property">done</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">isWaitingData</span>++;<br>        &#125;<br>        <span class="hljs-keyword">yield</span> buffer;<br>        <span class="hljs-comment">/// Here is the point, use do-while instead of finally, you can avoid stack overflow。</span><br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>  &#125;<br><br>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> <span class="hljs-title function_">waterOverflow</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (!num.<span class="hljs-property">done</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;webView.waterOverflow:&quot;</span>, num);<br>    &#125;<br>  &#125;<br>&#125;)();<br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>deno javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFS开发问题汇总</title>
    <link href="/2022/08/08/BFS%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2022/08/08/BFS%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>BFS运行时本质上是一个操作系统，主要目的是</p><ol><li>为了解决现代单页面应用（SPA）的性能不足问题。</li><li>为开发者提供<code>android</code>,<code>ios</code>和<code>desktop</code>端的应用开发。</li><li>为了契合面向角色编程和开发BFS资产做准备，为区块链开发做社区基础建设。</li></ol><h2 id="rust混合编译问题"><a href="#rust混合编译问题" class="headerlink" title="rust混合编译问题"></a>rust混合编译问题</h2><h3 id="修复-failed-to-run-custom-build-command-for-ring-v0-16-20"><a href="#修复-failed-to-run-custom-build-command-for-ring-v0-16-20" class="headerlink" title="修复 failed to run custom build command for ring v0.16.20"></a>修复 failed to run custom build command for <code>ring v0.16.20</code></h3><p>运行  </p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">RUST_BACKTRACE=1 cargo build --target=aarch64-linux-android --release<br></code></pre></div></td></tr></table></figure><p>发现</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">--- stderr<br> error occurred: Failed to find tool. Is `aarch64-linux-android-clang` installed?<br></code></pre></div></td></tr></table></figure><p>原因是环境变量的名称错误，需要更改一下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /Users/mac/Library/Android/sdk/ndk/21.3.6528147/toolchains/llvm/prebuilt/darwin-x86_64/bin/<br><br><span class="hljs-built_in">cp</span> aarch64-linux-android28-clang aarch64-linux-android-clang <br></code></pre></div></td></tr></table></figure><h3 id="修复error-failed-to-run-custom-build-command-for-libffi-sys-v1-3-2"><a href="#修复error-failed-to-run-custom-build-command-for-libffi-sys-v1-3-2" class="headerlink" title="修复error: failed to run custom build command for libffi-sys v1.3.2"></a>修复error: failed to run custom build command for <code>libffi-sys v1.3.2</code></h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">brew install autoconf automake libtool   <br></code></pre></div></td></tr></table></figure><p>然后 在ext&#x2F;ffi&#x2F;cargo.toml<br>修改版本为：libffi &#x3D; “3.0.0”</p><h2 id="rust-v8-问题汇总"><a href="#rust-v8-问题汇总" class="headerlink" title="rust_v8 问题汇总"></a>rust_v8 问题汇总</h2><h3 id="解决使用容器编译下载报错问题（这块仅供参考，具体位置查看build-rs文件）"><a href="#解决使用容器编译下载报错问题（这块仅供参考，具体位置查看build-rs文件）" class="headerlink" title="解决使用容器编译下载报错问题（这块仅供参考，具体位置查看build.rs文件）"></a>解决使用容器编译下载报错问题（这块仅供参考，具体位置查看build.rs文件）</h3><ol><li><p>下载: <a href="https://codeload.github.com/denoland/ninja_gn_binaries/tar.gz/refs/tags/20220517">https://codeload.github.com/denoland/ninja_gn_binaries/tar.gz/refs/tags/20220517</a><br>解压到：tools目录下</p></li><li><p>下载: <a href="https://commondatastorage.googleapis.com/chromium-browser-clang/Linux_x64/clang-llvmorg-15-init-9576-g75f9e83a-3.tgz">https://commondatastorage.googleapis.com/chromium-browser-clang/Linux_x64/clang-llvmorg-15-init-9576-g75f9e83a-3.tgz</a><br>解压到：tools&#x2F;clang  </p></li><li><p>下载: <a href="https://commondatastorage.googleapis.com/chrome-linux-sysroot/toolchain/3dc473ad845d3ae810c3e1be6f377e3eaa301c6e/debian_bullseye_arm64_sysroot.tar.xz">https://commondatastorage.googleapis.com/chrome-linux-sysroot/toolchain/3dc473ad845d3ae810c3e1be6f377e3eaa301c6e/debian_bullseye_arm64_sysroot.tar.xz</a><br>解压到：build&#x2F;linux&#x2F;debian_bullseye_arm64-sysroot</p></li><li><p>下载：git clone <a href="https://chromium.googlesource.com/chromium/src/third_party/android_platform">https://chromium.googlesource.com/chromium/src/third_party/android_platform</a></p></li><li><p>下载：git clone <a href="https://github.com/denoland/android_ndk.git">https://github.com/denoland/android_ndk.git</a></p></li><li><p>下载：git clone <a href="https://chromium.googlesource.com/catapult.git">https://chromium.googlesource.com/catapult.git</a><br>到 third_party<br>并且需要添加到环境变量：<code>GN</code>, <code>NINJA</code>,<code>CLANG_BASE_PATH</code>, <code>GN_ARGS</code></p></li></ol><h4 id="ERROR-at-build-config-mac-mac-sdk-gni-95-31-No-value-named-“xcode-build”-in-scope-“-mac-sdk-result”-v8-0-48-0-xcode-build-mac-sdk-result-xcode-build"><a href="#ERROR-at-build-config-mac-mac-sdk-gni-95-31-No-value-named-“xcode-build”-in-scope-“-mac-sdk-result”-v8-0-48-0-xcode-build-mac-sdk-result-xcode-build" class="headerlink" title="ERROR at &#x2F;&#x2F;build&#x2F;config&#x2F;mac&#x2F;mac_sdk.gni:95:31: No value named “xcode_build” in scope “_mac_sdk_result”[v8 0.48.0] xcode_build &#x3D;_mac_sdk_result.xcode_build"></a>ERROR at &#x2F;&#x2F;build&#x2F;config&#x2F;mac&#x2F;mac_sdk.gni:95:31: No value named “xcode_build” in scope “_mac_sdk_result”[v8 0.48.0] xcode_build &#x3D;_mac_sdk_result.xcode_build</h4><p>安装 xcode</p><h4 id="ERROR-at-dynamically-parsed-input-that-build-config-mac-mac-sdk-gni-93-19-loaded-1-15-This-is-not-a-valid-number-xcode-build-11C505"><a href="#ERROR-at-dynamically-parsed-input-that-build-config-mac-mac-sdk-gni-93-19-loaded-1-15-This-is-not-a-valid-number-xcode-build-11C505" class="headerlink" title="ERROR at dynamically parsed input that &#x2F;&#x2F;build&#x2F;config&#x2F;mac&#x2F;mac_sdk.gni:93:19 loaded :1:15: This is not a valid number.xcode_build&#x3D;11C505"></a>ERROR at dynamically parsed input that &#x2F;&#x2F;build&#x2F;config&#x2F;mac&#x2F;mac_sdk.gni:93:19 loaded :1:15: This is not a valid number.xcode_build&#x3D;11C505</h4><p>File “&#x2F;Users&#x2F;mac&#x2F;Desktop&#x2F;waterbang&#x2F;project&#x2F;rust&#x2F;rusty_v8&#x2F;build&#x2F;config&#x2F;apple&#x2F;sdk_info.py”, line 71<br>修改为 <code>int[lines[-1].split(](-1),16)</code></p><h4 id="fatal-error-‘features-h’-file-not-found"><a href="#fatal-error-‘features-h’-file-not-found" class="headerlink" title="fatal error: ‘features.h’ file not found"></a>fatal error: ‘features.h’ file not found</h4><p>检查  <code>--sysroot=../../../../third_party/android_ndk/toolchains/llvm/prebuilt/darwin-x86_64/sysroot</code><br>观察ndk,是否没有<code>darwin-x86_64</code>,把目录下：<br><code>third_party/android_ndk/toolchains/llvm/prebuilt/</code>的其他版本复制一分重命名为<code>darwin-x86_64</code>，或者是别的系统名。</p><h2 id="android-问题汇总"><a href="#android-问题汇总" class="headerlink" title="android 问题汇总"></a>android 问题汇总</h2><h3 id="使用android-studio生成JNI"><a href="#使用android-studio生成JNI" class="headerlink" title="使用android studio生成JNI"></a>使用android studio生成JNI</h3><p>打开设置路径：Tools-&gt;External Tools , 点击添加。</p><p><img src="/./jni.jpeg" alt="add jni"></p><blockquote><p>-classpath -v -jni -d $ContentRoot$&#x2F;jni<br>-d $ContentRoot$&#x2F;jni  -cp “$Classpath$” $FileFQPackage$.$FileNameWithoutAllExtensions$<br>$ModuleFileDir$</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>rust kotlin deno javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-6-6-rust如何通过jni调用kotlin方法</title>
    <link href="/2022/06/06/2022-6-6-rust%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87jni%E8%B0%83%E7%94%A8kotlin%E6%96%B9%E6%B3%95/"/>
    <url>/2022/06/06/2022-6-6-rust%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87jni%E8%B0%83%E7%94%A8kotlin%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网上这方面比较缺少或者不完整，因此记录一下整个流程。<br>增加一下关键字防止搜索不到，这篇教程能让有需要的人少几天的琢磨时间。</p><h3 id="使用rust写安卓库"><a href="#使用rust写安卓库" class="headerlink" title="使用rust写安卓库"></a>使用rust写安卓库</h3><h3 id="rust调用android"><a href="#rust调用android" class="headerlink" title="rust调用android"></a>rust调用android</h3><h3 id="rust通过ffi调用kotlin"><a href="#rust通过ffi调用kotlin" class="headerlink" title="rust通过ffi调用kotlin"></a>rust通过ffi调用kotlin</h3><h3 id="主要的流程"><a href="#主要的流程" class="headerlink" title="主要的流程"></a>主要的流程</h3><p>主要流程是通过全局缓存保存了android的环境变量。以此来实现在rust调用android方法。</p><h3 id="尝试过的方法"><a href="#尝试过的方法" class="headerlink" title="尝试过的方法"></a>尝试过的方法</h3><ol><li>直接通过rust闭包保存android环境，出现了方法不安全。✖️</li><li>通过线程通信，结合闭包传递信息给fni方法。出现了线程通信不安全。✖️</li><li>通过全局变量。也就是接下来的方法。 ✅</li></ol><h3 id="首先先看android部分如何进行加载"><a href="#首先先看android部分如何进行加载" class="headerlink" title="首先先看android部分如何进行加载"></a>首先先看android部分如何进行加载</h3><p>下面是android部分代码。主要是是加载库，然后注册函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> org.bfchain.rust.example<br><br><span class="hljs-keyword">import</span> android.app.IntentService<br><span class="hljs-keyword">import</span> android.content.Intent<br><span class="hljs-keyword">import</span> android.util.Log<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> TAG = <span class="hljs-string">&quot;SERVICE&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DenoService</span> : <span class="hljs-type">IntentService</span>(<span class="hljs-string">&quot;DenoService&quot;</span>) &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-comment">// 加载rust编译的so</span><br>        <span class="hljs-keyword">init</span> &#123;<br>            System.loadLibrary(<span class="hljs-string">&quot;rust_lib&quot;</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IHandleCallback</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleCallback</span><span class="hljs-params">(string: <span class="hljs-type">String</span>)</span></span><br>    &#125;<br>    <span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">nativeSetCallback</span><span class="hljs-params">(callback: <span class="hljs-type">IHandleCallback</span>)</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onHandleIntent</span><span class="hljs-params">(p0: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>        <span class="hljs-comment">// val appContext = applicationContext</span><br><span class="hljs-comment">//        makeStatusNotification(&quot;有医保的先rush&quot;, appContext)</span><br>        nativeSetCallback(<span class="hljs-keyword">object</span> : IHandleCallback &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleCallback</span><span class="hljs-params">(string: <span class="hljs-type">String</span>)</span></span> &#123;<br>                Log.d(<span class="hljs-string">&quot;handleCallback&quot;</span>, <span class="hljs-string">&quot;now rust says:&quot;</span> + string)<br>                <span class="hljs-comment">// callable_map[string]?.let &#123; it() &#125;  // todo 执行你android的方法</span><br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><code>nativeSetCallback</code>函数就是我们通过jni可以调用的方法，我们需要在rust通过全局缓存，把<code>android</code>的状态都缓存下来，<br>以此来实现我们在rust可以直接调用android方法。</p><h3 id="接下来编写rust部分的内容"><a href="#接下来编写rust部分的内容" class="headerlink" title="接下来编写rust部分的内容"></a>接下来编写rust部分的内容</h3><p>先上代码，后面再解释。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> crate::js_bridge::call_android_js;<br><span class="hljs-keyword">use</span> android_logger::Config;<br><span class="hljs-keyword">use</span> lazy_static::*;<br><span class="hljs-keyword">use</span> log::&#123;debug, error, info, Level&#125;;<br><span class="hljs-keyword">use</span> tokio;<br><span class="hljs-comment">// 引用标准库的一些内容</span><br><span class="hljs-keyword">use</span> std::&#123;<br>    ffi::&#123;c_void, CStr, CString&#125;,<br>    sync::&#123;mpsc, Mutex&#125;,<br>    thread,<br>&#125;;<br><span class="hljs-comment">// 引用 jni 库的一些内容，就是上面添加的 jni 依赖</span><br><span class="hljs-keyword">use</span> jni::&#123;<br>    objects::&#123;GlobalRef, JObject, JString, JValue&#125;,<br>    sys::&#123;jint, jstring, JNI_ERR,JNI_VERSION_1_4&#125;,<br>    JNIEnv, JavaVM, NativeMethod,<br>&#125;;<br><br><span class="hljs-comment">// 添加一个全局变量来缓存回调对象</span><br>lazy_static! &#123;<br>    <span class="hljs-comment">// jvm</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> JVM_GLOBAL: Mutex&lt;<span class="hljs-type">Option</span>&lt;JavaVM&gt;&gt; = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">None</span>);<br>    <span class="hljs-comment">//callback</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> JNI_CALLBACK: Mutex&lt;<span class="hljs-type">Option</span>&lt;GlobalRef&gt;&gt; = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">None</span>);<br>&#125;<br><span class="hljs-comment">/// 使用宏简化声明 NativeMethod 对象</span><br><span class="hljs-comment">/// ## Examples</span><br><span class="hljs-comment">/// ```</span><br><span class="hljs-comment">/// let method:NativeMethod = jni_method!(native_method, &quot;(Ljava/lang/String;)V&quot;);</span><br><span class="hljs-comment">/// ```</span><br><span class="hljs-built_in">macro_rules!</span> jni_method &#123;<br>    ( $method:tt, $signature:expr ) =&gt; &#123;&#123;<br>        jni::NativeMethod &#123;<br>            name: jni::strings::JNIString::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-built_in">stringify!</span>($method)),<br>            sig: jni::strings::JNIString::<span class="hljs-title function_ invoke__">from</span>($signature),<br>            fn_ptr: $method <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> c_void,<br>        &#125;<br>    &#125;&#125;;<br>&#125;<br><span class="hljs-comment">/// 动态库被 java 加载时 会出发此函数, 在此动态注册本地方法</span><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-meta">#[allow(non_snake_case)]</span><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">JNI_OnLoad</span>(jvm: JavaVM, _reserved: *<span class="hljs-keyword">mut</span> c_void) <span class="hljs-punctuation">-&gt;</span> jint &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">class_name</span>: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;org/bfchain/rust/example/DenoService&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">jni_methods</span> = [<br>        <span class="hljs-comment">// # 添加注册一个可以传递java回调对象的本地方法</span><br>        jni_method!(nativeSetCallback, <span class="hljs-string">&quot;(Lorg/bfchain/rust/example/DenoService$IHandleCallback;)V&quot;</span>),<br>    ];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ok</span> = <span class="hljs-title function_ invoke__">register_natives</span>(&amp;jvm, class_name, jni_methods.<span class="hljs-title function_ invoke__">as_ref</span>());<br><br>    <span class="hljs-comment">// 在动态库被java加载时, 缓存一个jvm到全局变量, 调用回调时使用</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ptr_jvm</span> = JVM_GLOBAL.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    *ptr_jvm = <span class="hljs-title function_ invoke__">Some</span>(jvm);<br>    JNI_VERSION_1_4<br>&#125;<br><br><span class="hljs-comment">/// 方法实现</span><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">nativeSetCallback</span>(env: JNIEnv, _obj: JObject, callback: JObject) &#123;<br>    <span class="hljs-comment">// 创建一个全局引用,</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">callback</span> = env.<span class="hljs-title function_ invoke__">new_global_ref</span>(JObject::<span class="hljs-title function_ invoke__">from</span>(callback)).<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-comment">// 添加到全局缓存</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ptr_fn</span> = JNI_CALLBACK.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    *ptr_fn = <span class="hljs-title function_ invoke__">Some</span>(callback);<br>&#125;<br><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">register_natives</span>(jvm: &amp;JavaVM, class_name: &amp;<span class="hljs-type">str</span>, methods: &amp;[NativeMethod]) <span class="hljs-punctuation">-&gt;</span> jint &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">env</span>: JNIEnv = jvm.<span class="hljs-title function_ invoke__">get_env</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">jni_version</span> = env.<span class="hljs-title function_ invoke__">get_version</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">version</span>: jint = jni_version.<span class="hljs-title function_ invoke__">into</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">clazz</span> = <span class="hljs-keyword">match</span> env.<span class="hljs-title function_ invoke__">find_class</span>(class_name) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(clazz) =&gt; clazz,<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; &#123;<br>            error!(<span class="hljs-string">&quot;java class not found : &#123;:?&#125;&quot;</span>, e);<br>            <span class="hljs-keyword">return</span> JNI_ERR;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = env.<span class="hljs-title function_ invoke__">register_native_methods</span>(clazz, &amp;methods);<br><br>    <span class="hljs-keyword">if</span> result.<span class="hljs-title function_ invoke__">is_ok</span>() &#123;<br>        info!(<span class="hljs-string">&quot;register_natives : succeed&quot;</span>);<br>        version<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        error!(<span class="hljs-string">&quot;register_natives : failed &quot;</span>);<br>        JNI_ERR<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="JNI-OnLoad"><a href="#JNI-OnLoad" class="headerlink" title="JNI_OnLoad"></a>JNI_OnLoad</h4><p>这个函数在你加载so库的时候会自动调用，并不用在android里声明。他返回的是JNI版本，你需要选择你支持的版本。</p><blockquote><p>jni_method 的第二个参数是函数签名，如果你在android注册的函数不一样，需要自己修改函数签名。<br>如何查找函数的签名，直接google。</p></blockquote><h4 id="nativeSetCallback"><a href="#nativeSetCallback" class="headerlink" title="nativeSetCallback"></a>nativeSetCallback</h4><p><code> env.new_global_ref</code>是必须的，他可以帮助我们创建全局引用，我们的方法就可以跨方法跨线程调用，这里面的callback就是我们需要传递的闭包函数。</p><h3 id="回调函数入口"><a href="#回调函数入口" class="headerlink" title="回调函数入口"></a>回调函数入口</h3><p>下面的函数是利用闭包去执行上面缓存的<code>android</code>环境。<code>call_method</code>里的<code>handleCallback</code>函数，<br>我传递的参数是字符串，因此函数签名为<code>(Ljava/lang/String;)V</code>。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">/// 回调 Callback 对象的 &#123; void handleCallback(string: String) &#125; 函数</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_java_callback</span>(fun_type: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>) &#123;<br>        android_logger::<span class="hljs-title function_ invoke__">init_once</span>(<br>        Config::<span class="hljs-title function_ invoke__">default</span>()<br>            .<span class="hljs-title function_ invoke__">with_min_level</span>(Level::<span class="hljs-built_in">Debug</span>)<br>            .<span class="hljs-title function_ invoke__">with_tag</span>(<span class="hljs-string">&quot;myrust::handleCallback&quot;</span>),<br>    );<br>    log::info!(<span class="hljs-string">&quot;i am call_java_callback xxxxxxx1&#123;:?&#125;&quot;</span>,fun_type);<br>    <span class="hljs-title function_ invoke__">call_jvm</span>(&amp;JNI_CALLBACK, <span class="hljs-keyword">move</span> |obj: JObject, env: &amp;JNIEnv| &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(fun_type);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">response</span>: JString = env<br>            .<span class="hljs-title function_ invoke__">new_string</span>(fun_type)<br>            .<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Couldn&#x27;t create java string!&quot;</span>);<br>        <span class="hljs-keyword">match</span> env.<span class="hljs-title function_ invoke__">call_method</span>(<br>            obj,<br>            <span class="hljs-string">&quot;handleCallback&quot;</span>,<br>            <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>,<br>            &amp;[JValue::<span class="hljs-title function_ invoke__">from</span>(JObject::<span class="hljs-title function_ invoke__">from</span>(response))],<br>        ) &#123;<br>            <span class="hljs-title function_ invoke__">Ok</span>(jvalue) =&gt; &#123;<br>                debug!(<span class="hljs-string">&quot;callback succeed: &#123;:?&#125;&quot;</span>, jvalue);<br>            &#125;<br>            <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; &#123;<br>                error!(<span class="hljs-string">&quot;callback failed : &#123;:?&#125;&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br><span class="hljs-comment">/// # 封装jvm调用</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_jvm</span>&lt;F&gt;(callback: &amp;Mutex&lt;<span class="hljs-type">Option</span>&lt;GlobalRef&gt;&gt;, run: F)<br><span class="hljs-keyword">where</span><br>    F: <span class="hljs-title function_ invoke__">Fn</span>(JObject, &amp;JNIEnv) + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>,<br>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ptr_jvm</span> = JVM_GLOBAL.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">if</span> (*ptr_jvm).<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ptr_fn</span> = callback.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">if</span> (*ptr_fn).<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">jvm</span>: &amp;JavaVM = (*ptr_jvm).<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">match</span> jvm.<span class="hljs-title function_ invoke__">attach_current_thread_permanently</span>() &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(env) =&gt; &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">obj</span> = (*ptr_fn).<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">as_obj</span>();<br>            <span class="hljs-title function_ invoke__">run</span>(obj, &amp;env);<br>            <span class="hljs-comment">// 检查回调是否发生异常, 如果有异常发生,则打印并清空</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(<span class="hljs-literal">true</span>) = env.<span class="hljs-title function_ invoke__">exception_check</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = env.<span class="hljs-title function_ invoke__">exception_describe</span>();<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = env.<span class="hljs-title function_ invoke__">exception_clear</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; &#123;<br>            debug!(<span class="hljs-string">&quot;jvm attach_current_thread failed: &#123;:?&#125;&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>jni部分的函数已经写完了，接下来直接去调用<code>call_java_callback</code>函数就可以了。</p><h3 id="调用call-java-callback"><a href="#调用call-java-callback" class="headerlink" title="调用call_java_callback"></a>调用call_java_callback</h3><p><code>use crate::android::android_inter;</code>就是上面文件的位置。具体根据您项目位置导入。<br>下面的<code>fun_type</code>参数就是要传递给android的，以此来调用android函数。</p><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(target_os = <span class="hljs-string">&quot;android&quot;</span>)]</span><br><span class="hljs-keyword">use</span> crate::android::android_inter;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_android</span>(fun_type: &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">callback</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">leak</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(fun_type).<span class="hljs-title function_ invoke__">into_boxed_str</span>());<br>    <span class="hljs-meta">#[cfg(target_os = <span class="hljs-string">&quot;android&quot;</span>)]</span><br>    android_inter::<span class="hljs-title function_ invoke__">call_java_callback</span>(callback);<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p> Box::leak(String::from(fun_type).into_boxed_str()); 可以把&amp;str变量转化成静态&amp;’static str</p></blockquote><h3 id="结束🐟"><a href="#结束🐟" class="headerlink" title="结束🐟"></a>结束🐟</h3><p>如果此文章对您有帮助请发个表情告诉我，如果有其他建议或者勘误请直接留言。</p><p>垂杨拂绿水，摇艳东风年。<br>「折杨柳」<br>李白</p>]]></content>
    
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-3-21-区块链如何赋能实体经济</title>
    <link href="/2022/03/21/2022-3-21-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%A6%82%E4%BD%95%E8%B5%8B%E8%83%BD%E5%AE%9E%E4%BD%93%E7%BB%8F%E6%B5%8E/"/>
    <url>/2022/03/21/2022-3-21-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%A6%82%E4%BD%95%E8%B5%8B%E8%83%BD%E5%AE%9E%E4%BD%93%E7%BB%8F%E6%B5%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文章受大佬点拨，也算做入门区块链做的铺垫。区块链因为在前几年的p2p非法集资中，在国内一直饱受争议。<br>这篇文章就从合法合规的角度来进行切入。</p><h2 id="区块链合法吗？"><a href="#区块链合法吗？" class="headerlink" title="区块链合法吗？"></a>区块链合法吗？</h2><h3 id="传统的行业"><a href="#传统的行业" class="headerlink" title="传统的行业"></a>传统的行业</h3><p>大伙日常生活中，肯定或多或少办过会员卡（优惠券），比如健身房的会员卡，超市的储值卡。<br>我们将钱提前交给商户去换取未来的服务或者物品。这肯定是合法合规的。并且很多大型的国企也存在这样的服务。</p><h4 id="容易出现的问题"><a href="#容易出现的问题" class="headerlink" title="容易出现的问题"></a>容易出现的问题</h4><p>在传统的行业中，假如，商家在一段时间内促销了大量的会员卡，然后老板提前转移资产，申请破产。<br>这是无法避免的，因为说不定法人都不是老板本人，老板不用承担任何责任。这在健身行业体现得较多，我以前就遇到过。</p><h3 id="区块链锚定实物为合法行为"><a href="#区块链锚定实物为合法行为" class="headerlink" title="区块链锚定实物为合法行为"></a>区块链锚定实物为合法行为</h3><p>当区块链没有和任何实物绑定，没有提供锚定实物的功能，这条链肯定是不合法的，将构成发币炒币的行为。<br>而当整条链去锚定实物的时候，实体商品将规范整条链的波动和价值体系，不会出现如同比特币的断崖式下跌，<br>整条链的波动范围将维持基本的稳定范围。</p><p>并且在进行锚定实物的时候，做的动作跟办会员卡的性质是一样的。只不过传统的行业是跟商家主体去质押。<br>而区块链上，是跟程序去质押，并且在上链的时候，锚定多少价值的实物，就需要冻结相应的资产。<br>这将倒逼商家的诚信行为，因为商家的作恶代价是巨大的。</p><p>因此当区块链结合实体经济的时候，这条链将是合法的，这也符合国家工信部发布的<a href="https://www.miit.gov.cn/zwgk/zcjd/art/2021/art_30c7489e3b3447318188d074f9f81044.html">《关于加快推动区块链技术应用和产业发展的指导意见》</a>。</p><h2 id="如何赋能实体经济"><a href="#如何赋能实体经济" class="headerlink" title="如何赋能实体经济"></a>如何赋能实体经济</h2><p>接下来的目标，就是介绍如何赋能实体经济，如何节省企业的成本，降低企业的运营风险，如何为用户提供公平公正的服务。先来看一张图。</p><p><img src="/./energize.png" alt="思维导图"></p><p>在所有的实体经济中，资本的循环可以总结为以上4个关键节点。 你是老板拿出资金，购买原料，购买场地，聘请人员进行产品的生产。<br>如果生产的是硬性产品，还需要购买仓库场地费用。<br>生产完产品之后，要通过营销部门去营销（不论何种方式），有营销才能产生收入。<br>最关键的数据这一块，数据为你的企业前年生产的产品销售数据，作为老板的你，在你手底下的团队对一整年的数据进行汇总整理后将数据摆到你面前。<br>你需要做出关键的决策，预定今年的生产目标，来将整个资金盘活，让企业获得更多的收益，让企业降低更多的资金盘风险。<br>一旦出现决策失误，作为最高决策的你，将掏钱承受损失。</p><blockquote><p>硬性：指实体行业。 软性：指服务行业。<br>B: 指二级分销商，或者代理商  G: 指政府监管部门  C: 指用户</p></blockquote><h3 id="传统行业的问题"><a href="#传统行业的问题" class="headerlink" title="传统行业的问题"></a>传统行业的问题</h3><h4 id="问题1：整体数据难收集，且难保证是否有伪造。"><a href="#问题1：整体数据难收集，且难保证是否有伪造。" class="headerlink" title="问题1：整体数据难收集，且难保证是否有伪造。"></a>问题1：整体数据难收集，且难保证是否有伪造。</h4><p>在传统行业中，数据是由线下的各个门店，或者代理商产生的，线上是由第三方公司提供的服务或者自己公司提供的服务产生的。<br>数据都需要从C经过1到多层的B,最终才能到达公司。<br>整体的营销数据在线下需要经过好几手的传达，最终才能到达你老板的面前，且不说是否造假和收集困难，数据的正确性就值得考证。<br>线上的数据相对直观，但是你得一年向第三方支付多少钱？并且刷单造假体现出整体的贩卖形式大好，也是容易做到的。</p><p>并且大公司请的大数据分析决策团队，一年也是要几千万的，小公司根本是不可能使用这样的技术的。</p><h4 id="问题2-维权打假难"><a href="#问题2-维权打假难" class="headerlink" title="问题2: 维权打假难"></a>问题2: 维权打假难</h4><p>假如：你现在是一名消费者，买到假货了，要跑去维权。我们来看看你需要做哪些动作：</p><ol><li>证明这个是假货</li><li>证明这个假货是这家公司的产品</li><li>证明这家供货商从这家公司进货。</li><li>拿着证据去政府部门维权。</li><li>政府部门去到门店帮忙维权。</li></ol><p>是不是看着就头大，这就是维权难，如果是十几块钱，几百块钱的是不是选择不了了之。贵的物品是不是你需要付不少的鉴定费和大量的时间？</p><p>并且，在传统行业中造假将会使公司的整体形象受损，进而影响整个公司的品牌，进一步打击整个营销效果。</p><h4 id="问题3-溯源难"><a href="#问题3-溯源难" class="headerlink" title="问题3: 溯源难"></a>问题3: 溯源难</h4><p>假如现在有一个消费者，拿着假货来公司，说这个假货是你们生产的要求赔钱，你看上面的制造商和logo都是你们公司的。你该怎么办？</p><h3 id="区块链技术如何赋能"><a href="#区块链技术如何赋能" class="headerlink" title="区块链技术如何赋能"></a>区块链技术如何赋能</h3><p>简单来说，如何运用区块链技术，为企业谋取更多的利益。</p><h4 id="用户和公司点对点交易"><a href="#用户和公司点对点交易" class="headerlink" title="用户和公司点对点交易"></a>用户和公司点对点交易</h4><p>在区块链当中，用户的交易是直接和公司产生的，并且直接到达公司，并不会产生需要货款月结的情况。<br>第一，由于区块链的不可篡改性，保证了整个交易的数据准确度。<br>第二，数据和资金直接一手直接到达账户，并不会跟传统产业一样，需要经过<strong>层层剥削</strong>。极大的增加了企业的资金收入。</p><h4 id="数据预测分析得到保证"><a href="#数据预测分析得到保证" class="headerlink" title="数据预测分析得到保证"></a>数据预测分析得到保证</h4><p>当公司的数据准确无误的呈现到面前的时候，对整个的生产预测将是极大的正反馈，当有正确的数据的时候，<br>你就知道应该生产什么，让整个仓库的存货压倒最低，甚至没有，极大的盘活资金盘。<br>并且，你能直观的看到哪款货物买得最好，营销将如何进行调整。这将极大的增加整个企业的效率，为企业将本增收。</p><h4 id="用预售的方式与用户共赢"><a href="#用预售的方式与用户共赢" class="headerlink" title="用预售的方式与用户共赢"></a>用预售的方式与用户共赢</h4><p>区块链的运作系统，C端和B端的界限将会变得模糊。公司可以采用预售的方式，提前售卖一些货品（上链必质押），<br>让用户去购买，最大化的减少库存堆积，并且让利给用户，比如价格的70%。然后一个月半个月后交货。<br>这样可以大大减少企业资金的风险。而在这个环节，原来的B端用户或者团体，就可以承担运输的角色，囤一些物品，并且由于所生产的物品都具有唯一性的特点，增值空间或者个人使用都是非常合适的。</p><h4 id="打假简单"><a href="#打假简单" class="headerlink" title="打假简单"></a>打假简单</h4><p>在区块链系统中，当出现假冒产品只有两种可能，第三方假冒的，公司本身造假。这依据区块链的溯源技术是可以直接得到结果的。<br>而现在政府部门，只需要出面发布公告，某某公司或团体生产假冒伪劣产品，极大的增加了整个监管部门的效率，使整个监管部门真正的为民服务，真正的办实事。</p><h3 id="结束🐟"><a href="#结束🐟" class="headerlink" title="结束🐟"></a>结束🐟</h3><p>此文章仅代表本人观点，如果有更好的想法，请留言。</p><p>江南几度梅花发，人在天涯鬓已斑。<br>「鹧鸪天·雪照山城玉指寒」<br>刘著</p>]]></content>
    
    
    
    <tags>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年度总结</title>
    <link href="/2021/12/31/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <url>/2021/12/31/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="2021-年度总结"><a href="#2021-年度总结" class="headerlink" title="2021 年度总结"></a>2021 年度总结</h2><p>今天是 2021 年 12 月 31 号，我已经忘记自己几岁了，反正也老大不小了，两个从小玩到大的朋友已经在今年结婚了。突然就感觉自己跟这个世界格格不入了。</p><blockquote><p>每年例行写年终，给老了留下点念想。接下来都是碎碎念。</p></blockquote><blockquote><p>你爱我，我爱你，蜜雪冰城甜蜜蜜。 – 2021</p></blockquote><h3 id="今年做了什么"><a href="#今年做了什么" class="headerlink" title="今年做了什么"></a>今年做了什么</h3><p>今年都在备考，感觉都没做啥事，今年就过去了，代码也放了好久，就只剩数据结构，计算机组成原理，操作系统，计算机网络（408）。总的来说，等于打基础了。还是有很多不会的，还需要好好学习。<br>数学没考好，对不起宇哥。已经考完了，考不上考得上已经不重要了，肖四压没压中也已经不重要了。今年整天呆在家，已经逐渐的不愿意出门了。走一步看一步了，没进复试就找个工作继续考。生活还是要积极向上的。</p><p><img src="/bilibili.JPG"></p><p>今年开始学硬件了，学习了画电路板，昨天焊了人生第一块电路板，我在焊接电阻的时候，焊得注意力太集中了，表演了一波手抓电烙铁，我可怜的小手 2333。难受。这次入手的是<a href="https://space.bilibili.com/20259914/">稚晖君</a>的透明小电视，而且网上教程多，比较适合新手入门。</p><blockquote><p>下图为群内大佬改良版。<br><img src="/PCD.png" alt="pcd"></p></blockquote><p>2021 是元宇宙元年，感觉就是谈资本割韭菜，谈技术有未来的东西。感觉这就是 web3 了。我也去玩了一下元宇宙的游戏,就是以前的网游然后加上 NFT,一块地卖那么多以太坊，实在是资本陷阱，不过数字资产倒是好东西，NFT 跟现实接轨，有那味了。如果剑网 3 也搞一搞，说不定起飞了。<br><img src="/meta.PNG" alt="meta"></p><h3 id="祝你天天开心"><a href="#祝你天天开心" class="headerlink" title="祝你天天开心"></a>祝你天天开心</h3><p>我今年没有啥实质性的进展，而且增加了很多焦虑。希望明年能更好一点。也祝读到这里的你心想事成。不说了，没内容了，焊电路板去了。<br><img src="/nn.JPG" alt="nn"></p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>霜落荆门江树空，布帆无恙挂秋风。<br>「秋下荆门」<br>李白</p>]]></content>
    
    
    
    <tags>
      
      <tag>年度总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决阿里云与公网的其他机器部署Kubernetes问题</title>
    <link href="/2021/03/31/%E8%A7%A3%E5%86%B3%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8E%E5%85%AC%E7%BD%91%E7%9A%84%E5%85%B6%E4%BB%96%E6%9C%BA%E5%99%A8%E9%83%A8%E7%BD%B2Kubernetes%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/31/%E8%A7%A3%E5%86%B3%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8E%E5%85%AC%E7%BD%91%E7%9A%84%E5%85%B6%E4%BB%96%E6%9C%BA%E5%99%A8%E9%83%A8%E7%BD%B2Kubernetes%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于阿里云的公网 ip 绑定的网卡在外层网关，所以机器地监听不到</p><h3 id="基本环境得安装"><a href="#基本环境得安装" class="headerlink" title="基本环境得安装"></a>基本环境得安装</h3><h4 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian &#x2F; Ubuntu"></a>Debian &#x2F; Ubuntu</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">apt-get update &amp;&amp; apt-get install -y apt-transport-https<br>curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -<br>cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list<br>deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main<br>EOF<br>apt-get update<br>apt-get install -y kubelet kubeadm kubectl<br></code></pre></div></td></tr></table></figure><blockquote><p>另外，你也可以指定版本安装<br>apt-get install kubectl&#x3D;1.19.3-00 kubelet&#x3D;1.19.3-00 kubeadm&#x3D;1.19.3-00</p></blockquote><h4 id="CentOS-RHEL-Fedora"><a href="#CentOS-RHEL-Fedora" class="headerlink" title="CentOS &#x2F; RHEL &#x2F; Fedora"></a>CentOS &#x2F; RHEL &#x2F; Fedora</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo<br>[kubernetes]<br>name=Kubernetes<br>baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/<br>enabled=1<br>gpgcheck=1<br>repo_gpgcheck=1<br>gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg<br>EOF<br>setenforce 0<br>yum install -y kubelet kubeadm kubectl<br>systemctl enable kubelet &amp;&amp; systemctl start kubelet<br></code></pre></div></td></tr></table></figure><h2 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h2><p><strong>_ 下面代码除特殊说明的 x.x.x.x 都是您的 master 节点公网地址 _</strong></p><h3 id="构建-etcd"><a href="#构建-etcd" class="headerlink" title="构建 etcd"></a>构建 etcd</h3><p>k8s 1.8 版本后，允许分段构建，所以我们要先构建一下 etcd phase。执行下面代码</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">kubeadm init phase etcd local<br></code></pre></div></td></tr></table></figure><p>您需要<strong>打开两个终端</strong>，一个执行 <code>kubeadm init ...</code> 也就是下面创建集群的代码,此时会卡住。<br>另一个需要修改<code>etcd.yaml</code>里面的<code>listen-client-urls</code>和<code>listen-peer-urls</code>，具体看下面代码，</p><h3 id="第一个终端创建集群"><a href="#第一个终端创建集群" class="headerlink" title="第一个终端创建集群"></a>第一个终端创建集群</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">kubeadm init --image-repository=registry.aliyuncs.com/google_containers --apiserver-advertise-address=x.x.x.x --service-cidr=10.1.0.0/16  --pod-network-cidr=10.244.0.0/16<br></code></pre></div></td></tr></table></figure><p>执行完第一个窗口会卡住，接着切换 master 的到第二个终端，执行下面代码。</p><h3 id="第二个终端修改-etcd-监听地址"><a href="#第二个终端修改-etcd-监听地址" class="headerlink" title="第二个终端修改 etcd 监听地址"></a>第二个终端修改 etcd 监听地址</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">第二个终端执行</span><br>vim /etc/kubernetes/manifests/etcd.yaml<br></code></pre></div></td></tr></table></figure><h4 id="第二个终端原来的内容："><a href="#第二个终端原来的内容：" class="headerlink" title="第二个终端原来的内容："></a>第二个终端原来的内容：</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">······ more</span><br>  - --client-cert-auth=true<br>    - --data-dir=/var/lib/etcd<br>    - --initial-advertise-peer-urls=https://x.x.x.x:2380<br>    - --initial-cluster=master=https://x.x.x.x:2380<br>    - --key-file=/etc/kubernetes/pki/etcd/server.key<br>    - --listen-client-urls=https://127.0.0.1:2379,https://x.x.x.x:2379<br>    - --listen-metrics-urls=http://127.0.0.1:2381<br>    - --listen-peer-urls=https://x.x.x.x:2380<br>    - --name=master<br><span class="hljs-meta prompt_">#</span><span class="language-bash">······ more</span><br></code></pre></div></td></tr></table></figure><h4 id="第二个终端修改后的内容："><a href="#第二个终端修改后的内容：" class="headerlink" title="第二个终端修改后的内容："></a>第二个终端修改后的内容：</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">······ more</span><br>  - --client-cert-auth=true<br>    - --data-dir=/var/lib/etcd<br>    - --initial-advertise-peer-urls=https://x.x.x.x:2380<br>    - --initial-cluster=master=https://x.x.x.x:2380<br>    - --key-file=/etc/kubernetes/pki/etcd/server.key<br>    - --listen-client-urls=https://127.0.0.1:2379<br>    - --listen-metrics-urls=http://127.0.0.1:2381<br>    - --listen-peer-urls=https://127.0.0.1:2380<br>    - --name=master<br><span class="hljs-meta prompt_">#</span><span class="language-bash">······  more</span><br></code></pre></div></td></tr></table></figure><p>稍等一会，第一个窗口 <code>kubeadm init ...</code>就执行成功了。</p><h3 id="执行成功，终端会提醒我们执行下面命令"><a href="#执行成功，终端会提醒我们执行下面命令" class="headerlink" title="执行成功，终端会提醒我们执行下面命令"></a>执行成功，终端会提醒我们执行下面命令</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">mkdir -p $HOME/.kube<br>sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br>sudo chown $(id -u):$(id -g) $HOME/.kube/config<br></code></pre></div></td></tr></table></figure><h4 id="将-worker-加入集群"><a href="#将-worker-加入集群" class="headerlink" title="将 worker 加入集群"></a>将 worker 加入集群</h4><p>接着在 worker 节点 执行 <code>kubeadm join</code> 的代码， token 有效期默认 2 小时。</p><h3 id="查看加入的节点"><a href="#查看加入的节点" class="headerlink" title="查看加入的节点"></a>查看加入的节点</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">kubectl get ndoes<br></code></pre></div></td></tr></table></figure><p>会查看到 master 节点和 node 节点都是 NotReady 状态。</p><h3 id="接着就需要安装网络环境"><a href="#接着就需要安装网络环境" class="headerlink" title="接着就需要安装网络环境"></a>接着就需要安装网络环境</h3><h4 id="在-master-节点和-node-节点都安装-flannel-插件"><a href="#在-master-节点和-node-节点都安装-flannel-插件" class="headerlink" title="在 master 节点和 node 节点都安装 flannel 插件"></a>在 master 节点和 node 节点都安装 flannel 插件</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml<br></code></pre></div></td></tr></table></figure><h2 id="如果遇到错误就看日志"><a href="#如果遇到错误就看日志" class="headerlink" title="如果遇到错误就看日志"></a>如果遇到错误就看日志</h2><h3 id="执行下面命令看看是否都处于-runing-状态"><a href="#执行下面命令看看是否都处于-runing-状态" class="headerlink" title="执行下面命令看看是否都处于 runing 状态"></a>执行下面命令看看是否都处于 runing 状态</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">kubectl get pods --all-namespaces<br></code></pre></div></td></tr></table></figure><p>看 kubelet</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">journalctl -f -u kubelet<br></code></pre></div></td></tr></table></figure><h3 id="pod-一直-CrashLoopBackOff"><a href="#pod-一直-CrashLoopBackOff" class="headerlink" title="pod 一直 CrashLoopBackOff"></a>pod 一直 CrashLoopBackOff</h3><p>看看 log 对症下药</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">kubectl logs pod-name<br></code></pre></div></td></tr></table></figure><p>看看是不是有缺少什么东西，如果缺少了就从 master 节点复制,如：</p><h3 id="The-connection-to-the-server-localhost-8080-was-refused-did-you-specify-the-right-host-or-port"><a href="#The-connection-to-the-server-localhost-8080-was-refused-did-you-specify-the-right-host-or-port" class="headerlink" title="The connection to the server localhost:8080 was refused - did you specify the right host or port?"></a>The connection to the server localhost:8080 was refused - did you specify the right host or port?</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这命令在 master 节点执行，x.x.x.x为你报错的节点的公网ip</span><br>scp /etc/docker/daemon.json root@x.x.x.x:/etc/docker/daemon.json<br></code></pre></div></td></tr></table></figure><p>或者前往 对于的<a href="https://github.com/kubernetes/kubernetes/issues/50295">github issuse</a></p><h3 id="failed-open-run-systemd-resolve-resolv-conf-no-such-file-or-directory"><a href="#failed-open-run-systemd-resolve-resolv-conf-no-such-file-or-directory" class="headerlink" title="failed: open &#x2F;run&#x2F;systemd&#x2F;resolve&#x2F;resolv.conf: no such file or directory"></a>failed: open &#x2F;run&#x2F;systemd&#x2F;resolve&#x2F;resolv.conf: no such file or directory</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 复制master的文件</span></span><br>scp /run/systemd/resolve/resolv.conf root@x.x.x.x:/run/systemd/resolve/resolv.conf<br>systemctl daemon-reload<br></code></pre></div></td></tr></table></figure><h3 id="sys-fs-cgroup-pids-system-slice-etcd-service-no-such-file-or-directory"><a href="#sys-fs-cgroup-pids-system-slice-etcd-service-no-such-file-or-directory" class="headerlink" title="&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;pids&#x2F;system.slice&#x2F;etcd.service: no such file or directory"></a>&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;pids&#x2F;system.slice&#x2F;etcd.service: no such file or directory</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"> vim /etc/docker/daemon.json<br>vim /run/flannel/subnet.env<br></code></pre></div></td></tr></table></figure><h3 id="network-plugin-is-not-ready-cni-config-uninitialized"><a href="#network-plugin-is-not-ready-cni-config-uninitialized" class="headerlink" title="network plugin is not ready: cni config uninitialized"></a>network plugin is not ready: cni config uninitialized</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">vim /etc/cni/net.d/10-flannel.conflist<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#输入下面内容</span></span><br>&#123;<br>  &quot;name&quot;: &quot;cbr0&quot;,<br>  &quot;cniVersion&quot;: &quot;0.3.1&quot;,<br>  &quot;plugins&quot;: [<br>    &#123;<br>      &quot;type&quot;: &quot;flannel&quot;,<br>      &quot;delegate&quot;: &#123;<br>        &quot;hairpinMode&quot;: true,<br>        &quot;isDefaultGateway&quot;: true<br>      &#125;<br>    &#125;,<br>    &#123;<br>      &quot;type&quot;: &quot;portmap&quot;,<br>      &quot;capabilities&quot;: &#123;<br>        &quot;portMappings&quot;: true<br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="network-run-flannel-subnet-env-is-missing-FLANNEL-NETWORK"><a href="#network-run-flannel-subnet-env-is-missing-FLANNEL-NETWORK" class="headerlink" title="network: &#x2F;run&#x2F;flannel&#x2F;subnet.env is missing FLANNEL_NETWORK"></a>network: &#x2F;run&#x2F;flannel&#x2F;subnet.env is missing FLANNEL_NETWORK</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml<br>kubectl get pods --all-namespaces<br></code></pre></div></td></tr></table></figure><blockquote><p>排错技巧，<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/">kubeadm 进行故障排查</a>， <a href="https://www.jianshu.com/p/2ded3a8cc788">Kubernetes 常用命令</a>.</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年度总结</title>
    <link href="/2020/12/31/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/31/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="2020-写给自己的年度总结"><a href="#2020-写给自己的年度总结" class="headerlink" title="2020 写给自己的年度总结"></a>2020 写给自己的年度总结</h2><p>嘿嘿先来欣赏一下百万剪辑狮的<a href="https://www.bilibili.com/video/BV1si4y1w7UN?spm_id_from=333.851.b_7265706f7274466972737431.11">年度总结</a>, 看看一下电影一样的 2020。希望给未来留下一点回忆。</p><h3 id="年度关键词"><a href="#年度关键词" class="headerlink" title="年度关键词"></a>年度关键词</h3><p>【<strong>变化</strong>】 这是我的年度关键词，今年大四了，同届的都出去实习的实习，考研的考研。工作室显得意外的冷清。<br>我是最后一个出去实习的一直在投简历，但是以我这个本科的学校，大公司一看双非，直接 pass。</p><p>7 月份的时候，整天找工作，但是感觉都不如意。最后在 8 月份的时候，入职了一家小企业。然后在今年的 12 月份离职了。</p><p>入职的原因： 为了完成学校大四的实习任务。</p><p>离职的原因：</p><ol><li>准备脱产考研，我考虑了非常久。</li><li>大公司看不上我这种学历的，小公司学不到东西。</li></ol><h3 id="开始有自己盈利的产品"><a href="#开始有自己盈利的产品" class="headerlink" title="开始有自己盈利的产品"></a>开始有自己盈利的产品</h3><!-- 今年因为周老哥的介绍，认识了匠，并有幸和他一起合作做自己的产品。这是个很厉害的 大厂 JAVA后端，因此每个月都能有额外的收入。最不好意思的是，每次我准备发布新版本，然后提交测试。我每次都以为没问题了，但总是又出现一些大小不一的问题。非常尴尬。听说大厂会把每个人产出的bug记到小本本上，然后年终的时候评个奖。 --><p>从三月份做到十二月学习到很多，细节处理，用户体验，产品思考。这些都是汇聚成大海的涓涓细流。今后也将不断继续尝试，将技术变成金钱。</p><h3 id="今年学习进度"><a href="#今年学习进度" class="headerlink" title="今年学习进度"></a>今年学习进度</h3><p>今年开始在<a href="https://leetcode-cn.com/">LeetCode</a>上有意识的去刷题了，每日一题总是必刷，但是如果超过 30 分钟没有解出来直接看答案理解，经典题和不会的再进一步进行收藏。跟着笨猪爆破组(原名天使爆破组)，正月点灯笼，labuladong 等几位大佬学到了挺多东西。</p><p><img src="/./leetcode.jpeg" alt="leetCode"></p><h4 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h4><p>今年对 ai 领域进行了学习，主要使用的就是 tensorflow.js 和 他的 node 版本。主要是使用他的对象识别模型，来提供服务。</p><!-- 我目前开放了一个IBM的对象识别接口，部署在kubernetes上，供大家免费测试。 --><!-- ```bashcurl -F " image=student.JPG" -XPOST https://object.waterbang.top/model/predict``` --><p>云服务与机器学习我认为是不分家的，云服务确实是软件的基石。</p><h4 id="毕业设计"><a href="#毕业设计" class="headerlink" title="毕业设计"></a>毕业设计</h4><p>今年的毕业设计也是基于此模型。是一个叫导盲犬的小程序，现在并不完善，并且有很多问题要求探究和解决。这个小程序的最终目的是：「为制作一个可以为盲人充当眼睛的眼睛，提供可行性方案」，如果我在我年迈时，近视到看不见了，我希望他能成为我的眼睛。现在测试版直接微信小程序搜索「导盲犬」。</p><h4 id="前端技术"><a href="#前端技术" class="headerlink" title="前端技术"></a>前端技术</h4><p>今年的前端技术持续深耕，vue3.0 出来的，感觉 Composition API 的写法更适合我，搭配着 TS 也是直接搞起来了。但是 element-plus 还有许多的 bug，但是我也是直接冲了，就是莽，实在不行就提 <code>pull request</code>。</p><h3 id="今年读的书"><a href="#今年读的书" class="headerlink" title="今年读的书"></a>今年读的书</h3><p>《node.js 狼书卷二》: 这本书跟一不一样，卷一偏重源码和理论讲解。卷二偏重实战运用，也是重点讲解了 koa2.</p><p>《kubernetes 实战指南》: 这本书讲得挺好，但是由于知识原因，第二章较为枯燥，但又是不可或缺的，建议可以先看后面的实战，再返回读一遍，理解会更深刻。</p><p>《红宝书第 4 版》：js 参考答案。</p><p>《python 机器学习入门指南》：说实话，还没拆封哈哈哈。</p><p>《西瓜书 🍉》：周志华教授的西瓜书，我感觉，我对 ai 一直都没真正入门，还差一个敲门砖，我觉得就是它。建议搭配<a href="https://www.bilibili.com/video/BV17J411C7zZ?t=107">机器学习白话讲解</a>，事半功倍。</p><p>《程序挑战设计 2》：从韩老哥那里拿的，用 C 讲解了算法非常全。</p><h4 id="小测"><a href="#小测" class="headerlink" title="小测"></a>小测</h4><ol><li>由浅入深吃透 Docker</li><li>深度学习入门与实战</li><li>web 安全攻防之道</li><li>打造千万级流量秒杀系统</li><li>前端基础建设与架构 30 讲</li><li>DevOps 落地笔记</li><li>DDD 微服务落地实战</li><li>软件架构场景 22 讲</li><li>Vue.js 3.0 核心源码解析</li><li>Kubernetes 原理剖析与实战应用</li><li>300 分钟搞定数据结构与算法</li></ol><p>以上小测都不错，适合通勤观看，如果需要可以留言，我都是一块钱买的哈哈哈，现在免费提供给大家学习。</p><h3 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h3><p>2021 脱产考研了，我还年轻需要去拼一拼，我这个人一天不学习就感觉非常愧疚闲不住，祝我一战成硕。<br><img src="/student.JPG" alt="xuexu"></p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>老来可惯通宵饮，待不眠、还怕寒侵。<br>「高阳台·除夜」<br>韩疁</p>]]></content>
    
    
    
    <tags>
      
      <tag>年度总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序使用组件实现tarBar隐藏显示</title>
    <link href="/2020/10/28/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0tarBar%E9%9A%90%E8%97%8F%E6%98%BE%E7%A4%BA/"/>
    <url>/2020/10/28/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0tarBar%E9%9A%90%E8%97%8F%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇文章解决场景：</p><p><strong>您的小程序有个需求，就是切换tarBar的时候实现隐藏。如果您使用过中转页面实现跳转，会在安卓机上发现有明显的白屏。</strong></p><blockquote><p>以下代码可直接复制粘贴，只需要将tarbar数据换成自己的</p></blockquote><p><img src="/./gif.gif" alt="gif"></p><h3 id="配置自定义tarbar"><a href="#配置自定义tarbar" class="headerlink" title="配置自定义tarbar"></a>配置自定义tarbar</h3><p>在项目的app.json，的tarBar对象内添加配置：<code>custom:true</code>，代码如下：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">.....<br><span class="hljs-attr">&quot;tabBar&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;custom&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// +++</span><br>    <span class="hljs-attr">&quot;backgroundColor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#fafafa&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;borderStyle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;white&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;selectedColor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#e14739&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;color&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#404040&quot;</span><span class="hljs-punctuation">,</span><br>.....<br></code></pre></div></td></tr></table></figure><h3 id="创建custom-tar-bar组件"><a href="#创建custom-tar-bar组件" class="headerlink" title="创建custom-tar-bar组件"></a>创建custom-tar-bar组件</h3><p>创建结构如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">compoment<br>├── custom-tab-bar<br>│   ├── <span class="hljs-keyword">index</span>.js<br>│   ├── <span class="hljs-keyword">index</span>.json<br>│   ├── <span class="hljs-keyword">index</span>.wxml<br>│   └── <span class="hljs-keyword">index</span>.wxss<br></code></pre></div></td></tr></table></figure><h4 id="wxml"><a href="#wxml" class="headerlink" title="wxml"></a>wxml</h4><p>编辑wxml页面，代码如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">cover-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tab-bar&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">cover-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tab-bar-border&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cover-view</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">cover-view</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">list</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tab-bar-item&quot;</span> <span class="hljs-attr">data-path</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.pagePath</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">index</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;switchTab&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">cover-image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">_index</span> === index ? item.selectedIconPath : item.iconPath&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cover-image</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">cover-view</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: </span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">_index</span> === index ? selectedColor : color&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.text</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">cover-view</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">cover-view</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">cover-view</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><h4 id="wxss"><a href="#wxss" class="headerlink" title="wxss"></a>wxss</h4><p>样式代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs wxss">.tab-bar &#123;<br>  position: fixed;<br>  bottom: 0;<br>  left: 0;<br>  right: 0;<br>  height: 48px;<br>  background: white;<br>  display: flex;<br>  padding-bottom: env(safe-area-inset-bottom);<br>&#125;<br><br>.tab-bar-border &#123;<br>  background-color: rgba(0, 0, 0, 0.33);<br>  position: absolute;<br>  left: 0;<br>  top: 0;<br>  width: 100%;<br>  height: 1px;<br>  transform: scaleY(0.5);<br>&#125;<br><br>.tab-bar-item &#123;<br>  flex: 1;<br>  text-align: center;<br>  display: flex;<br>  justify-content: center;<br>  align-items: center;<br>  flex-direction: column;<br>&#125;<br><br>.tab-bar-item cover-image &#123;<br>  width: 27px;<br>  height: 27px;<br>&#125;<br><br>.tab-bar-item cover-view &#123;<br>  font-size: 10px;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><p>json页面不用动，代码如下：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;component&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;usingComponents&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></div></td></tr></table></figure><h4 id="js页面"><a href="#js页面" class="headerlink" title="js页面"></a>js页面</h4><p>js页面需要注意一下，因为我们要实现隐藏页面，所以我们需要创建个空页面来当我们要实际跳转页面的替身（替身稻草人）。<br>并且，在我们点击跳转的时候，会触发<code>switchTab()</code>函数，我们在函数中拦截一下这个跳转，让他跳转到我们真正要去的页面。</p><blockquote><p>data里面的数据，就是你app.json里，tarbar的数据</p></blockquote><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">Component</span>(&#123;<br>  <span class="hljs-attr">properties</span>: &#123;<br>    <span class="hljs-attr">_index</span>: Number<br>  &#125;,<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;#7A7E83&quot;</span>,<br>    <span class="hljs-attr">selectedColor</span>: <span class="hljs-string">&quot;#666666&quot;</span>,<br>    <span class="hljs-attr">list</span>: [<br>      &#123;<br>        <span class="hljs-attr">pagePath</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-attr">iconPath</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-attr">selectedIconPath</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;首页&quot;</span>,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">pagePath</span>: <span class="hljs-string">&quot;/pages/yinchang/index/index&quot;</span>, // 实际上不会跳这个页面<br>        <span class="hljs-attr">iconPath</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-attr">selectedIconPath</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;需要隐藏的页面&quot;</span>,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">pagePath</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-attr">iconPath</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-attr">selectedIconPath</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;我的&quot;</span>,<br>      &#125;<br>    ]<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_ invoke__">switchTab</span>(e) &#123;<br>      <span class="hljs-keyword">const</span> data = e.currentTarget.dataset<br>      <span class="hljs-keyword">const</span> url = data.path<br>      <span class="hljs-keyword">if</span> (data.index === <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 拦截跳转</span><br>        wx.<span class="hljs-title function_ invoke__">navigateTo</span>(&#123;<br>          <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/pages/create/create&#x27;</span>, // 实际上跳转的页面，并且能返回<br>        &#125;)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        wx.<span class="hljs-title function_ invoke__">switchTab</span>(&#123;url&#125;)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br><br></code></pre></div></td></tr></table></figure><p>到此组件创建完毕</p><h3 id="引入页面"><a href="#引入页面" class="headerlink" title="引入页面"></a>引入页面</h3><p>在您需要显示的页面，引入上面创建的组件，举例一个home页面.</p><h4 id="json引入"><a href="#json引入" class="headerlink" title="json引入"></a>json引入</h4><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;navigationBarTitleText&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;首页&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;usingComponents&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;custom-tab-bar&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/compoment/custom-tab-bar/index&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></div></td></tr></table></figure><h4 id="wxml使用"><a href="#wxml使用" class="headerlink" title="wxml使用"></a>wxml使用</h4><p>由于我们首页的索引是0，所以给组件传0，避免点击效果渲染错误。（举一反三）</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">&lt;custom-<span class="hljs-built_in">tab</span>-<span class="hljs-built_in">bar</span> _index=<span class="hljs-string">&quot;0&quot;</span>&gt;&lt;/custom-<span class="hljs-built_in">tab</span>-<span class="hljs-built_in">bar</span>&gt;<br></code></pre></div></td></tr></table></figure><p>到此功能就结束了，希望有快速解决您的需要。<br>如果有其他问题请留言，我会继续补充。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>但年年燕子，晚烟斜日。<br>「满江红·金陵乌衣园」<br>吴潜</p>]]></content>
    
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础机器学习:使用CNN的手写数字识别</title>
    <link href="/2020/06/10/%E5%9F%BA%E7%A1%80%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%BD%BF%E7%94%A8CNN%E7%9A%84%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <url>/2020/06/10/%E5%9F%BA%E7%A1%80%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%BD%BF%E7%94%A8CNN%E7%9A%84%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本章将基于<a href="https://www.tensorflow.org/js/">TensorFlow.js</a>模型，使用卷积神经网络识别手写数字。<br>使用的打包工具是<a href="https://parceljs.org/getting_started.html">parcel</a>。<br>这个手写数字是机器学习领域的HelloWorld,我们将会创建一个浏览器的网页来承载我们的模型。<br>这个模型将会学习大量的示例，和正确的输出结果，来训练模型。这被称为<a href="https://developers.google.cn/machine-learning/problem-framing/cases">监督学习</a>。</p><h4 id="训练集介绍"><a href="#训练集介绍" class="headerlink" title="训练集介绍"></a>训练集介绍</h4><p>训练集是著名的<a href="http://yann.lecun.com/exdb/mnist/">MNIST</a>,（需要翻墙），图像是黑白两色，大小为28×28像素。<br>Google的开发人员已经帮我们将这些大量的图片数据，变成了一张雪碧图，并且给了我们一个加载这些数据的<code>data.js</code>。这样我们就可以专注于训练的部分。</p><p><img src="/./allData.png" alt="allData"></p><p>总共有65,000张图像，资源链接如下：（链接失效评论区留言）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1BuaB5mMCWYKHCpy3rMxIsg">https://pan.baidu.com/s/1BuaB5mMCWYKHCpy3rMxIsg</a><br> 提取码：gec2</p></blockquote><h4 id="data-js介绍"><a href="#data-js介绍" class="headerlink" title="data.js介绍"></a>data.js介绍</h4><p>提供的代码包含一个<code>MnistData</code>具有两个公共方法的类：</p><p>nextTrainBatch(batchSize)：从训练集中返回随机的一批图像及其标签。<br>nextTestBatch(batchSize)：从测试集中返回一批图像及其标签。<br><code>MnistData</code>类还执行重排和规范化数据的重要步骤。</p><h2 id="开始编码"><a href="#开始编码" class="headerlink" title="开始编码"></a>开始编码</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>在您的工作目录下创建<code>mnist</code>文件夹，和<code>data</code>文件夹，前者是我们的工作目录，后者要起个静态资源服务，以便我们的data.js加载。<br>在<code>mnist</code>文件夹下创建index.html,和index.js,并且把上面下载的data.js放进去。<br>在<code>data</code>文件夹下放上面下载的<code>mnist_images.png</code>和<code>mnist_labels_uint8</code>两个文件。</p><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>本次将用到<code>@tensorflow/tfjs</code>,<code>@tensorflow/tfjs-vis</code>,<code>http-server</code>,<code>parcel</code>这些包，运行下列命令进行安装。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">npm i @tensorflow/tfjs @tensorflow/tfjs-vis --save<br>npm i -g parcel-bundler http-server<br></code></pre></div></td></tr></table></figure><p>工作结束后您的目录应该像这样</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">|-node_modules<br>|-data<br>    |-mnist_images.png<br>    |-mnist_labels_uint8<br>|-mnist<br>    |--data.js<br>    |--index.html<br>    |--index.js<br>|-package.json<br>|-package-lock.json<br></code></pre></div></td></tr></table></figure><h3 id="启动静态服务器"><a href="#启动静态服务器" class="headerlink" title="启动静态服务器"></a>启动静态服务器</h3><p>我们先把静态服务器开起来，直接在工作目录下运行：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">hs .\data\ --cors<br></code></pre></div></td></tr></table></figure><p>因为我们的端口不一样，加个<code>--cors</code>来防止跨域。</p><h4 id="修改data-js"><a href="#修改data-js" class="headerlink" title="修改data.js"></a>修改data.js</h4><p>data.js里面有两行是加载文件的，需要翻墙才能下载，所以我们将加载的地址替换成我们的静态服务器地址：<br>将:</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MNIST_IMAGES_SPRITE_PATH</span> =<br><span class="hljs-string">&#x27;https://storage.googleapis.com/learnjs-data/model-builder/mnist_images.png&#x27;</span>;<br> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MNIST_LABELS_PATH</span> =<br><span class="hljs-string">&#x27;https://storage.googleapis.com/learnjs-data/model-builder/mnist_labels_uint8&#x27;</span>;<br></code></pre></div></td></tr></table></figure><p>替换成</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MNIST_IMAGES_SPRITE_PATH</span> =<br>    <span class="hljs-string">&#x27;http://127.0.0.1:8080/mnist_images.png&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MNIST_LABELS_PATH</span> =<br>    <span class="hljs-string">&#x27;http://127.0.0.1:8080/mnist_labels_uint8&#x27;</span>;<br></code></pre></div></td></tr></table></figure><p>这样data.js就能帮助我们加载数据了，我们也可以去学习data.js里的代码，以便我们后续创建属于自己加载数据的方法。</p><h2 id="显示输出数据"><a href="#显示输出数据" class="headerlink" title="显示输出数据"></a>显示输出数据</h2><h3 id="观察数据"><a href="#观察数据" class="headerlink" title="观察数据"></a>观察数据</h3><p>接下来我们来加载我们的训练数据，并且显示到我们的训练板上。我们会把我们的代码用<code>window.onload</code>包裹起来，<br>当然您也可以监听<code>DOMContentLoaded</code>事件。<br>先取出20组的测试数据，在index.js写入：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">window</span>.onload = () =&gt; &#123;<br>  const <span class="hljs-class"><span class="hljs-keyword">data</span> = new <span class="hljs-type">MnistData</span>();</span><br>  await <span class="hljs-class"><span class="hljs-keyword">data</span>.load();</span><br>  const examples = <span class="hljs-class"><span class="hljs-keyword">data</span>.nextTestBatch(20);</span><br>  console.log(examples);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后输入shell命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">parcel .\mnist\index.html<br></code></pre></div></td></tr></table></figure><p>等待编译完成，就能在浏览器看到我们取出来的数据结构。<br><img src="/./dataStyle.png" alt="dataStyle"></p><p>我们需要关注的就是这个张量的数据样式:<code>shape[20, 784]</code>。<br>第一个20表示我们取了20组的数据。<br>第二个784表示的是28×28×1,前两个28是代表图片的像素点，后面的1表示是黑白图片，因为黑白图片的RGB通道只占一个。<br>如果是彩色，那就要变成28×28×3。</p><h3 id="切割数据"><a href="#切割数据" class="headerlink" title="切割数据"></a>切割数据</h3><p>我们现在已经取出了数据了，接下来就是要切割成一张一张的图片，下面将用到TensorFlow.js给我们提供的处理数据的API：<br><a href="https://js.tensorflow.org/api/2.0.0/#slice">slice</a>： 这个会帮助我们对张量进行切割，类似于js的splice。<br><a href="https://js.tensorflow.org/api/2.0.0/#tf.Tensor.reshape">reshape</a>： 这个会帮助我们重新定义张量的形状，有利于我们将张量转换成像素显示出来。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MnistData</span>();<br>  <span class="hljs-keyword">await</span> data.<span class="hljs-title function_">load</span>();<br>  <span class="hljs-keyword">const</span> examples = data.<span class="hljs-title function_">nextTestBatch</span>(<span class="hljs-number">20</span>);<br>  <span class="hljs-keyword">const</span> numExamples = examples.<span class="hljs-property">xs</span>.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 取出数据的个数</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numExamples; i += <span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-keyword">const</span> imageTensor = tf.<span class="hljs-title function_">tidy</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>           <span class="hljs-keyword">return</span> examples.<span class="hljs-property">xs</span>.<span class="hljs-title function_">slice</span>([i, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">784</span>])<br>                             .<span class="hljs-title function_">reshape</span>([<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>]);<br>       &#125;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们将数据用<a href="https://js.tensorflow.org/api/2.0.0/#tidy">tf.tidy</a>包裹起来，他能帮助我们自动清除内存，这样能防止我们在处理大数据的时候，出现内存泄漏。<br>下面我们会借助TensorFlow.js的<a href="https://js.tensorflow.org/api/2.0.0/#browser.toPixels">toPixels</a>,将数据绘制在画布上。<br>他对输入数据的格式有要求，所以我们在切割完要调用<code>reshape([28, 28, 1])</code>转换数据格式。</p><h3 id="显示数据"><a href="#显示数据" class="headerlink" title="显示数据"></a>显示数据</h3><p>接着我们先在页面上用<code>canvas</code>画出我们的数据，并且显示到我们的训练板上。<br>我们要先调用<a href="https://js.tensorflow.org/api_vis/1.4.0/#tfvis.Visor.surface">tfvis.visor().surface</a>，来创建一个训练板。<br>并且创建canvas元素，用<a href="https://js.tensorflow.org/api/2.0.0/#browser.toPixels">toPixels</a>API,将我们的数据转换成像素，并画出来。<br>toPixels返回的是一个Promise。<br>具体代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-built_in">window</span>.onload = <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> MnistData();<br>  <span class="hljs-keyword">await</span> data.load();<br>  <span class="hljs-keyword">const</span> examples = data.nextTestBatch(<span class="hljs-number">20</span>);<br>  <span class="hljs-keyword">const</span> numExamples = examples.xs.shape[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">const</span> surface = tfvis.visor().surface(&#123; name: <span class="hljs-string">&#x27;输入数据例子&#x27;</span>,tab:<span class="hljs-string">&#x27;输入数据&#x27;</span> &#125;);<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; numExamples; i += <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">const</span> imageTensor = tf.tidy(() =&gt; &#123;<br>          <span class="hljs-keyword">return</span> examples.xs<br>              .slice([i, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">784</span>])<br>              .reshape([<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>]);<br>      &#125;);<br><br>      <span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;canvas&#x27;</span>);<br>      canvas.width = <span class="hljs-number">28</span>;<br>      canvas.height = <span class="hljs-number">28</span>;<br>      canvas.style = <span class="hljs-string">&#x27;margin: 3px&#x27;</span>;<br>      <span class="hljs-keyword">await</span> tf.browser.toPixels(imageTensor, canvas);<br>      surface.drawArea.appendChild(canvas);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果不出意外，您将看到以下内容：<br><img src="/./input-data.png" alt="inputData"></p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="卷积神经网络的定义"><a href="#卷积神经网络的定义" class="headerlink" title="卷积神经网络的定义"></a>卷积神经网络的定义</h3><p>卷积神经网络是模拟人视觉的处理过程，它包含的层为<br>·卷积层<br>·池化层<br>·全连接层</p><h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><p>卷积层可以用来帮助我们提取图像的特征，计算机基于卷积运算来提取特征。<br><a href="https://setosa.io/ev/image-kernels/">Image Kernels</a>这个网站,可以帮助我们理解底层操作。<br>图像中越白的数值越大，越黑的数据越小，范围为0-255<br><img src="/./data-size.png" alt="data-size"><br>接下来我们看看如何用卷积矩阵来提取特征。用一个outline内核为例。</p><h5 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h5><p>outline的特征矩阵为：<br>[-1 -1 -1]<br>[-1  8 -1]<br>[-1 -1 -1]<br>将这个矩阵乘以像素的值再相加，就能输出一个特征值，它可以帮我们提取图片的轮廓。<br><img src="/./img.png" alt="img"></p><p>不同的内核可以帮我们提取图片不同的特征，我们只需要知道卷积操作是用来帮我们提取特征的就行。<br>而一个卷积层使用了<code>多个卷积核</code>对图像进行卷积操作，因为一个图像的特征是非常丰富的。</p><blockquote><p>卷积层提取特征参考资料<br><a href="https://cs231n.github.io/convolutional-networks/">https://cs231n.github.io/convolutional-networks/</a></p></blockquote><p><img src="/./filters.gif" alt="strides"></p><p>卷积层训练的结果就是卷积核，我们在模型里需要输入的有:<br><code>kernelSize</code>: 滑动窗口的大小，如果设置为5，它将指定了一个正方形的5x5卷积窗口。<br><code>filters</code>: 指定大小为kernelSize的窗口数。<br><code>strides</code>: 每次走的步长。</p><h4 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h4><p>将一个或多个由前趋的卷积层创建的矩阵压缩为较小的矩阵。池化通常是取整个池化区域的最大值或平均值。<br>池化层有助于帮助我们在输入矩阵中实现<code>平移不变性</code>。</p><blockquote><p>平移不变性：例如，无论一只狗位于画面正中央还是画面左侧，该算法仍然可以识别它。</p></blockquote><p><img src="/./pooling.png" alt="pooling"></p><p>池化层也帮助了我们减少了计算量，以前是特征都要计算，现在只要计算最强特征就行了。并且可以间接帮助我们防止过拟合。<br>我们只需要知道，池化层仅仅是用来帮我们压缩训练的数据，减少计算量，它并没有权重需要训练。</p><h4 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h4><p>全连接层主要是作为输出层，和多分类下作为分类器，是比较常用的。全连接层有权重需要训练。</p><h3 id="创建模型结构"><a href="#创建模型结构" class="headerlink" title="创建模型结构"></a>创建模型结构</h3><p>接下来我们来在代码中定义我们的模型，其实tf.js已经帮我们把API封装好了，我们只需要调用就好了。</p><h4 id="定义卷积层"><a href="#定义卷积层" class="headerlink" title="定义卷积层"></a>定义卷积层</h4><p>我们添加的模型还是sequential()，连续的模型，第一层先添加一个二维的卷积层，因为我们图片是二维的。<br>接着上面的代码往下写：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javaScript"> ...<br><span class="hljs-keyword">const</span> model = tf.<span class="hljs-title function_">sequential</span>();<br>model.<span class="hljs-title function_">add</span>(tf.<span class="hljs-property">layers</span>.<span class="hljs-title function_">conv2d</span>(&#123;<br>    <span class="hljs-attr">inputShape</span>: [<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>],<br>    <span class="hljs-attr">kernelSize</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">filters</span>: <span class="hljs-number">8</span>,<br>    <span class="hljs-attr">strides</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">activation</span>: <span class="hljs-string">&#x27;relu&#x27;</span>,<br>    <span class="hljs-attr">kernelInitializer</span>: <span class="hljs-string">&#x27;varianceScaling&#x27;</span><br>&#125;));<br></code></pre></div></td></tr></table></figure><p><code>inputShape: [28, 28, 1]</code>: 输入数据的结构，分别对应长和宽，后面的1表示RGB占一个通道，为黑白图片。<br><code>kernelSize: 3</code>: 卷积核大小，像我们上面的矩阵就是3×3的卷积窗口，我们这里设置为5的卷积窗口。<br><code>filters: 8</code>: 指定大小为kernelSize的窗口数。我们这里用8个。<br><code>strides: 1</code>: 步长，就是每次移动的步数。<br><code>activation: &#39;relu&#39;</code>: 设置激活函数<code>relu：f(x)=max(0,x)</code>,他在x小于0的时候输出0，在大于0的时候输出自己。<br><img src="/./relu.png" alt="relu"><br><code>kernelInitializer: &#39;varianceScaling&#39;</code>: 用于随机初始化模型权重的方法，能加快收敛速度。</p><h4 id="定义个最大池化层"><a href="#定义个最大池化层" class="headerlink" title="定义个最大池化层"></a>定义个最大池化层</h4><p>第二层定义个最大池化层,并且设置两个超参数。接着写代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javaScript">model.<span class="hljs-title function_">add</span>(tf.<span class="hljs-property">layers</span>.<span class="hljs-title function_">maxPool2d</span>(&#123;<br>  <span class="hljs-attr">poolSize</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>],<br>  <span class="hljs-attr">strides</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<br>&#125;));<br></code></pre></div></td></tr></table></figure><p><code>poolSize: [2, 2]</code>: 池化的尺寸。<br><code>strides: [2, 2]</code>: 每次移动的步数。<br>定义了两层之后我们就已经提取了一轮的特征了，（可以理解为提取了横或竖的特征）我们接着再来定义第二轮的特征。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javaScript">model.<span class="hljs-title function_">add</span>(tf.<span class="hljs-property">layers</span>.<span class="hljs-title function_">conv2d</span>(&#123;<br>    <span class="hljs-attr">kernelSize</span>: <span class="hljs-number">5</span>,<br>    <span class="hljs-attr">filters</span>: <span class="hljs-number">16</span>,<br>    <span class="hljs-attr">strides</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">activation</span>: <span class="hljs-string">&#x27;relu&#x27;</span>,<br>    <span class="hljs-attr">kernelInitializer</span>: <span class="hljs-string">&#x27;varianceScaling&#x27;</span><br>  &#125;));<br><br>  model.<span class="hljs-title function_">add</span>(tf.<span class="hljs-property">layers</span>.<span class="hljs-title function_">maxPool2d</span>(&#123;<br>    <span class="hljs-attr">poolSize</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>],<br>    <span class="hljs-attr">strides</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<br>  &#125;));<br></code></pre></div></td></tr></table></figure><p>就是将上面两层模型再写一遍，<code>inputShape</code>不用再写一次，模型会自动计算出来，但是<code>filters</code>要填得大一点，因为我们要提取更多的特征。</p><h3 id="摊平数据"><a href="#摊平数据" class="headerlink" title="摊平数据"></a>摊平数据</h3><p>我们现在的数据是高维数据，卷积操作往往会增加进入其中的数据的大小。<br>在将它们传递到最终分类层之前，我们需要将数据展平为一个长数组。<code>tf.layers.flatten()</code>可以帮助我们拍平数组。<br>这是到达最后一层：<code>dense</code>层进行分类的最普遍的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javaScript">model.<span class="hljs-title function_">add</span>(tf.<span class="hljs-property">layers</span>.<span class="hljs-title function_">flatten</span>());<br></code></pre></div></td></tr></table></figure><blockquote><p>平坦层中没有权重。它只是将其输入展开为一个长数组。</p></blockquote><h4 id="全连接层-dense"><a href="#全连接层-dense" class="headerlink" title="全连接层(dense)"></a>全连接层(dense)</h4><p>这是最后一层，我们需要先设置一下神经元个数<code>units:10</code>,因为我们输出的分类是10个。<br>设置激活函数<code>softmax</code>,这个函数也称为归一化指数函数，它能将一个含任意实数的K维向量z“压缩”到另一个K维实向量σ(z)中，<br>使得每一个元素的范围都在(0,1)之间，并且所有元素的和为1。<br>设置层的初始化方法:<code>varianceScaling</code>。具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jacaScript">model.add(tf.layers.dense(&#123;<br>  units: 10,<br>  activation: &#x27;softmax&#x27;,<br>  kernelInitializer: &#x27;varianceScaling&#x27;<br>&#125;))<br></code></pre></div></td></tr></table></figure><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>我们的卷积模型已经定义好了，下一步就是要来设置一下损失函数和优化器。<br>第二步就是准备训练的数据，第三步就是可视化训练过程。</p><h3 id="设置损失函数和优化器"><a href="#设置损失函数和优化器" class="headerlink" title="设置损失函数和优化器"></a>设置损失函数和优化器</h3><p>在<code>compile</code>中设置交叉熵损失函数:<code>categoricalCrossentropy</code>，设置了一阶梯度优化：<code>自适应矩估计（Adam）</code>，<br>设置度量单位，准确度：<code>accuracy</code>。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">model.<span class="hljs-title function_">compile</span>(&#123;<br>  <span class="hljs-attr">loss</span>: <span class="hljs-string">&#x27;categoricalCrossentropy&#x27;</span>,<br>  <span class="hljs-attr">optimizer</span>: tf.<span class="hljs-property">train</span>.<span class="hljs-title function_">adam</span>(),<br>  <span class="hljs-attr">metrics</span>: [<span class="hljs-string">&#x27;accuracy&#x27;</span>]<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>接下来是准备数据.</p><h3 id="准备要训练的数据"><a href="#准备要训练的数据" class="headerlink" title="准备要训练的数据"></a>准备要训练的数据</h3><p>这是第二步，我们需要准备训练集和验证集。</p><h4 id="取出训练集"><a href="#取出训练集" class="headerlink" title="取出训练集"></a>取出训练集</h4><p>有一点要注意的是我们操作张量(tensor)的时候，要放在tidy中,它会帮我们清除两边的张量(tensor),减少干扰。<br>并且在执行完之后清除由分配的所有中间张量(tensor)。<br>取出500个训练集，具体看您机器性能。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> [trainXs, trainYs] = tf.<span class="hljs-title function_">tidy</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> d = data.<span class="hljs-title function_">nextTrainBatch</span>(<span class="hljs-number">500</span>);<br>  <span class="hljs-keyword">return</span> [<br>    d.<span class="hljs-property">xs</span>.<span class="hljs-title function_">reshape</span>([<span class="hljs-number">500</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>]), <span class="hljs-comment">// 改变数据的形状，变成适合我们模型的形状。</span><br>    d.<span class="hljs-property">labels</span><br>  ];<br>&#125;)<br></code></pre></div></td></tr></table></figure><h4 id="取出验证集"><a href="#取出验证集" class="headerlink" title="取出验证集"></a>取出验证集</h4><p>取出100个验证集.验证集可以看看训练得咋样，有没有过拟合或欠拟合。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [testXs, testYs] = tf.<span class="hljs-title function_">tidy</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> d = data.<span class="hljs-title function_">nextTestBatch</span>(<span class="hljs-number">100</span>);<br>  <span class="hljs-keyword">return</span> [<br>    d.<span class="hljs-property">xs</span>.<span class="hljs-title function_">reshape</span>([<span class="hljs-number">100</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>]),<br>    d.<span class="hljs-property">labels</span><br>  ];<br>&#125;);<br></code></pre></div></td></tr></table></figure><h3 id="调用tfvis可视化训练过程"><a href="#调用tfvis可视化训练过程" class="headerlink" title="调用tfvis可视化训练过程"></a>调用tfvis可视化训练过程</h3><p>接下来就是加载我们的训练集和验证集了。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">await</span> model.<span class="hljs-title function_">fit</span>(trainXs, trainYs, &#123;<br>  <span class="hljs-attr">validationData</span>: [testXs, testYs],<br>  <span class="hljs-attr">batchSize</span>: <span class="hljs-number">50</span>, <span class="hljs-comment">// 一次训练多少个</span><br>  <span class="hljs-attr">epochs</span>: <span class="hljs-number">20</span>, <span class="hljs-comment">// 训练几轮</span><br>  <span class="hljs-attr">callbacks</span>: tfvis.<span class="hljs-property">show</span>.<span class="hljs-title function_">fitCallbacks</span>(<br>      &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;训练效果&#x27;</span> &#125;,<br>      [<span class="hljs-string">&#x27;loss&#x27;</span>, <span class="hljs-string">&#x27;val_loss&#x27;</span>, <span class="hljs-string">&#x27;acc&#x27;</span>, <span class="hljs-string">&#x27;val_acc&#x27;</span>],<br>      &#123; <span class="hljs-attr">callbacks</span>: [<span class="hljs-string">&#x27;onEpochEnd&#x27;</span>] &#125; <span class="hljs-comment">// 只想看到onEpochEnd</span><br>  )<br>&#125;);<br></code></pre></div></td></tr></table></figure><p><code>&#39;loss&#39;, &#39;val_loss&#39;</code>表示的是要显示训练集和验证集的损失。<br><code>&#39;acc&#39;, &#39;val_acc&#39;</code> 表示要显示训练集和验证集的精确度。</p><p>接下来就可以观察到我们的结果了。启动命令：</p><blockquote><p>parcel .\mnist\index.html</p></blockquote><p><img src="/loo.png" alt="loo"><br>因为机器的原因，我们的误差还是很难降下来，您可以尝试增加训练数据来减少误差。</p><h3 id="进行预测"><a href="#进行预测" class="headerlink" title="进行预测"></a>进行预测</h3><p>我们的渣渣模型已经训练好了，很期待它会对我们写的数字作何反应。<br>我们接下来就要在网页上用canvas写出数字，并且转换为张量，然后输入模型进行预测。<br>直接上代码,先来HTML的代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 2px solid #666;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clear();&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin: 4px;&quot;</span>&gt;</span>清除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;predict();&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin: 4px;&quot;</span>&gt;</span>预测<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>接下来写clear和predict方法，它们需要挂载到window上。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><br>const canvas = document.querySelector(&#x27;canvas&#x27;);<br><br>canvas.addEventListener(&#x27;mousemove&#x27;, (e) =&gt; &#123; // 当鼠标划过的时候<br>  if (e.buttons === 1) &#123; // 如果按着左键<br>    const ctx = canvas.getContext(&#x27;2d&#x27;);<br>    ctx.fillStyle = &#x27;rgb(255,255,255)&#x27;; // 白的字<br>    ctx.fillRect(e.offsetX, e.offsetY, 25, 25);<br>  &#125;<br>&#125;);<br><br>window.clear = () =&gt; &#123;<br>  const ctx = canvas.getContext(&#x27;2d&#x27;);<br>  ctx.fillStyle = &#x27;rgb(0,0,0)&#x27;; // 设置黑底<br>  ctx.fillRect(0, 0, 300, 300); // 填充大小<br>&#125;;<br><br>clear(); // 每次初始化的时候都清空一下<br><br>window.predict = () =&gt; &#123;<br>  const input = tf.tidy(() =&gt; &#123;<br>    return tf.image.resizeBilinear(<br>      tf.browser.fromPixels(canvas), // 将canvas转换为张量<br>      [28, 28], // 将300×300 的图片转换为28×28<br>      true // 设置4个边角<br>    ).slice([0, 0, 0], [28, 28, 1]) // 将彩色图片转换为黑白图片，删除了RGB另外两个通道<br>      .toFloat() // 转换为float<br>      .div(255) // 除去255，进行归一化处理<br>      .reshape([1, 28, 28, 1]); // 将张量变成输入的形状，要跟输入数据保查一致<br>  &#125;);<br>  const pred = model.predict(input).argMax(1); // 进行预测<br>  alert(`预测结果为 $&#123;pred.dataSync()[0]&#125;`); // 转换为普通数据结构，不然是个数组<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>接下来就可以开心的进行预测了。<br><img src="/./yc.png" alt="预测"><br>因为我们的训练数据并不是很多，所以预测的成功率大约只有70%.(很多7都识别成1)。</p><p>感谢看到最后。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>草色烟光残照里，无言谁会凭阑意。<br>「蝶恋花·伫倚危楼风细细」<br>柳永</p>]]></content>
    
    
    
    <tags>
      
      <tag>TensorFlow.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端基础机器学习:线性回归</title>
    <link href="/2020/06/07/%E5%9F%BA%E7%A1%80%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <url>/2020/06/07/%E5%9F%BA%E7%A1%80%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本章将使用<a href="https://www.tensorflow.org/js/">TensorFlow.js</a>,进行线性回归的学习。<br>使用<a href="https://parceljs.org/getting_started.html">parcel</a>打包工具进行打包, 此工具免配置，适用于经验不同的开发者，比webpack方便。<br>并且会用两个例子，一个是简单的预测两数之间的关系，一个是预测孩子的身高与父母身高的关系，来加深印象。</p><h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>您需要有前端开发的基础知识。（js,html）<br>了解线性回归相关知识。<br>拥有高中或者高等数学知识。</p><blockquote><p>推荐：<a href="https://developers.google.cn/machine-learning/crash-course/ml-intro?hl=zh-cn">Google机器学习速成教程</a></p></blockquote><p><img src="/0.jpg" alt="上号"></p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>我们先在任意空文件夹中，打开我们的编辑器，初始化我们的编码环境</p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init -y<br></code></pre></div></td></tr></table></figure><p>接下来我们来下载我们的TensorFlow.js包，和 parcel 打包工具。</p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @tensorflow/tfjs <br></code></pre></div></td></tr></table></figure><p>全局安装parcel</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g parcel-bundler<br></code></pre></div></td></tr></table></figure><p>我们接下来会用<a href="https://github.com/tensorflow/tfjs/tree/master/tfjs-vis">tfjs-vis</a>，来可视化我们的训练过程，我们把它也顺便安装上。</p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @tensorflow/tfjs-vis<br></code></pre></div></td></tr></table></figure><p>创建文件夹，进入文件夹创建index.html和index.js,目录结构类似这样:</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-string">|-node_modules</span><br><span class="hljs-string">|-linearRegression</span><br>    <span class="hljs-string">|--index.html</span><br>    <span class="hljs-string">|--index.js</span><br><span class="hljs-string">|-package.json</span><br><span class="hljs-string">|-package-lock.json</span><br></code></pre></div></td></tr></table></figure><p>我们等等要用到async+await语法，所以我们的在package.json声明一一些代码： <code>last 1 Chrome version</code></p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;tensoflow.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;@tensorflow-models/speech-commands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^0.4.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@tensorflow/tfjs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.3.1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@tensorflow/tfjs-node&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.2.9&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@tensorflow/tfjs-vis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.2.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ISC&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;browserslist&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;last 1 Chrome version&quot;</span> <br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></div></td></tr></table></figure><h2 id="用X来预测Y"><a href="#用X来预测Y" class="headerlink" title="用X来预测Y"></a>用X来预测Y</h2><h3 id="创建HTML"><a href="#创建HTML" class="headerlink" title="创建HTML"></a>创建HTML</h3><p>我们首先把上面创建的HTML引入我们的js，让它来可视化我们的训练过程。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>线性回归<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="填充训练集和绘制散点图"><a href="#填充训练集和绘制散点图" class="headerlink" title="填充训练集和绘制散点图"></a>填充训练集和绘制散点图</h3><h4 id="引入我们需要的两个库"><a href="#引入我们需要的两个库" class="headerlink" title="引入我们需要的两个库"></a>引入我们需要的两个库</h4><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> tf <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tensorflow/tfjs&#x27;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> tfvis <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tensorflow/tfjs-vis&#x27;</span>;<br></code></pre></div></td></tr></table></figure><h4 id="填充我们的训练集"><a href="#填充我们的训练集" class="headerlink" title="填充我们的训练集"></a>填充我们的训练集</h4><p>我们填充了xs,和ys,准备用xs来预测我们的ys。并且创建了一个匿名函数，让它在html加载完执行。<br>（数据也可自行填充）</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> tf <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tensorflow/tfjs&#x27;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> tfvis <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tensorflow/tfjs-vis&#x27;</span>;<br><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> xl = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">const</span> yl = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>];<br>&#125;;<br></code></pre></div></td></tr></table></figure><h4 id="绘制散点图"><a href="#绘制散点图" class="headerlink" title="绘制散点图"></a>绘制散点图</h4><p>下面调用的<code>tfvis</code>的render方法里的<a href="https://js.tensorflow.org/api_vis/1.4.0/#render.scatterplot"><code>scatterplot</code></a>,来绘制散点图。<code>scatterplot</code>接收三个对象。我们只介绍部分，详情点击上面链接。<br>第一个对象可以接收一个<code>name</code>,类型是string,代表图表的名字<br>第二个对象接收一个<code>values</code>,类型是以{x，y}元组的数组（或嵌套数组）。</p><blockquote><p>类型就是这样：[ { x: 1, y: 2 }, { x: 2, y: 3 }, { x: 3, y: 5 }, { x: 4, y: 7 } ]</p></blockquote><p>第三个对象我们只用到了<code>xAxisDomain</code>和<code>yAxisDomain</code>，用来调整我们图表的可视范围。</p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> tf <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tensorflow/tfjs&#x27;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> tfvis <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tensorflow/tfjs-vis&#x27;</span>;<br><br>window.onload = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    const xl = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>    const yl = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>];<br>&#125;;<br> tfvis.render.scatterplot(<br>        &#123; name: <span class="hljs-string">&#x27;linear regression&#x27;</span> &#125;,<br>        &#123; values: xl.map(<span class="hljs-function"><span class="hljs-params">(x, i)</span> =&gt;</span> (&#123; x, y: yl[i] &#125;)) &#125;,<br>        &#123; xAxisDomain: [<span class="hljs-number">0</span>, <span class="hljs-number">5</span>], yAxisDomain: [<span class="hljs-number">0</span>, <span class="hljs-number">8</span>] &#125;<br>    );<br></code></pre></div></td></tr></table></figure><p>接下来就可以运行一下我们的程序了，在命令行写入：</p><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta">parcel .\linear-regression\<span class="hljs-keyword">index</span>.html<br></code></pre></div></td></tr></table></figure><p>然后打开页面，就能查看到我们的散点图了<br><img src="/./index.png" alt="散点图"></p><h3 id="创建一个神经网络模型"><a href="#创建一个神经网络模型" class="headerlink" title="创建一个神经网络模型"></a>创建一个神经网络模型</h3><p>用<a href="https://js.tensorflow.org/api/2.0.0/#sequential">tf.sequential</a>,创建一个连续的模型。<br><code>sequential</code>模型的阔谱可以理解为堆栈，没有分支和跳过。我们在解决一些简单问题的时候，一般用此模型。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> tf <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tensorflow/tfjs&#x27;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> tfvis <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tensorflow/tfjs-vis&#x27;</span>;<br><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> xl = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">const</span> yl = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>];<br>&#125;;<br> tfvis.<span class="hljs-property">render</span>.<span class="hljs-title function_">scatterplot</span>(<br>        &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;linear regression&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">values</span>: xl.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x, i</span>) =&gt;</span> (&#123; x, <span class="hljs-attr">y</span>: yl[i] &#125;)) &#125;,<br>        &#123; <span class="hljs-attr">xAxisDomain</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">5</span>], <span class="hljs-attr">yAxisDomain</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">8</span>] &#125;<br>    );<br><span class="hljs-keyword">const</span> model = tf.<span class="hljs-title function_">sequential</span>();<br></code></pre></div></td></tr></table></figure><h3 id="为神经网络添加层"><a href="#为神经网络添加层" class="headerlink" title="为神经网络添加层"></a>为神经网络添加层</h3><p>接下来就是为神经网络添加一个全连接层，它可以实现的操作是</p><blockquote><p>output &#x3D; activation(dot(input, kernel) + bias)</p></blockquote><p><code>activation</code>: 激活函数，我们现在还用不到，他能帮我们解决更多的问题<br><code>dot</code> : 点乘<br><code>kernel</code>: 权重矩阵，在我们这个例子里可以理解为简单的一个数值。<br><code>bias</code>: 表示偏置矢量 </p><p>简单理解就是: 它可以帮我们解决乘以一个权重，再加上一个参数的问题。代码如下：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">model</span> = tf.<span class="hljs-title function_ invoke__">sequential</span>();<br>model.<span class="hljs-title function_ invoke__">add</span>(tf.layers.<span class="hljs-title function_ invoke__">dense</span>(&#123; <span class="hljs-attr">units</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">inputShape</span>: [<span class="hljs-number">1</span>] &#125;));<br></code></pre></div></td></tr></table></figure><p><code>model.add</code>: 表示添加一个层<br><code>tf.layers.dense()</code>: 创建一个全连接层。 <a href="https://js.tensorflow.org/api/2.0.0/#layers.dense">扩展tf.layers.dense()</a><br><code>units</code>: 神经元的个数，一个神经元就能解决我们的问题了。<br><code>inputShape</code>: 输入的值形状，[1]表示我们的输入是一维的数据。就是我们的x轴数据。</p><h3 id="设置损失函数：均方误差与优化器：-随机梯度下降"><a href="#设置损失函数：均方误差与优化器：-随机梯度下降" class="headerlink" title="设置损失函数：均方误差与优化器： 随机梯度下降"></a>设置损失函数：均方误差与优化器： 随机梯度下降</h3><p>神经网络在初始化的时候会瞎蒙一个权重值，这个权重值一般是错的，而这个损失函数，就是来告诉神经网络，这个权重值错得有多离谱。<br>而神经网络就会用优化器来降低我们的损失。<a href="https://developers.google.com/machine-learning/crash-course/descending-into-ml/training-and-loss?hl=zh-cn">降低损失</a></p><blockquote><p>均方误差这个常用的损失函数，在我们这个线性回归问题的适用的，但不代表所有情况。</p></blockquote><p>TensorFlow已经帮我们封装了公式的操作，我们只需要调用就行了，如下：</p><figure class="highlight roboconf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs roboconf">model.compile(&#123; <br>    <span class="hljs-attribute">loss</span>: tf<span class="hljs-variable">.losses</span><span class="hljs-variable">.meanSquaredError</span>, <br>    optimizer: tf<span class="hljs-variable">.train</span><span class="hljs-variable">.sgd</span>(0.1) <br>    &#125;);<br></code></pre></div></td></tr></table></figure><p>loss：里面传了一个均方误差<code>tf.losses.meanSquaredError</code>，<a href="https://js.tensorflow.org/api/2.0.0/#losses.absoluteDifference">tf.losses</a>里有很多的损失函数。<br>optimizer: 传了一个优化器，<code>sgd</code>就是随机梯度下降。并且设置了一个0.1的学习速率。这是一个超参数。 <a href="https://js.tensorflow.org/api/2.0.0/#train.sgd">扩展：更多优化器</a>.</p><p><a href="https://developers.google.cn/machine-learning/crash-course/ml-intro?hl=zh-cn">优化学习速率</a>，Google的这个交互教程能加快您对学习速率的理解。</p><h3 id="训练模型并在网页上显示训练过程"><a href="#训练模型并在网页上显示训练过程" class="headerlink" title="训练模型并在网页上显示训练过程"></a>训练模型并在网页上显示训练过程</h3><p>我们训练的第一步是将训练的数据转换为 <a href="https://js.tensorflow.org/api/2.0.0/#tensor">Tensor</a>,这个张量是一个高维的物理量，这是TensorFlow世界的规定。<br>具体了解详情点击上面链接看示例。<br>第二步就能调用<a href="https://js.tensorflow.org/api/2.0.0/#tf.LayersModel.fit">model.fit</a>训练模型。<br>第一个参数是x的张量，第二个参数是y的张量。第三个参数接收一个对象，我们主要用到以下几个：<br><code>epochs</code>: 迭代训练数据数组的次数,接收类型为Number。<br><code>batchSize </code>: 每个梯度更新的样本数,接收类型为Number。<br><code>callback</code>: 回调，我们要在此调用<a href="https://js.tensorflow.org/api_vis/1.4.0/#show.fitCallbacks">tfvis.show.fitCallbacks</a>，来绘制我们的损失。<br>它返回的是一个Promise,所以我们要在前面加上await，函数前面也要记得加async。<br>代码如下：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">import * <span class="hljs-keyword">as</span> tf <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tensorflow/tfjs&#x27;</span>;<br>import * <span class="hljs-keyword">as</span> tfvis <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tensorflow/tfjs-vis&#x27;</span>;<br><br>window.onload = <span class="hljs-title function_ invoke__">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">xl</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">yl</span> = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>];<br><br>    tfvis.render.<span class="hljs-title function_ invoke__">scatterplot</span>(<br>        &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;线性回归训练集&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">values</span>: xl.<span class="hljs-title function_ invoke__">map</span>((x, i) =&gt; (&#123; x, <span class="hljs-attr">y</span>: yl[i] &#125;)) &#125;,<br>        &#123; xAxisDomain: [<span class="hljs-number">0</span>, <span class="hljs-number">5</span>], yAxisDomain: [<span class="hljs-number">0</span>, <span class="hljs-number">8</span>] &#125;<br>    );<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">model</span> = tf.<span class="hljs-title function_ invoke__">sequential</span>();<br>    model.<span class="hljs-title function_ invoke__">add</span>(tf.layers.<span class="hljs-title function_ invoke__">dense</span>(&#123; <span class="hljs-attr">units</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">inputShape</span>: [<span class="hljs-number">1</span>] &#125;));<br>    model.<span class="hljs-title function_ invoke__">compile</span>(&#123; <br>        <span class="hljs-attr">loss</span>: tf.losses.meanSquaredError, <br>        <span class="hljs-attr">optimizer</span>: tf.train.<span class="hljs-title function_ invoke__">sgd</span>(<span class="hljs-number">0.1</span>) <br>    &#125;);<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">xInputs</span> = tf.<span class="hljs-title function_ invoke__">tensor</span>(xl);<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">yInputs</span> = tf.<span class="hljs-title function_ invoke__">tensor</span>(yl); <span class="hljs-comment">// 将两个数据转换为张量</span><br>    await model.<span class="hljs-title function_ invoke__">fit</span>(xInputs, yInputs, &#123;<br>        <span class="hljs-attr">batchSize</span>: <span class="hljs-number">2</span>, // 每次要去学的数据量多大: 随机梯度下降<br>        <span class="hljs-attr">epochs</span>: <span class="hljs-number">200</span>, // 超参数<br>        <span class="hljs-attr">callbacks</span>: tfvis.show.<span class="hljs-title function_ invoke__">fitCallbacks</span>(<br>            &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;训练过程&#x27;</span> &#125;,<br>            [<span class="hljs-string">&#x27;loss&#x27;</span>]<br>        )<br>    &#125;);<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>当<code>batchSize</code>设置为2的时候，代表每次给模型学习两个点，这样模型产生的误差抖动还是较大的。<br><img src="/./batchSize_2.png" alt="batchSize_2"></p><p>我们将<code>batchSize</code>设置为4,让模型一次学4个点看看<br><img src="/./batchSize_4.png" alt="batchSize_4"></p><p>这次的曲线好多了，接下来我们就可以用这个训练好的模型来进行预测了。</p><h3 id="预测模型"><a href="#预测模型" class="headerlink" title="预测模型"></a>预测模型</h3><p>下面将用<a href="https://js.tensorflow.org/api/2.0.0/#tf.GraphModel.predict">model.predict</a>对输入的张量进行推理。<br>注意：输入的值要转换为张量。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> tf <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tensorflow/tfjs&#x27;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> tfvis <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tensorflow/tfjs-vis&#x27;</span>;<br><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> xl = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">const</span> yl = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>];<br><br>    tfvis.<span class="hljs-property">render</span>.<span class="hljs-title function_">scatterplot</span>(<br>        &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;线性回归训练集&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">values</span>: xl.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x, i</span>) =&gt;</span> (&#123; x, <span class="hljs-attr">y</span>: yl[i] &#125;)) &#125;,<br>        &#123; <span class="hljs-attr">xAxisDomain</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">5</span>], <span class="hljs-attr">yAxisDomain</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">8</span>] &#125;<br>    );<br><br>    <span class="hljs-keyword">const</span> model = tf.<span class="hljs-title function_">sequential</span>();<br>    model.<span class="hljs-title function_">add</span>(tf.<span class="hljs-property">layers</span>.<span class="hljs-title function_">dense</span>(&#123; <span class="hljs-attr">units</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">inputShape</span>: [<span class="hljs-number">1</span>] &#125;));<br>    model.<span class="hljs-title function_">compile</span>(&#123; <br>         <span class="hljs-attr">loss</span>: tf.<span class="hljs-property">losses</span>.<span class="hljs-property">meanSquaredError</span>, <br>         <span class="hljs-attr">optimizer</span>: tf.<span class="hljs-property">train</span>.<span class="hljs-title function_">sgd</span>(<span class="hljs-number">0.1</span>) <span class="hljs-comment">// 学习率</span><br>    &#125;); <br><br>    <span class="hljs-keyword">const</span> xInputs = tf.<span class="hljs-title function_">tensor</span>(xl);<br>    <span class="hljs-keyword">const</span> yInputs = tf.<span class="hljs-title function_">tensor</span>(yl);<br>    <span class="hljs-keyword">await</span> model.<span class="hljs-title function_">fit</span>(xInputs, yInputs, &#123;<br>        <span class="hljs-attr">batchSize</span>: <span class="hljs-number">4</span>, <span class="hljs-comment">// 每次要去学的数据量多大: 随机梯度下降</span><br>        <span class="hljs-attr">epochs</span>: <span class="hljs-number">200</span>, <span class="hljs-comment">// 超参数</span><br>        <span class="hljs-attr">callbacks</span>: tfvis.<span class="hljs-property">show</span>.<span class="hljs-title function_">fitCallbacks</span>(<br>            &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;训练过程&#x27;</span> &#125;,<br>            [<span class="hljs-string">&#x27;loss&#x27;</span>]<br>        )<br>    &#125;);<br><br>    <span class="hljs-keyword">const</span> output = model.<span class="hljs-title function_">predict</span>(tf.<span class="hljs-title function_">tensor</span>([<span class="hljs-number">5</span>]));<br>    output.<span class="hljs-title function_">print</span>()<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`当x为 5 的时候，推理的 y 为 <span class="hljs-subst">$&#123;output.dataSync()[<span class="hljs-number">0</span>]&#125;</span>`</span>);<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>到此我们就完成了线性回归的学习。</p><h2 id="预测男女性身高"><a href="#预测男女性身高" class="headerlink" title="预测男女性身高"></a>预测男女性身高</h2><p>数据是伪造的,只要简单的填充一下数据，和改写一下区间就行，大体不变：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">import * <span class="hljs-keyword">as</span> tf <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tensorflow/tfjs&#x27;</span>;<br>import * <span class="hljs-keyword">as</span> tfvis <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tensorflow/tfjs-vis&#x27;</span>;<br><br>window.onload = <span class="hljs-title function_ invoke__">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">xl</span> = [<span class="hljs-number">1.6</span>, <span class="hljs-number">1.7</span>, <span class="hljs-number">1.75</span>, <span class="hljs-number">2.3</span>]; <span class="hljs-comment">// 父母平均身高</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">yl</span> = [<span class="hljs-number">1.86</span>, <span class="hljs-number">1.87</span>, <span class="hljs-number">1.875</span>, <span class="hljs-number">1.93</span>]; <span class="hljs-comment">// 儿女身高</span><br><br><br><br>    tfvis.render.<span class="hljs-title function_ invoke__">scatterplot</span>(<br>        &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;根据父母身高预测孩子身高&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">values</span>: xl.<span class="hljs-title function_ invoke__">map</span>((x, i) =&gt; (&#123; x, <span class="hljs-attr">y</span>: yl[i] &#125;)) &#125;,<br>        &#123; xAxisDomain: [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>], yAxisDomain: [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>] &#125;<br>    );<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">model</span> = tf.<span class="hljs-title function_ invoke__">sequential</span>();<br>    model.<span class="hljs-title function_ invoke__">add</span>(tf.layers.<span class="hljs-title function_ invoke__">dense</span>(&#123; <span class="hljs-attr">units</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">inputShape</span>: [<span class="hljs-number">1</span>] &#125;));<br>    model.<span class="hljs-title function_ invoke__">compile</span>(&#123; <span class="hljs-attr">loss</span>: tf.losses.meanSquaredError, <span class="hljs-attr">optimizer</span>: tf.train.<span class="hljs-title function_ invoke__">sgd</span>(<span class="hljs-number">0.1</span>) &#125;);<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">xInputs</span> = tf.<span class="hljs-title function_ invoke__">tensor</span>(xl);<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">yInputs</span> = tf.<span class="hljs-title function_ invoke__">tensor</span>(yl);<br>    await model.<span class="hljs-title function_ invoke__">fit</span>(xInputs, yInputs, &#123;<br>        <span class="hljs-attr">batchSize</span>: <span class="hljs-number">4</span>, // 每次要去学的数据量多大: 随机梯度下降<br>        <span class="hljs-attr">epochs</span>: <span class="hljs-number">200</span>, // 超参数<br>        <span class="hljs-attr">callbacks</span>: tfvis.show.<span class="hljs-title function_ invoke__">fitCallbacks</span>(<br>            &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;训练过程&#x27;</span> &#125;,<br>            [<span class="hljs-string">&#x27;loss&#x27;</span>]<br>        )<br>    &#125;);<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">output</span> = model.<span class="hljs-title function_ invoke__">predict</span>(tf.<span class="hljs-title function_ invoke__">tensor</span>([<span class="hljs-number">2</span>]));<br>    output.<span class="hljs-keyword">print</span>()<br>    <span class="hljs-title function_ invoke__">alert</span>(`当父母平均身高为 <span class="hljs-number">2</span> 米的时候，儿子的身高 为 $&#123;output.<span class="hljs-title function_ invoke__">dataSync</span>()[<span class="hljs-number">0</span>]&#125; 米`);<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>以上就是本次的线性回归，这是入门的基础内容，有错误请指正。</p><blockquote><p>参考:<br><a href="https://zhuanlan.zhihu.com/p/43915994">B乎</a><br><a href="https://developers.google.cn/machine-learning/crash-course/fitter/graph?hl=zh-cn">Google机器学习速成教程</a><br><a href="https://js.tensorflow.org/api/2.0.0/">TensorFlow.js官网API</a></p></blockquote><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>怕上层楼，十日九风雨。<br>「祝英台近·晚春」<br>辛弃疾</p>]]></content>
    
    
    
    <tags>
      
      <tag>TensorFlow.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>尤雨溪谈vue3.0beta总结</title>
    <link href="/2020/04/21/%E5%B0%A4%E9%9B%A8%E6%BA%AA%E8%B0%88vue3-0beta%E6%80%BB%E7%BB%93/"/>
    <url>/2020/04/21/%E5%B0%A4%E9%9B%A8%E6%BA%AA%E8%B0%88vue3-0beta%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vue3.0测试版已经发布了。尤雨溪在<code>bilibili</code>直播中，分享了一些新特性。<br>vue3中所有的一手信息，可以在<a href="https://github.com/vuejs/rfcs">RFC</a>中查阅。</p><blockquote><p><a href="https://github.com/vuejs/vue-next#status-beta">https://github.com/vuejs/vue-next#status-beta</a><br>视频链接<br>链接：<a href="https://pan.baidu.com/s/1l18x-Duubn17XQx8XZJR_A">https://pan.baidu.com/s/1l18x-Duubn17XQx8XZJR_A</a><br> 提取码：otbp </p></blockquote><p>您可以在Vue CLI中通过<a href="https://github.com/vuejs/vue-cli-plugin-vue-next">vue-cli-plugin-vue-next</a>获得实验性支持。</p><h2 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h2><p>·   Performance （通过一些细节实现性能的提高）<br>·   Tree-shaking support（没有用到的API不进行打包）<br>·   <a href="https://composition-api.vuejs.org/">Composition API</a> （vue的组合API）<br>·   <code>Fragment</code>, <code>Teleport</code>, <code>Suspense</code> （新的内置的功能）<br>·   Better TypeScript support （更强的TS支持）<br>·   Custom Renderer API（第一方暴露自定义渲染API）</p><h2 id="性能（Performance）"><a href="#性能（Performance）" class="headerlink" title="性能（Performance）"></a>性能（Performance）</h2><blockquote><p>性能比较只比较JavaScript引擎占用的时间，场景皆为模拟，具体看真实的环境。<br><a href="https://vue-next-template-explorer.netlify.app/#%7B%22src%22%3A%22%3Cdiv%3EHello%20World!%3C%2Fdiv%3E%22%2C%22options%22%3A%7B%22mode%22%3A%22module%22%2C%22prefixIdentifiers%22%3Afalse%2C%22optimizeBindings%22%3Afalse%2C%22hoistStatic%22%3Afalse%2C%22cacheHandlers%22%3Afalse%2C%22scopeId%22%3Anull%7D%7D">vue3模板编译的程序</a></p></blockquote><h3 id="重写了-virtual-dom"><a href="#重写了-virtual-dom" class="headerlink" title="重写了 virtual dom"></a>重写了 virtual dom</h3><p>virtual dom本质上还是需要去花时间去编译的。vue3利用了编译器的特性，通过分析模板，来实现模板编译时的优化。<br>生成优化过后的virtual dom。</p><h3 id="优化模板编译（Compiler-informed-fast-paths）"><a href="#优化模板编译（Compiler-informed-fast-paths）" class="headerlink" title="优化模板编译（Compiler informed fast paths）"></a>优化模板编译（Compiler informed fast paths）</h3><p>假如我们要编译以下代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>static<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>它会编译成下面这样：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createVNode <span class="hljs-keyword">as</span> _createVNode, toDisplayString <span class="hljs-keyword">as</span> _toDisplayString, openBlock <span class="hljs-keyword">as</span> _openBlock, createBlock <span class="hljs-keyword">as</span> _createBlock &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx, _cache</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-title function_">_openBlock</span>(), <span class="hljs-title function_">_createBlock</span>(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-literal">null</span>, [<br>    <span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;span&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;static&quot;</span>),<br>    <span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;span&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-title function_">_toDisplayString</span>(_ctx.<span class="hljs-property">msg</span>), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>) <span class="hljs-comment">//page flag</span><br>  ]))<br>&#125;<br><span class="hljs-comment">// Check the console for the AST</span><br></code></pre></div></td></tr></table></figure><p>vue会在运行时，只有带有page flag的节点会被真正的追踪。也就是说，当我们后续要更新的时候，vue就会直接去找到这个动态节点。<br>而且通过flag的信息，可以知道只需要要比较text内容的变动，不需要去管其他的属性，或者绑定。<br>并且不用管层级嵌套得很深，它的动态节点是直接跟Block的根节点绑定起来的。所以不再需要去遍历静态的节点。<br>再看以下代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>static<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;bar&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>编译成下面这样</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">import &#123; createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;<br>export function render(_ctx, _cache) &#123;<br>  return (_openBlock(), _createBlock(&quot;div&quot;, null, [<br>    _createVNode(&quot;span&quot;, null, &quot;static&quot;),<br>    _createVNode(&quot;span&quot;, &#123; id: &quot;bar&quot; &#125;, _toDisplayString(_ctx.msg), 1 /* TEXT */)<br>  ]))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个id是静态的，所以我们的page flag 也没有变化，对于runtime来说，这个id存不存在都没有区别。<br>只有在创建的时候创建了一次，后续的更新都不用管了。<br>如果将id改成动态：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>static<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">:id</span> = <span class="hljs-string">&quot;bar&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>编译后：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">import &#123; createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;<br>export function render(_ctx, _cache) &#123;<br>  return (_openBlock(), _createBlock(&quot;div&quot;, null, [<br>    _createVNode(&quot;span&quot;, null, &quot;static&quot;),<br>    _createVNode(&quot;span&quot;, &#123; id: _ctx.bar &#125;, _toDisplayString(_ctx.msg), 9 /* TEXT, PROPS */, [&quot;id&quot;])<br>  ]))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>做成动态绑定之后，page flag 变成 <code>/* TEXT, PROPS */, [&quot;id&quot;]</code>,它告诉我们，不仅有text的变化，还有PROPS的变化，变化的就是数组里的id。</p><p>这样就既跳出了virtual dom性能的瓶颈，又保留了可以手写render的灵活性。<br>也可以理解为：既有react的灵活性，又有基于模板的性能保证。</p><h3 id="侦听缓存（cacheHandlers）"><a href="#侦听缓存（cacheHandlers）" class="headerlink" title="侦听缓存（cacheHandlers）"></a>侦听缓存（cacheHandlers）</h3><p>假如我们要绑定一个事件：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> @<span class="hljs-attr">click</span> = <span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>默认没有优化的编译是这样的:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">import &#123; toDisplayString as _toDisplayString, createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;<br>export function render(_ctx, _cache) &#123;<br>  return (_openBlock(), _createBlock(&quot;div&quot;, null, [<br>    _createVNode(&quot;span&quot;, &#123; onClick: _ctx.onClick &#125;, _toDisplayString(_ctx.msg), 9 /* TEXT, PROPS */, [&quot;onClick&quot;])<br>  ]))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们需要将它看作一个动态的绑定，如果后续要替换掉onClick是需要进行一次更新的。<br>如果我们使用<code>cacheHandlers</code>,进行优化：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">import &#123; toDisplayString as _toDisplayString, createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;<br><br>export function render(_ctx, _cache) &#123;<br>  return (_openBlock(), _createBlock(&quot;div&quot;, null, [<br>    _createVNode(&quot;span&quot;, &#123;<br>      onClick: _cache[1] || (_cache[1] = $event =&gt; (_ctx.onClick($event)))<br>    &#125;, _toDisplayString(_ctx.msg), 1 /* TEXT */)<br>  ]))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>它会生成一个内联函数，这个内联函数才会去引用当前最新的<code>onClick</code>,然后把这个内联函数缓存起来。<br>第一次执行的时候，会创建这个函数并且缓存，后续直接在缓存里读取这个函数。<br>所以上面的没有再标记flag,将其变成了静态的。<br>我们还可以在<code>click</code>里手写内联函数，vue也会将内联函数缓存起来，帮助你跳过更多的更新。<br>这个的优势主要体现在组件上：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Foo</span> @<span class="hljs-attr">click</span> = <span class="hljs-string">&quot;()=&gt;foo()&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Foo</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>这样导致的问题是：父组件一旦更新，子组件也会跟着更新。<br><code>cacheHandlers</code>解决了这个问题，并且vue3在编译时就帮你做好，让我们不用考虑这个问题。</p><h3 id="更快的服务器渲染-（-2-3x-faster-SSR-）"><a href="#更快的服务器渲染-（-2-3x-faster-SSR-）" class="headerlink" title="更快的服务器渲染 （ 2-3x faster SSR*）"></a>更快的服务器渲染 （ 2-3x faster SSR*）</h3><p>如果我们在进行SSR的时候，有很多的静态内容：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:id</span> = <span class="hljs-string">&quot;bar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>编译结果：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">import &#123; ssrRenderAttr as _ssrRenderAttr &#125; from &quot;@vue/server-renderer&quot;<br><br>export function ssrRender(_ctx, _push, _parent) &#123;<br>  _push(`<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&lt;div$&#123;_ssrRenderAttr(&quot;id&quot;, _ctx.bar)&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>它在编译的时候会将其当作一个字符串，直接推进Buffer里。如果包含动态id,也会尽量渲染成一个字符串。<br>这样服务端渲染的性能会大大提高。<br>并且如果在客户端的时候，静态节点达到一定的阈值，会直接对其innerHTML。</p><h2 id="Tree-shaking"><a href="#Tree-shaking" class="headerlink" title="Tree-shaking"></a>Tree-shaking</h2><p>这是vue3比2的一个较大的区别。比如说你没有用到<code>v-model</code> 或者 <code>transition</code>这些功能，就不会去编译到最后的包里。<br>这个Tree-shaking是通过编译器来实现的，举例来说。<br>如果我们引入一个div:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>它会引入以下内容：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">import &#123; createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;<br>export function render(_ctx, _cache) &#123;<br>  return (_openBlock(), _createBlock(&quot;div&quot;))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>只有当你使用到的时候，才会被引入进去，而虚拟节点的更新算法和响应式系统，这是无论如何都会引入到你的包里的。<br>如果我们引入一个text的<code>v-model</code>:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;foo&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>它会引入以下代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">import &#123; vModelText as _vModelText, createVNode as _createVNode, withDirectives as _withDirectives, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;<br></code></pre></div></td></tr></table></figure><p>它将会把针对文字输入框的v-model代码引入进来。<br>如果我们改成<code>checkbox</code>:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;foo&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>它将会引入<code>checkbox</code>的代码:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">import &#123; vModelCheckbox as _vModelCheckbox, createVNode as _createVNode, withDirectives as<br> _withDirectives, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;<br></code></pre></div></td></tr></table></figure><p> vue会尽可能的引入少的包，没有引入的会被tree-shaking掉。<br> 它在只引入一个HelloWorld，最终打包出来的大小只有13.5kb。</p><h2 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a><a href="https://composition-api.vuejs.org/api.html">Composition API</a></h2><p>vue2百分之九十的代码在vue3是不受影响的。<code>Composition API</code>可以理解为一个新添加的API，它不影响对其他功能的使用。<br>它还可以与现有的逻辑一起使用。<br>抽离公共逻辑的时候，在vue2里用<code>mixins</code>，但是在vue3里就不要使用了，尽量使用<code>Composition API</code>。<br>其核心的api有：<br>·   <a href="">reactive</a><br>·   <a href="https://composition-api.vuejs.org/api.html#ref">ref</a><br>·   <a href="https://composition-api.vuejs.org/api.html#computed">computed</a><br>·   <a href="https://composition-api.vuejs.org/api.html#readonly">readonly</a><br>·   <a href="https://composition-api.vuejs.org/api.html#watchEffect">watchEffect</a><br>·   <a href="https://composition-api.vuejs.org/api.html#watch">watch</a><br>再加一个<a href="https://composition-api.vuejs.org/api.html#lifecycle-hooks">Lifecycle Hooks</a><br>其他的一些是一些工具函数，类似于<code>Loadsh</code>。</p><h2 id="Fragments-（碎片）"><a href="#Fragments-（碎片）" class="headerlink" title="Fragments （碎片）"></a>Fragments （碎片）</h2><p>这个功能让我们不用在用一个div把文件包裹起来，我们的模板可以只是一个纯文字，也可以是多个节点，它会自动变成碎片。<br>如果是渲染函数，也可以直接返回一个数组，也会自动变成一个碎片。</p><h2 id=""><a href="#" class="headerlink" title="&lt;Teleoirt&gt;"></a><code>&lt;Teleoirt&gt;</code></h2><p>对标react的<Portal>,它可以接收一个disable的参数，如果disable的话，就会将本来应该传送出去的东西，<br>挪回来，放到原来的渲染树里面。主要是用于一些响应式的设计。</p><h2 id="-1"><a href="#-1" class="headerlink" title="&lt;Suspense&gt;"></a><code>&lt;Suspense&gt;</code></h2><p>它会在嵌套树中等待嵌套异步依赖项。也就是说，它会在一个嵌套的组件树，渲染到一个屏幕上之前，先在内存中进行渲染，<br>在渲染的过程中，会记录所有存在异步依赖的组件，它只有在所有的异步依赖组件都resolve之后，才会把整个树渲染到DOM。<br>如果你的组件里有一个 async setup()的函数，这个组件就会被看成一个异步组件。<br>这样在一定程度上，实现了一个嵌套的异步调度。</p><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>vue3用TS进行重写了，但不代表我们一定得用TS进行开发，我们用TS或者JS都能在开发的时候，获得类型声明，或者引入的自动补全。<br>用了TS，也会有更多的好处，比如有更强的静态类型检测。vue3也有TSX的支持。</p><h2 id="自定义渲染器API-Custom-Renderer-API"><a href="#自定义渲染器API-Custom-Renderer-API" class="headerlink" title="自定义渲染器API(Custom Renderer API)"></a>自定义渲染器API(Custom Renderer API)</h2><p>这个在vue2里可以通过一个非暴露的API进行实现,但是会产生一些依赖上同步的问题。<br>在vue3里变成了一个普通的API,充分暴露给了用户。</p><blockquote><p>扩展：<a href="https://alligator.io/vuejs/custom-component-renderers/">Vue.js自定义组件渲染器</a><br><a href="https://vugel.planning.nl/"><code>Vugel</code></a></p></blockquote><h2 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a><a href="https://github.com/vuejs/vite">Vite</a></h2><p>可以看成一个小的HTTP服务器。<br>他可以直接引入一个script:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>这样可以直接不用打包，用原生的ES6 import：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">import &#123; createApp &#125; from &#x27;vue&#x27;<br>import Comp from &#x27;./Comp.vue&#x27;<br><br>createApp(Comp).mount(&#x27;#app&#x27;)<br></code></pre></div></td></tr></table></figure><p>这样它就会去服务器上请求对于的Vue文件，然后编译成javaScript发回去。<br>这个东西没有打包，没有编译，支持热更新。这个热更新请求哪个文件，哪个文件才会去打包。<br>而且浏览器会帮我们做缓存，感觉这个挺不错的。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>但满目京尘，东风竟日吹露桃。<br>「忆旧游·记愁横浅黛」<br>周邦彦</p>]]></content>
    
    
    
    <tags>
      
      <tag>VUE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现简单的koa</title>
    <link href="/2020/04/07/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84koa/"/>
    <url>/2020/04/07/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84koa/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>贴一波官网<a href="https://koa.bootcss.com/">koa</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>koa 通过async函数帮助我们避免了回调函数。他的源码都是用类写的，基于http模块，<br>它的源码只有4个文件，分别是：<br><code>application.js</code> : 应用入口，核心文件<br><code> context.js</code> ： 上下文，主要为辅助方法<br><code>request.js</code> ： 专门对应于请求<br><code> response.js</code> ： 专门对应响应</p><h3 id="如何用"><a href="#如何用" class="headerlink" title="如何用"></a>如何用</h3><p>需要先引入koa,它会返回一个类,koa基于原生的node方法封装了request,和response。<br>koa 怕用户还要区分原生的req和res，与koa自己封装的封装了request,和response。<br>用 ctx代理了原生和koa封装的方法。这样就非常方便了。如我们要取路径：</p><div class="hljs code-wrapper"><pre><code class="hljs">ctx.request.path</code></pre></div><p> 这样子不太方便，直接下面这样就行了</p><div class="hljs code-wrapper"><pre><code class="hljs">   ctx.path</code></pre></div><p> koa核心用法</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const Koa = require(&#x27;koa&#x27;);<br><br>const app =  new Koa();<br><br>app.use((ctx,next) =&gt; &#123;<br>  ctx.body = &quot;hello!&quot;;<br>&#125;)<br><br>app.listen(3000);<br></code></pre></div></td></tr></table></figure><p>koa帮我们解决了很多恶心的事，比如：<br>之前不能直接返回对象，现在只要：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">ctx.body = &#123;obj:&quot;water&quot;&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>注意：koa不建议绕过response，应该避免使用以下node属性：<br>res.statusCode res.writeHead() res.write() res.end()</strong></p></blockquote><h2 id="构建自己的koa"><a href="#构建自己的koa" class="headerlink" title="构建自己的koa"></a>构建自己的koa</h2><p>在你的工作目录下创建，如下结构：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">|-koa<br>|-server.js<br>|-koa<br>    |-application.js<br>    |-context.js<br>    |-request.js<br>    |-response.js<br></code></pre></div></td></tr></table></figure><p>为了先实现简单点,我们先用点原生的方法作为过渡，在server.js里写入以下代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const Koa = require(&#x27;./koa/application&#x27;);<br><br>let app = new Koa();<br><br>app.use((req, res) =&gt; &#123;<br>  res.end(&#x27;hello&#x27;);<br>&#125;)<br><br>app.listen(2000);<br></code></pre></div></td></tr></table></figure><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>接着我们需要导出一个Koa类，源码里面默认叫<code>Application</code>。<br>然后添加两个方法，listen是监听一个端口号，use是存了一个函数，当请求到来的时候执行，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">class Application&#123;<br>  use()&#123; // 用来注册方法<br><br>  &#125;<br>  listen(..args) &#123; // 用来监听端口<br><br>  &#125;<br>&#125;<br><br>module.exports = Application;<br></code></pre></div></td></tr></table></figure><h4 id="listen-use"><a href="#listen-use" class="headerlink" title="listen &amp;&amp; use"></a>listen &amp;&amp; use</h4><p>用http模块创建监听方法：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const http = require(&#x27;http&#x27;);<br><br>class Application&#123;<br>  use(fn)&#123;<br><br>  &#125;<br>  handleRequest(req, res) &#123;<br><br>  &#125;<br>  listen(...args) &#123;<br>    let server = http.createServer(this.handleRequest.bind(this));<br>    server.listen(...args);<br>  &#125;<br>&#125;<br><br>module.exports = Application;<br></code></pre></div></td></tr></table></figure><p>把handleRequest拿出去用来接收use的方法，接着将fn放到handleRequest里面执行：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const http = require(&#x27;http&#x27;);<br><br>class Application&#123;<br>  use(fn)&#123;<br>    this.fn = fn;<br>  &#125; <br>  handleRequest(req, res) &#123;<br>    this.fn(req, res);<br>  &#125;<br>  listen(...args) &#123;<br>    let server = http.createServer(this.handleRequest.bind(this));<br>    server.listen(...args);<br>  &#125;<br>&#125;<br><br>module.exports = Application;<br></code></pre></div></td></tr></table></figure><p>这样就实现了一个简单的功能。我们用<a href="https://www.npmjs.com/package/nodemon">nodemon</a>跑一下，在浏览器就能看到结果。</p><blockquote><p>全局安装nodemon:<br>npm install -g nodemon<br>或者安装为开发依赖<br>npm install –save-dev nodemon</p></blockquote><h3 id="向Koa靠拢"><a href="#向Koa靠拢" class="headerlink" title="向Koa靠拢"></a>向Koa靠拢</h3><p>koa没有实现res和req，只有一个ctx,我们需要封装request和response对象到ctx上，先修改一下server.js：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./koa/application&#x27;</span>);<br><br><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">ctx</span>) =&gt;</span> &#123;<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">2000</span>);<br></code></pre></div></td></tr></table></figure><p>接下来我们先来用上其他的文件，把对应的功能放到对应的文件，然后引入到application.js,<br>并且将引入的对象放到this上，为了不破坏原有的方法，并且方便扩展，使用<code>Object.create()</code>创建对象：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">// context.js<br>const context = &#123;<br>&#125;<br>module.exports = context;<br></code></pre></div></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">// response.js<br>const response = &#123;<br>&#125;<br>module.exports = response;<br></code></pre></div></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">// request.js<br>const request = &#123;<br><br>&#125;<br>module.exports = request;<br></code></pre></div></td></tr></table></figure><p>在构造方法上赋值：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const http = require(&#x27;http&#x27;);<br><br>const context = require(&#x27;./context&#x27;);<br>const response = require(&#x27;./response&#x27;);<br>const request = require(&#x27;./request&#x27;);<br><br>class Application&#123;<br>  constructor() &#123;<br>    this.context = context;<br>    this.response = response;<br>    this.request = request;<br>  &#125;<br>  use(fn)&#123;<br>    this.fn = fn;<br>  &#125; <br>  handleRequest(req, res) &#123;<br>    this.fn(req, res);<br>  &#125;<br>  listen(...args) &#123;<br>    let server = http.createServer(this.handleRequest.bind(this));<br>    server.listen(...args);<br>  &#125;<br>&#125;<br>module.exports = Application;<br></code></pre></div></td></tr></table></figure><p>现在就需要变化fn()那边的req和res,将其变为ctx,ctx整合了req(原生),res(原生),request(自己的),response(自己的)。<br>我们先创建一个函数，来整合四个属性。：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const http = require(&#x27;http&#x27;);<br><br>const context = require(&#x27;./context&#x27;);<br>const response = require(&#x27;./response&#x27;);<br>const request = require(&#x27;./request&#x27;);<br><br>class Application&#123;<br>  constructor() &#123;<br>    this.context = context;<br>    this.response = response;<br>    this.request = request;<br>  &#125;<br>  use(fn)&#123;<br>    this.fn = fn;<br>  &#125;<br>  createContext(req, res) &#123;<br>    let context = Object.create(this.context);<br>    context.req = req;<br>    context.res = res;<br>    context.request = Object.create(this.request);<br>    context.response = Object.create(this.response);<br>    return context;<br>  &#125;<br>  handleRequest(req, res) &#123;<br>    let ctx = this.createContext(req, res);<br>    this.fn(ctx);<br>  &#125;<br>  listen(...args) &#123;<br>    let server = http.createServer(this.handleRequest.bind(this));<br>    server.listen(...args);<br>  &#125;<br>&#125;<br><br>module.exports = Application;<br></code></pre></div></td></tr></table></figure><h4 id="增加url"><a href="#增加url" class="headerlink" title="增加url"></a>增加url</h4><p>现在来修改一下server.js文件，来尝试获取一下url:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const Koa = require(&#x27;./koa/application&#x27;);<br><br>let app = new Koa();<br>app.use((ctx) =&gt; &#123;<br>  console.log(ctx.req.url); // 原生<br>  console.log(ctx.request.req.url); // 原生<br>  console.log(ctx.request.url); // 自己的<br>  console.log(ctx.url); // 自己的<br>&#125;)<br><br>app.listen(2000);<br></code></pre></div></td></tr></table></figure><p>上面四个在原生的Koa是全部能打印出来的, 而我们的只能获取到第一个，接着我们在创建上下文的时候，<br>将原生的方法，赋值给我们自己的方法，来支持第二个打印：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">createContext(req, res) &#123;<br>  let context = Object.create(this.context);<br>  context.request = Object.create(this.request);<br>  context.response = Object.create(this.response);<br>  context.req = context.request.req =  req;<br>  context.res = context.response.res =  res;<br>  return context;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样子第二个也能打印出来了。接下来我们来解决ctx.request.url，我们先回到request.js文件，<br>里面的url需要动态获取，我们使用属性访问器的方式，来帮助我们处理复杂逻辑。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">// request.js<br>const request = &#123;<br>  get url() &#123; <br>    return this.req.url; // this === ctx.request<br>  &#125;<br>&#125;<br><br>module.exports = request;<br></code></pre></div></td></tr></table></figure><p>这样子取this.req.url时，取的就是ctx.request上的url,所以第三个也就可以了。<br><img src="/./console1.png" alt="/"></p><p>最后一个是最难的，我们取ctx.url,真正取的是ctx.request.url。这时候就可以做一个代理模式。<br>正好我们的context.js只做一件事：实现代理功能，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const context = &#123;&#125;<br><br>Object.defineProperty(context,&#x27;url&#x27; ,&#123;<br>  get() &#123;<br>    return this.request.url; // 这里的this指代的是自己创建的context<br>  &#125;<br>&#125;)<br><br>module.exports = context;<br></code></pre></div></td></tr></table></figure><h4 id="增加method"><a href="#增加method" class="headerlink" title="增加method"></a>增加method</h4><p>Koa源码是使用一个非标准且快废弃的属性<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__"><code>__defineGetter__</code></a>，所以我改用了<code>Object.defineProperty</code>。<br>如果我们现在把server.js 里面的url换成method呢？是不是还得写一个defineProperty，<br>所以我们要把defineProperty封装一下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const context = &#123;&#125;<br>function defineGetter(property, key) &#123;<br>  Object.defineProperty(context,key ,&#123;<br>    get() &#123;<br>      return this[property][key];<br>    &#125;<br>  &#125;)<br>&#125;<br><br>defineGetter(&#x27;request&#x27;, &#x27;url&#x27;);<br>defineGetter(&#x27;request&#x27;, &#x27;method&#x27;);<br><br>module.exports = context;<br></code></pre></div></td></tr></table></figure><p>我们还得在自己的request.js上添加一个获取method的方法：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const request = &#123;<br>  get url() &#123; <br>    return this.req.url; // this === ctx.request<br>  &#125;,<br>  get method() &#123;<br>    return this.req.method;<br>  &#125;<br>&#125;<br><br>module.exports = request;<br></code></pre></div></td></tr></table></figure><p>这样就能打印出method。<br><img src="/./console2.png" alt="console2"></p><p>为什么不在request.js上也封装方法呢？ 因为它是拿来扩展的，比如我们要增加一个path：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const url = require(&#x27;url&#x27;);<br>const request = &#123;<br>  get url() &#123; <br>    return this.req.url; // this === ctx.request<br>  &#125;,<br>  get method() &#123;<br>    return this.req.method;<br>  &#125;,<br>  get path()&#123;<br>    return url.parse(this.req.url).pathname;<br>  &#125;<br><br>&#125;<br><br>module.exports = request;<br></code></pre></div></td></tr></table></figure><p>然后在context.js里新增代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">defineGetter(&#x27;request&#x27;, &#x27;path&#x27;);<br></code></pre></div></td></tr></table></figure><p>这样就给自己的request扩展了个方法。</p><h3 id="ctx-body"><a href="#ctx-body" class="headerlink" title="ctx.body"></a>ctx.body</h3><p>接下来设置一下body属性，先修改一下server.js代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const Koa = require(&#x27;./koa/application&#x27;);<br><br>let app = new Koa();<br>app.use((ctx) =&gt; &#123;<br>  ctx.response.body = &#x27;hello&#x27;;<br>  console.log(ctx.body); <br>&#125;)<br><br>app.listen(2000);<br></code></pre></div></td></tr></table></figure><p>ctx代理了response方法，所以ctx.body就是ctx.response.body。<br>接下来需要在response.js里给body设置get和set方法：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const response = &#123;<br>  _body:&#x27;&#x27;,<br>  get body() &#123;<br>    return this._body;<br>  &#125;,<br>  set body(newValue) &#123;<br>    this._body = newValue;<br>  &#125;<br>&#125;<br><br>module.exports = response;<br></code></pre></div></td></tr></table></figure><p>然后在context.js里，再增加一行代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">defineGetter(&#x27;response&#x27;, &#x27;body&#x27;);<br></code></pre></div></td></tr></table></figure><p>这样就能打印出hello。</p><p>但是如果我们是赋值给ctx.body呢：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">app.use((ctx) =&gt; &#123;<br>  ctx.body = &#x27;hello&#x27;;<br>  console.log(ctx.response.body); <br>&#125;)<br></code></pre></div></td></tr></table></figure><p>要实现这样的效果，我们要给ctx.body设置的时候，也得走到response里去，<br>编辑context.js，新增加个set,随便修改个方法名：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const context = &#123;&#125;<br>function defineAgency(property, key) &#123;<br>  Object.defineProperty(context, key, &#123;<br>    get() &#123;<br>      return this[property][key];<br>    &#125;,<br>    set(newValue) &#123;<br>      this[property][key] = newValue;<br>    &#125;<br>  &#125;)<br>&#125;<br><br>defineAgency(&#x27;request&#x27;, &#x27;url&#x27;);<br>defineAgency(&#x27;request&#x27;, &#x27;method&#x27;);<br>defineAgency(&#x27;request&#x27;, &#x27;path&#x27;);<br>defineAgency(&#x27;response&#x27;, &#x27;body&#x27;);<br><br>module.exports = context;<br></code></pre></div></td></tr></table></figure><p>这样就能在ctx.body上赋值了。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>app.use里，不仅有ctx,而且还有next，如果我们写了多个use,需要调一下next(),来执行下一个方法。<br>这里就是洋葱模型。在koa里有个compose方法，会将所有的方法组合成一个大的promise。</p><h4 id="洋葱模型"><a href="#洋葱模型" class="headerlink" title="洋葱模型"></a>洋葱模型</h4><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const Koa = require(&#x27;koa&#x27;);<br><br>const app =  new Koa();<br><br>app.use((ctx,next) =&gt; &#123;<br>  console.log(1);<br>  next();<br>  console.log(4);<br>&#125;);<br><br>app.use((ctx,next) =&gt; &#123;<br>  console.log(2);<br>  next();<br>  console.log(5);<br>&#125;);<br><br>app.use((ctx,next) =&gt; &#123;<br>  console.log(3);<br>  next();<br>  console.log(6);<br>&#125;);<br><br>app.listen(3000);<br></code></pre></div></td></tr></table></figure><p>执行顺序就是<br><img src="/./ycmx.png" alt="洋葱模型"></p><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>中间件可以理解为use方法，它可以决定是否向下执行。在执行异步的时候，可以使用async + await语法。</p><blockquote><p>写koa一定得在next前面加await要不就加return,不然它不会等待里面的函数执行完。</p></blockquote><p>接下来我们的use就需要将方法存起来了，方便后期执行。然后在handleRequest方法，等所有promise执行完，<br>将结果返回去。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">// application.js<br>const http = require(&#x27;http&#x27;);<br><br>const context = require(&#x27;./context&#x27;);<br>const response = require(&#x27;./response&#x27;);<br>const request = require(&#x27;./request&#x27;);<br><br>class Application&#123;<br>  constructor() &#123;<br>    this.context = context;<br>    this.response = response;<br>    this.request = request;<br>    this.middlewares = []; // +++++<br>  &#125;<br>  use(fn)&#123;<br>    this.middlewares.push(fn);  // +++++<br>  &#125;<br>  createContext(req, res) &#123;<br>    let context = Object.create(this.context);<br>    context.request = Object.create(this.request);<br>    context.response = Object.create(this.response);<br>    context.req = context.request.req =  req;<br>    context.res = context.response.res =  res;<br>    return context;<br>  &#125;<br>  handleRequest(req, res) &#123;<br>    let ctx = this.createContext(req, res);<br>    this.compose(ctx).then(() =&gt; &#123;      // +++++<br>      let _body = ctx.body;             // +++++<br>      res.end(_body);                   // +++++<br>    &#125;);                                 // +++++<br>  &#125;<br>  listen(...args) &#123;<br>    let server = http.createServer(this.handleRequest.bind(this));<br>    server.listen(...args);<br>  &#125;<br>&#125;<br><br>module.exports = Application;<br></code></pre></div></td></tr></table></figure><h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>这里面最主要的就是this.compose方法。它返回的就是一个promise。<br>我们先来修改一下server.js，让它来检测我们的compose:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const Koa = require(&#x27;./koa/application&#x27;);<br><br>const app =  new Koa();<br><br>const my = () =&gt; &#123;<br>  return new Promise((resolve, reject) =&gt; &#123;<br>    setTimeout(() =&gt; &#123;<br>      console.log(&quot;my&quot;);<br>      resolve();<br>    &#125;, 1000);<br>  &#125;);<br>&#125;;<br><br>app.use(async(ctx,next) =&gt; &#123;<br>  console.log(1);<br>  await next();<br>  console.log(4);<br>&#125;);<br><br>app.use(async(ctx,next) =&gt; &#123;<br>  console.log(2);<br>  await my();<br>  next();<br>  console.log(5);<br>&#125;);<br><br>app.use((ctx,next) =&gt; &#123;<br>  console.log(3);<br>  next();<br>  console.log(6);<br>&#125;);<br><br>app.listen(3000);<br></code></pre></div></td></tr></table></figure><p>先取出第一个函数，执行，然后派发给下一个函数，我们先直接写,不考虑promise。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">compose(ctx) &#123;<br>  function dispatch(index) &#123;<br>   let middle =  this.middlewares[index];<br>   middle(ctx,()=&gt; dispatch(index+1)); // 这个箭头函数指的就是下一个函数<br>  &#125;<br>  return dispatch(0)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在有可能这个方法是一个普通函数。如果它不是个promise，我们也把他变成promise。<br>这样保证方法执行完，返回一个promise.并且我们再加上终止条件。如果终止了直接返回一个成功的promise。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">compose(ctx) &#123;<br>  let dispatch = (index) =&gt; &#123;<br>    if (index == this.middlewares.length) return Promise.resolve();// 返回一个成功的Promise<br>    let middle = this.middlewares[index]; // 拿出第一个use 让其执行<br>    return Promise.resolve(middle(ctx, () =&gt; dispatch(index + 1))); //  执行的时候传递ctx,next方法<br>  &#125;<br>  return dispatch(0);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样我们在server.js运行，就能看到跟源码一样的结果。核心逻辑只有3行。<br>但是我们的代码还不够健壮，我们接下来要防止next调用多次，造成代码顺序混乱。<br>然后再加上错误处理，并且将错误用事件抛出，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const http = require(&#x27;http&#x27;);<br>const EventEmitter = require(&#x27;events&#x27;);<br><br>const context = require(&#x27;./context&#x27;);<br>const response = require(&#x27;./response&#x27;);<br>const request = require(&#x27;./request&#x27;);<br><br>class Application extends EventEmitter &#123;<br>  constructor() &#123;<br>    super();<br>    this.context = context;<br>    this.response = response;<br>    this.request = request;<br>    this.middlewares = [];<br>  &#125;<br>  use(fn) &#123;<br>    this.middlewares.push(fn);<br>  &#125;<br>  createContext(req, res) &#123;<br>    let context = Object.create(this.context);<br>    context.request = Object.create(this.request);<br>    context.response = Object.create(this.response);<br>    context.req = context.request.req = req;<br>    context.res = context.response.res = res;<br>    return context;<br>  &#125;<br>  compose(ctx) &#123;<br>    let i = -1<br>    let dispatch = (index) =&gt; &#123;<br>      if (index &lt;= i) return Promise.reject(new Error(&#x27;next() called multiple times&#x27;))<br>      i = index<br>      if (index == this.middlewares.length) return Promise.resolve();// 返回一个成功的Promise<br>      let middle = this.middlewares[index]; // 拿出第一个use 让其执行<br>     try &#123;<br>      return Promise.resolve(middle(ctx, () =&gt; dispatch(index + 1))); //  执行的时候传递ctx,next方法<br>     &#125; catch (err)&#123;<br>      return Promise.reject(err)<br>     &#125;<br>    &#125;<br>    return dispatch(0);<br>  &#125;<br>  handleRequest(req, res) &#123;<br>    let ctx = this.createContext(req, res);<br>    this.compose(ctx).then(() =&gt; &#123;<br>      let _body = ctx.body;<br>      res.end(_body);<br>    &#125;).catch(err =&gt; &#123;<br>      this.emit(&#x27;error&#x27;, err);<br>    &#125;);<br>  &#125;<br>  listen(...args) &#123;<br>    let server = http.createServer(this.handleRequest.bind(this));<br>    server.listen(...args);<br>  &#125;<br>&#125;<br><br>module.exports = Application;<br></code></pre></div></td></tr></table></figure><p>最后我们来让body支持一下对象,并且可以返回文件，它需要引入Stream模块。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const http = require(&#x27;http&#x27;);<br>const EventEmitter = require(&#x27;events&#x27;);<br>let Stream = require(&#x27;stream&#x27;);<br><br>const context = require(&#x27;./context&#x27;);<br>const response = require(&#x27;./response&#x27;);<br>const request = require(&#x27;./request&#x27;);<br><br>class Application extends EventEmitter &#123;<br>  constructor() &#123;<br>    super();<br>    this.context = context;<br>    this.response = response;<br>    this.request = request;<br>    this.middlewares = [];<br>  &#125;<br>  use(fn) &#123;<br>    this.middlewares.push(fn);<br>  &#125;<br>  createContext(req, res) &#123;<br>    let context = Object.create(this.context);<br>    context.request = Object.create(this.request);<br>    context.response = Object.create(this.response);<br>    context.req = context.request.req = req;<br>    context.res = context.response.res = res;<br>    return context;<br>  &#125;<br>  compose(ctx) &#123;<br>    let i = -1<br>    let dispatch = (index) =&gt; &#123;<br>      if (index &lt;= i) return Promise.reject(new Error(&#x27;next() called multiple times&#x27;))<br>      i = index<br>      if (index == this.middlewares.length) return Promise.resolve();// 返回一个成功的Promise<br>      let middle = this.middlewares[index]; // 拿出第一个use 让其执行<br>     try &#123;<br>      return Promise.resolve(middle(ctx, () =&gt; dispatch(index + 1))); //  执行的时候传递ctx,next方法<br>     &#125; catch (err)&#123;<br>      return Promise.reject(err)<br>     &#125;<br>    &#125;<br>    return dispatch(0);<br>  &#125;<br>  handleRequest(req, res) &#123;<br>    let ctx = this.createContext(req, res);<br>    this.compose(ctx).then(() =&gt; &#123;<br>      let _body = ctx.body;<br>      if(_body instanceof Stream)&#123;<br>          return _body.pipe(res);<br>      &#125;else if(typeof _body === &#x27;object&#x27;)&#123;<br>          return res.end(JSON.stringify(_body));<br>      &#125;else&#123;<br>          return res.end(_body);<br>      &#125;<br>    &#125;).catch(err =&gt; &#123;<br>      this.emit(&#x27;error&#x27;, err);<br>    &#125;);<br>  &#125;<br>  listen(...args) &#123;<br>    let server = http.createServer(this.handleRequest.bind(this));<br>    server.listen(...args);<br>  &#125;<br>&#125;<br><br>module.exports = Application;<br></code></pre></div></td></tr></table></figure><p>这样我们就实现了koa 90%的方法了。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>怪来一夜蛙声歇，又作东风十日寒。<br>「绝句」<br>吴涛</p>]]></content>
    
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于node的fs实现可读流和可写流</title>
    <link href="/2020/03/29/%E5%9F%BA%E4%BA%8Enode%E7%9A%84fs%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%AF%BB%E6%B5%81%E5%92%8C%E5%8F%AF%E5%86%99%E6%B5%81/"/>
    <url>/2020/03/29/%E5%9F%BA%E4%BA%8Enode%E7%9A%84fs%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%AF%BB%E6%B5%81%E5%92%8C%E5%8F%AF%E5%86%99%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>确保您有node.js的环境。</p><h2 id="可读流（ReadStream）"><a href="#可读流（ReadStream）" class="headerlink" title="可读流（ReadStream）"></a>可读流（ReadStream）</h2><p>先来看看核心方法如何使用，这也是我们开发中真正使用的。在工作目录下先创建一个<code>1.txt</code>,写入 你好<br>然后创建一个<code>stream.js</code>,内容如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">let fs = require(&#x27;fs&#x27;);<br>let path = require(&#x27;path&#x27;);<br><br>let rs = fs.createReadStream(path.resolve(__dirname,&#x27;1.txt&#x27;))<br>let arr = [];<br><br>rs.on(&#x27;data&#x27;,function(data)&#123; // buffer<br>    arr.push(data);<br>&#125;)<br>rs.on(&#x27;end&#x27;,function()&#123;<br>   console.log(Buffer.concat(arr).toString());<br>&#125;);<br><br></code></pre></div></td></tr></table></figure><p>上面代码中我们创建了一个arr数组来存我们每次读取的二进制数据。其形式为buffer。<br>其内部每次读取到数据就会触发我们监听的<code>data</code>事件。然后把数据返还给我们，而<code>end</code>事件是结束时触发的。两者都是固定的。<br>上面调用<code>fs.createReadStream()</code> 默认是流是暂停的，只有我们手动监听<code>data</code>事件的时候才会进行数据读取。</p><blockquote><p>内部触发事件具体看<a href="http://nodejs.cn/api/fs.html#fs_class_fs_readstream">官方文档</a></p></blockquote><h3 id="可传的参数"><a href="#可传的参数" class="headerlink" title="可传的参数"></a>可传的参数</h3><p><code>fs.createReadStream(path，[options])</code>的第二个参数允许我们进行传参，我们先来了解一下各个参数的作用。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">let rs = fs.createReadStream(&#x27;./1.txt&#x27;,&#123;<br>    flags:&#x27;r&#x27;, // 当前要做什么操作，具体可以看下面的文件系统标志<br>    encoding:null, // 默认是buffer<br>    highWaterMark:2,// 内部会创建 64k大的buffer<br>    mode:438,// 文件的权限 438为8进制，换成二进制为110110110<br>    autoClose:true, //默认为true ,在`error`或`end` 事件时，文件描述符会自动关闭。<br>    start:0,<br>    end:6 // start 和 end 就是读取一定范围的字节。<br>&#125;);<br></code></pre></div></td></tr></table></figure><ol><li><code>flags</code> 具体要进行的操作，如读取 <code>r</code> 或者写入 <code>w</code>。 默认 r</li><li><code>encoding</code>  其可以是 Buffer 接受的任何一种字符编码。 默认 null</li><li><code>fd</code> 如果指定，其内部将会忽略path参数，并使用指定的文件描述符。 默认为 null</li><li><code>mode</code> 文件的权限，跟linux一样，4-&gt;可读 2-&gt;可写 1-&gt;可执行， 默认为 0o666或者438</li><li><code>autoClose</code> 是否在触发error或者end事件时自动关闭文件。 默认为 true</li><li><code>emitClose</code> 默认情况下，流在销毁后将不会触发 ‘close’ 事件。更改为true可以更改此行为。 默认为 false</li><li><code>start end</code> 设置读取的范围。默认读取全部内容。</li><li><code>highWaterMark</code> 默认每次读取64K，内部创建64K的缓冲区（buffer）。 默认为 64*1024</li></ol><blockquote><p>注意: <em>文件写入时。如果文件不存在则创建文件，如果文件已存在则截断文件。</em><br><em>文件在读取时。如果文件不存在，则出现异常。</em></p></blockquote><h3 id="ReadStream-js"><a href="#ReadStream-js" class="headerlink" title="ReadStream.js"></a>ReadStream.js</h3><p>我们在工作目录创建文件 <code>ReadStream.js</code>,来写我们自己的可读流。<br>我们要先明确内部的流在创建的时候是暂停的。就跟我们的龙头一样。data事件就是我们的开关。<br>其次内部为了降低耦合，用了发布订阅。<br>我们首先要改一下stream.js,来用上我们自己的ReadStream。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const fs = require(&#x27;fs&#x27;);<br>let ReadStream = require(&#x27;./ReadStream&#x27;);<br>let rs = new ReadStream(&#x27;./1.txt&#x27;,&#123;<br>    flags:&#x27;r&#x27;, // 当前要做什么操作，具体可以看下面的文件系统标志<br>    encoding:null, // 默认是buffer<br>    highWaterMark:2,// 内部会创建 64k大的buffer<br>    mode:438,// 文件的权限 438为8进制，换成二进制为110110110<br>    autoClose:true, //默认为true ,在`error`或`end` 事件时，文件描述符会自动关闭。<br>    start:0,<br>    end:6 // start 和 end 就是读取一定范围的字节。<br>&#125;);<br>rs.on(&#x27;open&#x27;,function(fd)&#123;<br>    console.log(&#x27;文件打开触发open事件&#x27;,fd)<br>&#125;);<br>let arr = [];<br>rs.on(&#x27;data&#x27;,function(data)&#123; // 每次读取到的结果<br>    console.log(data);<br>    arr.push(data); // 存起来<br>&#125;)<br>rs.on(&#x27;end&#x27;,function()&#123;<br>    console.log(&#x27;文件读取完毕&#x27;)<br>     console.log(Buffer.concat(arr).toString());<br>&#125;);<br>rs.on(&#x27;close&#x27;,function()&#123;<br>    console.log(&#x27;文件关闭&#x27;)<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>接下来就可以创建我们自己的ReadStream了，内部会基于node.js的<a href="http://nodejs.cn/api/events.html">events</a>和<a href="http://nodejs.cn/api/fs.html">fs</a>模块。<br>先引入两个模块，然后我们的类要继承events，接着把常用的可选参数传入。<br>读取的第一步就是要将文件打开，借助fs模块我们可以打开文件，并获得文件标识符，以方便下一步动作。<br>我们用一个<code>flowing</code>参数标识流是否是暂停的。并且在注册了<code>data</code>事件之后，将其打开。<br>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const EventEmitter = require(&#x27;events&#x27;);<br>const fs = require(&#x27;fs&#x27;);<br>class ReadStream extends EventEmitter&#123;<br>  constructor(path, options = &#123;&#125;) &#123;<br>    super();<br>    this.path = path;<br>    this.flags = options.flags || &#x27;r&#x27;;<br>    this.encoding = options.encoding || null;<br>    this.highWaterMark = options.highWaterMark || 64*1024;<br>    this.mode = options.mode || 438;<br>    this.autoClose = options.autoClose || true;<br>    this.start = options.start || 0;<br>    this.end = options.end;<br><br>    this.flowing = null; // 默认是暂停模式<br>    this.offset = 0; // 读取文件的偏移量<br>    this.open(); // 打开文件 (异步)<br>    this.on(&#x27;newListener&#x27;,(type) =&gt; &#123;<br>    console.log(type);<br>     if(type === &#x27;data&#x27;) &#123;<br>      this.flowing = true;<br>      this.read();<br>     &#125;<br>    &#125;)<br>  &#125;<br>  read() &#123;<br>    console.log(this.fd);  // undefined<br>   &#125;<br>  open() &#123;<br>    fs.open(this.path, this.flags, (err,fd) =&gt;&#123;<br>      this.fd = fd;<br>      this.emit(&#x27;open&#x27;, this.fd);<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的<a href="http://nodejs.cn/api/events.html#events_event_newlistener">newListener</a>事件,为其注册监听器，会传递事件名称和对要添加的监听器的引用。<br>type打印内容如下：<br><img src="/./newListener.png" alt="newListener"></p><p>在我们打开文件要对其进行读取的时候，发现文件打开操作是异步的，而读取操作是同步的。文件还没打开就去读取是不得行的。<br>所以在<code>read()</code>的时候，this.fd是undefined。我们现在要解决的就是让<code>read()</code>比<code>open()</code>慢。<br>process.nextTick是不行的，它指定的任务会发生在所有异步任务之前。<br>解决方法是给<code>read()</code>注册一个open监听器，文件描述符获取到后触发这个open事件。<br>然后再去再次调用<code>read()</code>，这样就能在<code>read()</code>里获取到this.fd。具体代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">read() &#123;<br>    if(typeof this.fd !== &quot;number&quot;) &#123; // 因为read 比open先调用<br>      return this.once(&#x27;open&#x27;, this.read); // 先把read方法存起来， 等open后再次调用。<br>    &#125;<br>    console.log(this.fd);<br>  &#125;<br>  open() &#123;<br>    fs.open(this.path, this.flags, (err,fd) =&gt;&#123;<br>      this.fd = fd;<br>      this.emit(&#x27;open&#x27;, this.fd);<br>    &#125;)<br>  &#125;<br></code></pre></div></td></tr></table></figure><p>输出如下：<br><img src="/./fd.png" alt="fd"></p><p>这样就能获取到文件描述符，接下来就是进行连续读的操作，read()代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">read() &#123;<br>   if(typeof this.fd !== &quot;number&quot;) &#123; // 因为read 比open先调用<br>     return this.once(&#x27;open&#x27;, this.read); // 先把read方法存起来， 等open后再次调用。<br>   &#125;<br>   let buffer = Buffer.alloc(this.highWaterMark); // 每次读多少个<br><br>   fs.read(this.fd, buffer, 0, this.highWaterMark, this.offset, (err, bytesRead) =&gt; &#123;<br>     this.offset += bytesRead; // 每次往前走<br>     if(bytesRead &gt; 0) &#123; //判断是否读完<br>     this.emit(&#x27;data&#x27;, buffer); // 如果读取到了内容就触发data事件<br>     this.read();<br>     &#125; else &#123;<br>       this.emit(&#x27;end&#x27;);<br>     &#125;<br>   &#125;)<br> &#125;<br></code></pre></div></td></tr></table></figure><p>fs.read的各个参数分别是：<br><code>this.fd</code>: 要操作的文件标识符<br><code>buffer</code>: 给一个多大的缓冲区<br><code>0</code>：从buffer什么位置开始填进去<br><code>this.highWaterMark</code>： 每次读多少<br><code>this.offset</code>：每次写入文件的偏移量<br>然后我们每次读取到数据，就去触发data事件，然后把读到的buffer传递出去。如果bytesRead小于或等于零，表示读完了直接触发end事件就可以了。<br>我们还需要进一步完善我们的读取操作。把我们的end和start参数用上，并且添加close和控制流的方法：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const EventEmitter = require(&#x27;events&#x27;);<br>const fs = require(&#x27;fs&#x27;);<br>class ReadStream extends EventEmitter&#123;<br>  constructor(path, options = &#123;&#125;) &#123;<br>    super();<br>    this.path = path;<br>    this.flags = options.flags || &#x27;r&#x27;;<br>    this.encoding = options.encoding || null;<br>    this.highWaterMark = options.highWaterMark || 64*1024;<br>    this.mode = options.mode || 438;<br>    this.autoClose = options.autoClose || true;<br>    this.start = options.start || 0;<br>    this.end = options.end;<br><br>    this.flowing = null; // 默认是暂停模式<br>    this.offset = 0; //偏移量<br>    this.open(); // 打开文件 (异步)<br>    this.on(&#x27;newListener&#x27;,(type) =&gt; &#123;<br>     if(type === &#x27;data&#x27;) &#123;<br>      this.flowing = true;<br>      this.read();<br>     &#125;<br>    &#125;)<br>  &#125;<br>  read() &#123;<br>    if(typeof this.fd !== &quot;number&quot;) &#123; // 因为read 比open先调用<br>      return this.once(&#x27;open&#x27;, this.read); // 先把read方法存起来， 等open后再次调用。<br>    &#125;<br><br>    let howMuchToRead = this.end<br>    ? Math.min(this.highWaterMark, this.end-this.start + 1 - this.offset)<br>    : this.highWaterMark;<br>    let buffer = Buffer.alloc(howMuchToRead);<br><br>    fs.read(this.fd, buffer, 0, howMuchToRead, this.offset, (err, bytesRead) =&gt; &#123;<br>      this.offset += bytesRead;<br>      if(bytesRead &gt; 0) &#123;<br>      this.emit(&#x27;data&#x27;, buffer); // 如果读取到了内容就触发data事件<br>      this.flowing &amp;&amp; this.read();<br>      &#125; else &#123;<br>        this.emit(&#x27;end&#x27;);<br>        this.close();<br>      &#125;<br>    &#125;)<br>  &#125;<br>  close() &#123;<br>    if(this.autoClose) &#123;<br>      fs.close(this.fd, () =&gt; &#123;<br>        this.emit(&#x27;close&#x27;);<br>      &#125;)<br>    &#125;<br>  &#125;<br>  open() &#123;<br>    fs.open(this.path, this.flags, (err,fd) =&gt;&#123;<br>      this.fd = fd;<br>      this.emit(&#x27;open&#x27;, this.fd);<br>    &#125;)<br>  &#125;<br>  pause() &#123;<br>    this.flowing = false;<br>  &#125;<br>  resume() &#123;<br>    this.flowing = true;<br>    this.read();<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果我们传了end和start,我们就需要算出每次一共读几个，防止最后一次读取的时候超过end。<br>然后加上控制流的方法。还有条件。我们的可读流就完成了。</p><h2 id="可写流（writeStream）"><a href="#可写流（writeStream）" class="headerlink" title="可写流（writeStream）"></a>可写流（writeStream）</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>可写流最主要的就是 <code>write</code> 和 <code>end</code> 事件，一个是写入操作，一个是关闭操作。<br>我们先来实现一个写一点，等待写完，再次进行写的操作。这样可以节省内存占用。<br>创建一个write.js 文件用来写入我们的代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">let fs = require(&#x27;fs&#x27;);<br>let ws = fs.createWriteStream(&#x27;./1.txt&#x27;,&#123;<br>  highWaterMark:3 // 预计占用的内存<br>&#125;)<br>let index = 0;<br>function write() &#123;<br>  let flag = true;<br>  while(index &lt; 10 &amp;&amp; flag) &#123;<br>    flag = ws.write(index + &#x27;&#x27;); // 转换成 String<br>    index++;<br>  &#125;<br>  if(index &gt; 9) &#123;<br>    ws.end(); // 关闭文件 关闭可写流<br>  &#125;<br>&#125;<br>write();<br><br>ws.on(&#x27;drain&#x27;, function()&#123;<br>  console.log(&#x27;预计内存满了&#x27;);<br>  write();<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>highWaterMark参数表示预计占用的内存,默认为16K.<br>其内部在写入的个数达到了，且预计的大小被写入到文件后清空了，就会触发<code>drain</code>事件，<br>所以我们可以在<code>drain</code>事件里，再次调用write方法。输出内容如下：<br><img src="/./write1.png" alt="write1"></p><p>由于我们写入10个数，每次写3个，所以drain触发了3次。</p><blockquote><p><strong>注意：<br>由于内部不知道什么时候写完的，所以我们需要手动调用end事件。<br>可写流写入是数据只能是字符串或者Buffer。</strong></p></blockquote><h3 id="writeStream-js"><a href="#writeStream-js" class="headerlink" title="writeStream.js"></a>writeStream.js</h3><p>接下来创建自己的可写流，创建<code>writeStream.js</code>文件,改写write.js 内容如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">let fs = require(&#x27;fs&#x27;);<br>let WriteStream = require(&#x27;./writeStream&#x27;)<br>let ws = new WriteStream(&#x27;./1.txt&#x27;,&#123;<br>  highWaterMark:3,// 预期占用几个内存<br>  encoding:&#x27;utf8&#x27;,// 写入的编码<br>  start:0, // 从文件的第0个位置开始写入<br>  mode:438,<br>  flags:&#x27;w&#x27; // 默认操作是可写<br>&#125;)<br>let index = 0;<br>function write() &#123;<br>  let flag = true;<br>  while(index &lt; 10 &amp;&amp; flag) &#123;<br>    flag = ws.write(index + &#x27;&#x27;);<br>    console.log(flag)<br>    index++;<br>  &#125;<br>  if(index &gt; 9) &#123;<br>    ws.end(); // 关闭文件 关闭可写流<br>  &#125;<br>&#125;<br>write();<br><br>ws.on(&#x27;drain&#x27;, function()&#123;<br>  console.log(&#x27;预计内存满了&#x27;);<br>  write();<br>&#125;)<br>ws.on(&#x27;close&#x27;,function()&#123;<br>  console.log(&#x27;关闭了文件&#x27;);<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>刚开始的写法跟可读流是一样的，我们引入events模块，然后把参数在构造函数中赋值。可读流一创建就可以进行写的操作，<br>那么它在创建的时候肯定是打开了的，接下来先创建 open() write() end() 方法，内容如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const EventEmitter = require(&#x27;events&#x27;);<br>class WriteStream &#123;<br>  constructor(path, options = &#123;&#125;) &#123;<br>    super();<br>    this.path = path;<br>    this.highWaterMark = options.highWaterMark || 16 * 1024<br>    this.encoding = options.encoding || &#x27;utf8&#x27;;<br>    this.start = options.start || 0;<br>    this.mode = options.mode || 0o666;<br>    this.flags = options.flags || &#x27;w&#x27;;<br>    // 先打开文件<br>    this.open();<br>  &#125;<br>  open() &#123;<br><br>  &#125;<br>  write() &#123;<br><br>  &#125;<br>  end() &#123;<br>    <br>  &#125;<br>&#125;<br><br>module.exports = WriteStream;<br></code></pre></div></td></tr></table></figure><p>先完善我们的open()方法，用户会同步调用write方法，在取的时候并不一定能取到文件标识符，而且用户调用write方法时，<br>需要先判断当前是否正在写入，如果正在写入需要先放到缓存中，如果不是正在写入，需要真正的写入文件当中。<br>我们还需要创建几个变量，具体代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">class WriteStream &#123;<br>  constructor(path, options = &#123;&#125;) &#123;<br>    super();<br>    this.path = path;<br>    this.highWaterMark = options.highWaterMark || 16 * 1024<br>    this.encoding = options.encoding || &#x27;utf8&#x27;;<br>    this.start = options.start || 0;<br>    this.mode = options.mode || 0o666;<br>    this.flags = options.flags || &#x27;w&#x27;;<br>    // 先打开文件<br>    this.open();<br>    // 缓存区 <br>    this.cache = [];<br>    this.writing = false; // 判断是否正在被写入<br>    this.len = 0; // 缓存区的大小<br>    this.needDrain = false; // 是否触发drain事件<br>    this.offset = this.start; // offset 表示每次写入的偏移量<br>  &#125;<br>  open() &#123; // 先打开文件<br>    fs.open(this.path, this.flags, (err, fd) =&gt; &#123;<br>      this.fd = fd;<br>      this.emit(&#x27;open&#x27;, fd);<br>    &#125;)<br>  &#125;<br>  write() &#123;<br><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来完善write方法,第一个参数是写入的数据，第二个是编码没给用默认的编码，第三个是个callback。<br>我们首先要先判断，写入的数据是不是buffer,如果不是转换成buffer。接着统计写入数据的个数，<br>然后和highWaterMark比较，返回一个flag。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">write(chunk, encoding = this.encoding, callback) &#123;// 用户会同步的调用write方法<br>   chunk = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk); // 判断这个chunk 是不是buffer 如果不是buffer转化成buffer<br>   this.len += chunk.length; // 统计写入数据的个数<br>   let flag = this.len &lt; this.highWaterMark;<br>   return flag;<br> &#125;<br></code></pre></div></td></tr></table></figure><p>运行write.js文件，输出:</p><blockquote><p>true<br>true<br>false</p></blockquote><p>这样子是没错的，flag返回的是告知还有没有空间，我们的highWaterMark传入的是3，所以第三个写入满了，就返回了false。<br>这样我们可以得知，什么时候应该触发drain事件。然后我们需要将除了第一次数据真实写入，而其他都放到缓存中。<br>然后再去清空缓存队列，每次取第一个，进行真正的写入。而且每次调用的时候，还需要执行自己的成功操作，并且清空队列。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">write(chunk, encoding = this.encoding, callback) &#123;// 用户会同步的调用write方法<br>   chunk = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk); // 判断这个chunk 是不是buffer 如果不是buffer转化成buffer<br>   this.len += chunk.length; // 统计写入数据的个数<br>   let flag = this.len &lt; this.highWaterMark;<br>   this.needDrain = !flag; //相反操作<br>   if (this.writing) &#123; // 当前是否正在写入<br>     this.cache.push(&#123; // 将除了第一次真实的写入，其他都放到缓存中<br>       chunk,<br>       encoding,<br>       callback<br>     &#125;)<br>   &#125; else &#123;<br>     this.writing = true; // 标识是否正在写入<br>     this._write(chunk, encoding, () =&gt; &#123;<br>       callback &amp;&amp; callback(); // 先执行自己的成功操作<br>       this.clearBuffer(); // 再去清空队列中的第一个<br>     &#125;);// 真实像文件中写入<br>   &#125;<br>   return flag;<br> &#125;<br></code></pre></div></td></tr></table></figure><p>我们先来创建真正写入的核心方法_write,它获取this.fd，需要等待open事件触发，跟可读流一样。<br>接着进行文件的写入操作:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">// 核心的写入方法<br>_write(chunk, encoding, clearBuffer) &#123;<br>  if (typeof this.fd !== &#x27;number&#x27;) &#123; //  write方法相对于open 是先调用的<br>    return this.once(&#x27;open&#x27;, () =&gt; this._write(chunk, encoding, clearBuffer))<br>  &#125;<br>  fs.write(this.fd, chunk, 0, chunk.length, this.offset, (err, written) =&gt; &#123;<br>    // written 表示真实写入的个数<br>    this.offset += written; // 增加偏移量<br>    this.len -= written; // 减少缓存中的数据<br>    clearBuffer(); // 清空缓存<br>  &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>fs.write的各个参数分别是：<br><code>this.fd</code>: 要操作的文件标识符<br><code>chunk</code>: 写入的数据<br><code>chunk.length</code>: 读取buffer多少个字节<br><code>0</code>：0表示把数据的第0个位置开始写入<br><code>this.highWaterMark</code>： 每次读多少<br><code>this.offset</code>：每次写入文件的偏移量<br>接下来要写清空缓存中的方法，需要判断缓存中是否有数据，如果有就取出第一个进行写入，如果没有数据且this.needDrain为true，<br>就表示数据都被清空了，需要从新设置变量然后触发drain事件：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">clearBuffer() &#123;<br>   // 去缓存中取<br>   let obj = this.cache.shift();<br>   if (obj) &#123; // 需要写入<br>     this._write(obj.chunk, obj.encoding, () =&gt; &#123;<br>       obj.callback &amp;&amp; obj.callback();<br>       this.clearBuffer();<br>     &#125;);<br>   &#125; else &#123;<br>     if (this.needDrain) &#123;<br>       this.needDrain = false; // 下一次需要重新判断是否需要触发drain事件<br>       this.writing = false; //告诉下一次调用write 应该像文件中写入<br>       this.emit(&#x27;drain&#x27;);<br>     &#125;<br>   &#125;<br> &#125;<br></code></pre></div></td></tr></table></figure><p>这样我们的写入方法就完成了，再到write.js里run一下，内容是正确的，最后还需要完善close和end方法。<br>close比较简单直接调用fs的close方法就行了：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">close() &#123;<br>  fs.close(this.fd, () =&gt; &#123;<br>    this.emit(&#x27;close&#x27;)<br>  &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接着就是end方法，end方法可以传参，第一个是写入的内容，第二个是编码，<br>如果传递参数，我们需要先强制清空缓存，然后写入end方法的内容，接着再关闭文件,代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">end(chunk, encoding) &#123;  <br>  if (chunk) &#123;<br>    chunk = Buffer.isBuffer(chunk)?chunk:Buffer.from(chunk);<br>    return this.write(chunk, encoding, () =&gt; &#123;<br>      this.close()<br>    &#125;)<br>  &#125;<br>  this.close();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样我们就完成了可写流。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>错误之处留言告知，谢谢你！。</p><p>记得金銮同唱第，春风上国繁华。<br>「临江仙·记得金銮同唱第」<br>欧阳修</p>]]></content>
    
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10环境在node中使用RabbitMQ</title>
    <link href="/2020/03/13/%E5%9C%A8node%E4%B8%AD%E4%BD%BF%E7%94%A8RabbitMQ/"/>
    <url>/2020/03/13/%E5%9C%A8node%E4%B8%AD%E4%BD%BF%E7%94%A8RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>注意：本篇内容以官方文档为主线加个人理解和采坑</strong></p><h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><h3 id="在windows10上安装"><a href="#在windows10上安装" class="headerlink" title="在windows10上安装"></a>在windows10上安装</h3><p>注意：安装RabbitMQ要先安装<code>Erlang</code>编程语言。需要翻墙下载，不然很慢。</p><blockquote><p><a href="https://www.erlang.org/downloads">https://www.erlang.org/downloads</a></p></blockquote><p>安装完需要设置系统变量。</p><h4 id="可以从github-上下载："><a href="#可以从github-上下载：" class="headerlink" title="可以从github 上下载："></a>可以从github 上下载：</h4><blockquote><p><a href="https://github.com/rabbitmq/rabbitmq-server/releases">https://github.com/rabbitmq/rabbitmq-server/releases</a></p></blockquote><h5 id="或者点击直接下载"><a href="#或者点击直接下载" class="headerlink" title="或者点击直接下载"></a>或者点击直接下载</h5><p>注意：这个链接在您到来之后可能不是最新版！<br><a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-3.8.3.exe">https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-3.8.3.exe</a></p><h4 id="使用-chocolatey-Windows下的软件包管理器"><a href="#使用-chocolatey-Windows下的软件包管理器" class="headerlink" title="使用 chocolatey(Windows下的软件包管理器)"></a>使用 <code>chocolatey</code>(Windows下的软件包管理器)</h4><p>要安装RabbitMQ，请在命令行或PowerShell中运行以下命令:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">choco install rabbitmq<br></code></pre></div></td></tr></table></figure><h3 id="在MacOS上下载"><a href="#在MacOS上下载" class="headerlink" title="在MacOS上下载"></a>在MacOS上下载</h3><p>确保 Homebrew 为最新的：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">brew update<br></code></pre></div></td></tr></table></figure><p>然后下载rabbitmq</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">brew install rabbitmq<br></code></pre></div></td></tr></table></figure><h4 id="也可以下载通用UNIX的二进制文件"><a href="#也可以下载通用UNIX的二进制文件" class="headerlink" title="也可以下载通用UNIX的二进制文件"></a>也可以下载通用UNIX的二进制文件</h4><blockquote><p><a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-generic-unix-3.8.3.tar.xz">https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-generic-unix-3.8.3.tar.xz</a></p></blockquote><h3 id="使用docker镜像"><a href="#使用docker镜像" class="headerlink" title="使用docker镜像"></a>使用docker镜像</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker pull rabbitmq<br></code></pre></div></td></tr></table></figure><br><h3 id="配置RabbitMQ"><a href="#配置RabbitMQ" class="headerlink" title="配置RabbitMQ"></a>配置RabbitMQ</h3><p><strong>注意：接下来以windows10为基本环境</strong><br>如果您的环境为win10,下载完成记得将RabbitMQ的<code>/sbin</code>目录加入系统环境。<br>以便在任何地方控制您的MQ.<br>运行以下命令查看是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">rabbitmqctl status<br></code></pre></div></td></tr></table></figure><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>我的RabbitMQ一启动就失败，系统日志显示了以下错误。</p><blockquote><p>RabbitMQ: Erlang machine stopped instantly (distribution name conflict?). The service is not restarted, ignoring OnFail option.</p></blockquote><p>我尝试了多种解决方式。但是都没有用，最后把<code>erlang</code>和<code>RabbitMQ</code>卸载掉，都换成最新版本解决了问题。<br>注意：</p><ol><li>RabbitMQ无法安装到具有ASCII字符的路径,也就是路径不能有中文</li><li>需要用管理员身份安装Erlang环境。</li><li>安装路径不要有空格。（未实践！）<br>官方对错误的解答：<a href="https://www.rabbitmq.com/windows-quirks.html">Windows怪癖</a></li></ol><h4 id="安装可视化插件"><a href="#安装可视化插件" class="headerlink" title="安装可视化插件"></a>安装可视化插件</h4><p>先查看RabbitMQ的全部插件，运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">rabbitmq-plugins list<br></code></pre></div></td></tr></table></figure><p>输出内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Listing plugins with pattern &quot;.*&quot; ...<br> Configured: E = explicitly enabled; e = implicitly enabled<br> | Status: [failed to contact rabbit@waterbang - status not shown]<br> |/<br>....<br>[  ] rabbitmq_federation_management    3.8.3<br>[  ] rabbitmq_jms_topic_exchange       3.8.3<br>[  ] rabbitmq_management               3.8.3 // 这个是我们要安装的管理插件<br>[  ] rabbitmq_management_agent         3.8.3<br>[  ] rabbitmq_mqtt                     3.8.3<br>[  ] rabbitmq_peer_discovery_aws       3.8.3<br>[  ] rabbitmq_peer_discovery_common    3.8.3<br>[  ] rabbitmq_peer_discovery_consul    3.8.3<br>[  ] rabbitmq_peer_discovery_etcd      3.8.3<br>[  ] rabbitmq_peer_discovery_k8s       3.8.3<br>...<br></code></pre></div></td></tr></table></figure><p>运行以下命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">rabbitmq-plugins enable rabbitmq_management<br></code></pre></div></td></tr></table></figure><p>输出以下内容为安装成功</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Enabling plugins on node rabbit@waterbang:<br>rabbitmq_management<br>The following plugins have been configured:<br>  rabbitmq_management<br>  rabbitmq_management_agent<br>  rabbitmq_web_dispatch<br>Applying plugin configuration to rabbit@waterbang...<br>The following plugins have been enabled:<br>  rabbitmq_management<br>  rabbitmq_management_agent<br>  rabbitmq_web_dispatch<br><br>set 3 plugins.<br>Offline change; changes will take effect at broker restart.<br></code></pre></div></td></tr></table></figure><h2 id="如何在node中传递消息"><a href="#如何在node中传递消息" class="headerlink" title="如何在node中传递消息"></a>如何在node中传递消息</h2><p>我们来跟着官方的入门例子来进行第一步，将生产者连接到RabbitMQ,发送一条消息后退出。<br>下面是我们要实现的基本模型。中间蓝色的队列是消息缓冲区。<br><img src="/./helloword.png" alt="hello world"></p><h3 id="安装amqp-node"><a href="#安装amqp-node" class="headerlink" title="安装amqp.node"></a>安装amqp.node</h3><p><code>amqplib</code>是一个为Node.JS制作<a href="https://www.rabbitmq.com/amqp-0-9-1-reference.html">AMQP 0-9-1</a>客户端的库，它支持Callback和Promise两种风格。<br>接下来在您的工作目录运行：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">npm install amqplib<br></code></pre></div></td></tr></table></figure><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>安装完成后开始写代码。创建生产者send.js。先连接道RabbitMQ服务器，<br>这是RabbitMQ给我们的一个最重要的接口，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var amqp = require(&#x27;amqplib&#x27;);<br><br>amqp.connect(&#x27;amqp://localhost:5672&#x27;).then((conn) =&gt; &#123;  // 创建一个通道<br>  console.log(conn);<br>&#125;, (err) =&gt; &#123;<br>  throw Error(&#x27;connection fail:===&gt;&#x27; + err);<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>它返回给我们一个ChannelModel。接下来我们用它来创建一个通道,并且用<code>assertQueue(queue,[options])</code>声明一个队列。<br>它接收两个参数：<br><code>queue</code>是一个字符串；如果您提供一个空字符串或其他虚假值（包括null和undefined），则服务器将为您创建一个随机名称。<br><code>options</code>是一个对象，可以为空或null，如果是最后一个参数，则可以完全省略。<br>选项中的相关字段是：</p><ol><li>exclusive：如果为true，则将队列的作用域限定为连接（默认为false）</li><li>durable：如果为true，则队列将在代理重新启动后幸存下来，并对exclusive和的作用取模autoDelete。如果未提供，则默认为true，这与其他方法不同</li><li>autoDelete：如果为true，则当使用者数量降至零（默认值为false）时，将删除队列。</li><li>arguments：附加参数，通常是某种特定于代理的扩展的参数，例如，高可用性，TTL。<br>*想要了解得更加详细<a href="https://www.squaremobius.net/amqp.node/channel_api.html#channel_assertQueue">点我</a>*，代码如下：</li></ol><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var amqp = require(&#x27;amqplib&#x27;);<br><br>amqp.connect(&#x27;amqp://localhost:5672&#x27;).then((conn) =&gt; &#123;  // 连接到RabbitMQ服务器<br>  return conn.createChannel().then((ch) =&gt; &#123; // 创建一个通道<br>    console.log(ch);<br>    let q = &#x27;Queue&#x27;; // 队列名称<br>    let msg = &#x27;How are you!&#x27;; // 发送的消息<br>    let ok = ch.assertQueue(q, &#123; durable: false &#125;); // 创建队列<br>  &#125;).finally(() =&gt; &#123;<br>    conn.close();<br>  &#125;);<br>&#125;, (err) =&gt; &#123;<br>  throw Error(&#x27;connection fail:===&gt;&#x27; + err);<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>它返回给我们一个Channel，接下来我们来发送消息到队列.<br>具体代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var amqp = require(&#x27;amqplib&#x27;);<br><br>amqp.connect(&#x27;amqp://localhost:5672&#x27;).then((conn) =&gt; &#123;  // 连接到RabbitMQ<br>  return conn.createChannel().then((ch) =&gt; &#123; // 创建一个通道<br>    let q = &#x27;Queue&#x27;;<br>    let msg = &#x27;How are you!&#x27;;<br>    let ok = ch.assertQueue(q, &#123; durable: false &#125;); // 声明队列<br><br>    return ok.then((_qok) =&gt; &#123;<br>       for (let i = 0; i &lt; 100; i++) &#123;<br>            ch.sendToQueue(q, Buffer.from(`$&#123;msg&#125; 第$&#123;i&#125;条消息`));<br>        &#125;<br>      console.log(&quot; [x] Sent &#x27;%s&#x27;&quot;, msg);<br>      return ch.close(); // 关闭通道<br>    &#125;)<br>  &#125;).finally(() =&gt; &#123;<br>    conn.close();<br>  &#125;);<br>&#125;, (err) =&gt; &#123;<br>  throw Error(&#x27;connection fail:===&gt;&#x27; + err);<br>&#125;)<br></code></pre></div></td></tr></table></figure><blockquote><p>API详解<a href="https://www.squaremobius.net/amqp.node/channel_api.html#channel_sendToQueue">sendToQueue</a><br>Buffer.from() :创建一个新缓冲区，其中填充了指定的字符串</p></blockquote><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>接下我们来跟着上面一样写出消费者的代码，我们将使消费者保持运行状态以监听消息并打印出来。<br>我们一样要创建一个队列，防止在没有运行生产者的时候运行消费者。<br>具体代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var amqp = require(&#x27;amqplib&#x27;);<br><br>amqp.connect(&#x27;amqp://localhost:5672&#x27;).then((conn) =&gt; &#123; // 连接到RabbitMQ<br>  process.once(&#x27;SIGINT&#x27;, () =&gt; &#123; conn.close(); &#125;); // （beforeExit）在退出之前,关闭通道。<br><br>  return conn.createChannel().then((ch) =&gt; &#123; // 创建通道<br>    let queue = &#x27;Queue&#x27;;<br>    let ok = ch.assertQueue(queue, &#123;durable: false&#125;);  // 创建队列，（关闭持久化）<br><br>    ok = ok.then(function(_qok) &#123;<br>      return ch.consume(queue, (msg) =&gt; &#123;  // 取出消息（消费）<br>        console.log(&quot; [x] 消费了 &#x27;%s&#x27;&quot;, msg.content.toString());<br>      &#125;, &#123;noAck: true&#125;);<br>    &#125;);<br><br>    return ok.then((_consumeOk) =&gt; &#123;<br>      console.log(&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;);<br>    &#125;);<br>  &#125;);<br>&#125;).catch(console.warn);<br></code></pre></div></td></tr></table></figure><p><code>noAck: true</code>，如果为true，表示当消费者收到消息不会通知RabbitMQ，消费者收到了消息就会立即从队列中删除。</p><blockquote><p>消费API -&gt; <a href="https://www.squaremobius.net/amqp.node/channel_api.html#channel_consume">consume</a></p></blockquote><p>这样就实现了基本的消息发送和接收。</p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>使用任务队列的优点之一是能够轻松并行化工作。如果我们有很多工作，我们可以增加更多的消费者，这样就可以轻松扩展。<br>我们先来修改一下上面send.js的代码，让它能在命令行接收消息。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var amqp = require(&#x27;amqplib&#x27;);<br><br>amqp.connect(&#x27;amqp://localhost:5672&#x27;).then((conn) =&gt; &#123;  // 创建一个通道<br>  return conn.createChannel().then((ch) =&gt; &#123;<br>    let q = &#x27;task_queue&#x27;;<br>    let msg = process.argv.slice(2).join(&#x27;&#x27;) || &#x27;helloWord!&#x27;;<br>    let ok = ch.assertQueue(q, &#123; durable: true &#125;);<br><br>    return ok.then((_qok) =&gt; &#123;<br>        ch.sendToQueue(q, Buffer.from(msg), &#123;<br>          persistent: true<br>        &#125;);<br>      console.log(&quot; [x] Sent &#x27;%s&#x27;&quot;, msg);<br>      return ch.close();<br>    &#125;)<br>  &#125;).finally(() =&gt; &#123;<br>    conn.close();<br>  &#125;);<br>&#125;, (err) =&gt; &#123;<br>  throw Error(&#x27;connection fail:===&gt;&#x27; + err);<br>&#125;)<br></code></pre></div></td></tr></table></figure><blockquote><p><code>persistent: true</code>如果是true，则消息将在代理重新启动后继续存在，前提是它在一个队列中，该队列也在重新启动后继续存在.</p></blockquote><p>接下来修改一下上面的receive.js，让它在处理消息的时候伪造一秒钟的停顿。<br>它将从队列中弹出消息并执行任务，我们将其命名为<code>worker.js</code>，具体代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var amqp = require(&#x27;amqplib&#x27;);<br><br>amqp.connect(&#x27;amqp://localhost:5672&#x27;).then((conn) =&gt; &#123;<br>  process.once(&#x27;SIGINT&#x27;, () =&gt; &#123; conn.close(); &#125;); //beforeExit 执行close。<br>  return conn.createChannel().then((ch) =&gt; &#123;<br>    let queue = &#x27;task_queue&#x27;; // 保证使用该队列的时候先声明该队列<br>    let ok = ch.assertQueue(queue, &#123;durable: true&#125;);<br><br>    ok = ok.then(function(_qok) &#123;<br>      return ch.consume(queue, (msg) =&gt; &#123;<br>        let secs = msg.content.toString().split(&#x27;.&#x27;).length - 1; //几个点就延迟几秒<br>         console.log(&quot; [x] Received %s&quot;, msg.content.toString());<br>         setTimeout(function() &#123;<br>           console.log(&quot; [x] Done&quot;);<br>         &#125;, secs * 1000);<br>      &#125;, &#123;noAck: true&#125;);<br>    &#125;);<br><br>    return ok.then((_consumeOk) =&gt; &#123;<br>      console.log(&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;);<br>    &#125;);<br>  &#125;);<br>&#125;).catch(console.warn);<br></code></pre></div></td></tr></table></figure><h3 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h3><p>默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。<br>平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为循环。<br>具体效果如下：<br><img src="/./TaskQueue.png" alt="TaskQueue"></p><h3 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h3><p>如果其中一个使用者开始一项漫长的任务并仅部分完成而死掉，会发生什么情况。<br>使用我们当前的代码，RabbitMQ一旦向消费者发送了一条消息，便立即将其标记为删除。<br>在这种情况下，如果您杀死一个消费者，我们将丢失正在处理的消息。我们还将丢失所有发送给该特定消费者但尚未处理的消息。<br>但是我们不想丢失任何任务。如果一个消费者死亡，我们希望将任务交付给另一个消费者。<br>接下来我们来修改一下代码，开启<code>&#123;noAck: false&#125;</code>选项，一旦我们完成了一项任务，消费者会发送一个确认消息。<br>修改worker.js,具体如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var amqp = require(&#x27;amqplib&#x27;);<br><br>amqp.connect(&#x27;amqp://localhost:5672&#x27;).then((conn) =&gt; &#123;<br>  process.once(&#x27;SIGINT&#x27;, () =&gt; &#123; conn.close(); &#125;); //beforeExit 执行close。<br><br>  return conn.createChannel().then((ch) =&gt; &#123;<br>    let queue = &#x27;task_queue&#x27;; // 保证使用该队列的时候先声明该队列<br>    let ok = ch.assertQueue(queue, &#123;durable: true&#125;);<br>    ok = ok.then(function(_qok) &#123;<br><br>      return ch.consume(queue, (msg) =&gt; &#123;<br>        let secs = msg.content.toString().split(&#x27;.&#x27;).length - 1;<br>         console.log(&quot; [x] Received %s&quot;, msg.content.toString());<br>         setTimeout(function() &#123;<br>           console.log(&quot; [x] Done&quot;);<br>           ch.ack(msg);  // ++  // 确认给定的消息<br>         &#125;, secs * 1000);<br>      &#125;, &#123;noAck: false&#125;); // == <br>    &#125;);<br><br>    return ok.then((_consumeOk) =&gt; &#123;<br>      console.log(&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;);<br>    &#125;);<br>  &#125;);<br>&#125;).catch(console.warn);<br></code></pre></div></td></tr></table></figure><p>这样就能防止消费者挂掉后，由它处理的任务失败掉，我们来故意挂掉消费者1号，具体效果如下：<br><img src="/./TaskQueue_out.png" alt="TaskQueue_out.png"></p><p>消费者挂掉后，未确认的消息被重发了。</p><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>我们已经实现了如何确保消费者死亡，任务也不会丢失。但是，如果RabbitMQ服务器停止，我们的任务仍然会丢失。<br>如果您要告知RabbitMQ,确保消息不会消失，需要做两件事：我们需要将队列和消息都标记上持久性。<br>首先，我们需要确保RabbitMQ永远不会丢失队列。为此，我们需要将其声明为持久的：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">channel.assertQueue(&#x27;hello&#x27;, &#123;durable: true&#125;);<br></code></pre></div></td></tr></table></figure><blockquote><p>注意：RabbitMQ不允许您使用不同的参数重新定义现有队列，并且将向尝试执行此操作的任何程序返回错误。</p></blockquote><p>接下来将消息标记为持久消息：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">channel.sendToQueue(queue，Buffer.from(msg)，&#123; persistent：true &#125;);<br></code></pre></div></td></tr></table></figure><p>消息持久化并不会真正的写入磁盘，它只是保存到缓存当中，持久性并不强，但对于简单队列而言，已经绰绰有余了。<br>如果还需要更强的保存能力，可以使用<a href="https://www.rabbitmq.com/confirms.html">发布者确认</a></p><h3 id="公平分配"><a href="#公平分配" class="headerlink" title="公平分配"></a>公平分配</h3><p>为了不让RabbitMQ盲目的将消息的第n条消息发送给第n个使用者。这样在有的任务重，有的任务轻的时候，<br>可能会出现一位工人将一直忙碌而另一位工人将几乎不做任何工作。<br>发生这种情况是因为RabbitMQ在消息进入队列时才调度消息。它不会查看消费者的未确认消息数。<br>为了解决这个问题我们需要做以下配置：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">channel.prefetch(1);<br></code></pre></div></td></tr></table></figure><p>在处理并确认上一条消息之前，不要将新消息发送给工作人员。而是将其分派给尚不繁忙的下一个工作人员。</p><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>上面我们实现了把每个任务恰好交付给一个工人，接下来我们来实现，将消息传递给多个工人。<br>我们来跟着官方的例子，构建一个简单的日志记录系统。就是将已发布的日志广播到所有接收者。<br>它由两个程序组成：第一个程序将发出日志消息，第二个程序将接收并打印它们。</p><h3 id="交换（Exchanges）"><a href="#交换（Exchanges）" class="headerlink" title="交换（Exchanges）"></a>交换（Exchanges）</h3><p>它是Rabbit的消息交换模型。核心思想是生产者从不将任何消息直接发送到队列。<br>一方面，它接收来自生产者的消息，另一方面，将它们推入队列。<br>但是它如何知道应该将消息加入队列，还是丢弃呢？规则由交换类型定义。<br>有四种交换类型可用：<code>direct</code>,<code>topic</code>,<code>headers</code>,<code>fanout</code>。<br><code>fanout</code>交换类型正是我们需要的，它只是将接收到的所有消息广播到它知道的所有队列中。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">ch.assertExchange(&#x27;logs&#x27;,&#x27;fanout&#x27;,&#123;durable：false &#125;)<br></code></pre></div></td></tr></table></figure><blockquote><p>Channel的<code>assertExchange</code>用来断言交换的存在，与队列一样。<br>参数类型为：assertExchange(exchange, type, [options])</p></blockquote><p>如果要知道您的服务器上的交换可以运行：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">rabbitmqctl list_exchanges<br></code></pre></div></td></tr></table></figure><h4 id="默认交换"><a href="#默认交换" class="headerlink" title="默认交换"></a>默认交换</h4><p>我们以前使用的都是默认交换</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">channel.sendToQueue(&#x27;hello&#x27;，Buffer.from(&#x27;Hello World！&#x27;));<br></code></pre></div></td></tr></table></figure><p>在这里，我们使用默认或无名称交换：消息以指定为第一个参数的名称路由到队列（如果存在）。<br>接下来我们指定发布到<code>logs</code>交换中：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">channel.publish(&#x27;logs&#x27;, &#x27;&#x27;, Buffer.from(&#x27;Hello World！&#x27;));<br></code></pre></div></td></tr></table></figure><p><code>publish</code>功能和<code>sendToQueue</code>差不多，第二个参数的空字符串表示我们不想将消息发送到任何特定的队列。</p><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>我们已经创建了一个<code>fanout</code>交换和一个队列。现在我们需要告诉交换机将消息发送到我们的队列。交换和队列之间的关系称为绑定。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs HTML">channel.bindQueue(queue_name, &#x27;logs&#x27;, &#x27;&#x27;);<br></code></pre></div></td></tr></table></figure><blockquote><p><a href="https://www.squaremobius.net/amqp.node/channel_api.html#channel_bindQueue">bindQueue</a>:声明从交换机到队列的路由路径</p></blockquote><p>这此我们将消息发送到<code>logs</code>交换器，而不是无名的默认交换器。<br>发送时我们需要提供一个路由密钥，但是对于<code>fanout</code>交换，它的值将被忽略。这是emit_log.js脚本的代码 ：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const amqp = require(&#x27;amqplib&#x27;);<br><br>amqp.connect(&#x27;amqp://localhost&#x27;).then((conn) =&gt; &#123;<br>  return conn.createChannel().then((ch) =&gt; &#123;<br>    const ex = &#x27;logs&#x27;;<br>    let ok = ch.assertExchange(ex, &#x27;fanout&#x27;, &#123;durable: false&#125;) // 声明交换<br><br>    let message = process.argv.slice(2).join(&#x27; &#x27;) ||<br>      &#x27;info: Hello World!&#x27;;<br><br>    return ok.then(() =&gt; &#123;<br>      ch.publish(ex, &#x27;&#x27;, Buffer.from(message));<br>      console.log(&quot; [x] Sent &#x27;%s&#x27;&quot;, message);<br>      return ch.close();<br>    &#125;);<br>  &#125;).finally(() =&gt; &#123; conn.close(); &#125;);<br>&#125;).catch(console.warn);<br></code></pre></div></td></tr></table></figure><p>从上面我们可以看到，建立连接之后，我们声明了交换。<br>如果没有队列绑定到对应的交换那么消息将丢失。receive_log.js代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const amqp = require(&#x27;amqplib&#x27;);<br><br>amqp.connect(&#x27;amqp://localhost&#x27;).then( (conn) =&gt; &#123;<br>  process.once(&#x27;SIGINT&#x27;, () =&gt; &#123; conn.close(); &#125;);<br>  return conn.createChannel().then((ch) =&gt; &#123;<br>    let ok = ch.assertExchange(&#x27;logs&#x27;, &#x27;fanout&#x27;, &#123; durable: false &#125;);<br>    ok = ok.then(() =&gt; &#123;<br>      return ch.assertQueue(&#x27;&#x27;, &#123; exclusive: true &#125;);<br>    &#125;);<br>    ok = ok.then((qok) =&gt; &#123;<br>      return ch.bindQueue(qok.queue, &#x27;logs&#x27;, &#x27;&#x27;).then(function () &#123;  // 绑定队列<br>        return qok.queue;<br>      &#125;);<br>    &#125;);<br>    ok = ok.then((queue) =&gt; &#123;<br>      return ch.consume(queue, logMessage, &#123; noAck: true &#125;);<br>    &#125;);<br>    return ok.then(() =&gt; &#123;<br>      console.log(&#x27; [*] Waiting for logs. To exit press CTRL+C&#x27;);<br>    &#125;);<br><br>    function logMessage(msg) &#123;<br>      console.log(&quot; [x] &#x27;%s&#x27;&quot;, msg.content.toString());<br>    &#125;<br>  &#125;);<br>&#125;).catch(console.warn);<br></code></pre></div></td></tr></table></figure><p>运行结果如下：<br><img src="/./fady.png" alt="fady"></p><h2 id="over"><a href="#over" class="headerlink" title="over"></a>over</h2><p>助秋风雨来何速，惊破秋窗秋梦绿。<br>「代别离·秋窗风雨夕」<br>曹雪芹</p>]]></content>
    
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node中的require方法</title>
    <link href="/2020/03/10/node%E4%B8%AD%E7%9A%84require%E6%96%B9%E6%B3%95/"/>
    <url>/2020/03/10/node%E4%B8%AD%E7%9A%84require%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h3><p>node中js文件就是一个模块。</p><h4 id="为什么出现模块的概念"><a href="#为什么出现模块的概念" class="headerlink" title="为什么出现模块的概念"></a>为什么出现模块的概念</h4><p>防止命名冲突，可以把相同的功能封装到一起。</p><h3 id="简单版的require"><a href="#简单版的require" class="headerlink" title="简单版的require"></a>简单版的require</h3><p>我们来实现一下自己的简易版require，源码里的实现还是挺复杂的。<br>在工作目录中创建文件 Module.js,内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Modules</span>(<span class="hljs-params"></span>) &#123;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">req</span>(<span class="hljs-params"></span>)&#123;<br>&#125;<br><span class="hljs-title function_">req</span>(<span class="hljs-string">&#x27;./a&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>再创建一个 a.json,内容如下：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></div></td></tr></table></figure><p>node模块是按照后缀名查找的，先<code>.js</code> 然后 <code>.json</code>文件。<br>所以我们在module.js中写入：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Module</span>.<span class="hljs-property">extensions</span> = &#123;<br>    <span class="hljs-string">&#x27;.js&#x27;</span>() &#123;&#125;,<br>    <span class="hljs-string">&#x27;.json&#x27;</span>()&#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="第一步：把相对路径转换成绝对路径"><a href="#第一步：把相对路径转换成绝对路径" class="headerlink" title="第一步：把相对路径转换成绝对路径"></a>第一步：把相对路径转换成绝对路径</h4><p>要把用户传进来的相对路径转换成绝对路径。<br>先假设文件名有带后缀，然后判断是否存在该文件，<br>如果不存在，则从制定的文件后缀去拿出每一个后缀，让文件名和后缀拼接。<br>继续循环去查找文件是否存在。<br>接下来，给Module创建一个<code>resolveFileName</code>方法，来实现我们的逻辑：</p><blockquote><p>需要引入path,和fs 模块</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 给我一个相对路径，我给你解析成绝对路径</span><br><span class="hljs-title class_">Module</span>.<span class="hljs-property">resolveFileName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">filename</span>) &#123;<br>  <span class="hljs-keyword">let</span> absPath = path.<span class="hljs-title function_">resolve</span>(__dirname, filename); <span class="hljs-comment">// 1. 把相对路径转换为绝对路径</span><br>  <span class="hljs-keyword">let</span> flag = fs.<span class="hljs-title function_">existsSync</span>(absPath); <span class="hljs-comment">// 判断文件是否存在</span><br>  <span class="hljs-keyword">let</span> current;<br>  <span class="hljs-keyword">if</span> (!flag) &#123;<br>    <span class="hljs-keyword">let</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-title class_">Module</span>.<span class="hljs-property">extensions</span>); <span class="hljs-comment">// 取后缀</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++) &#123; <br>      current = absPath + keys[i]; <span class="hljs-comment">// 拼接每一个有可能的文件</span><br>      <span class="hljs-keyword">let</span> flag = fs.<span class="hljs-title function_">existsSync</span>(current);  <span class="hljs-comment">// 判断是否存在</span><br>      <span class="hljs-keyword">if</span> (flag) &#123; <br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        current = <span class="hljs-literal">null</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!current) &#123; <span class="hljs-comment">// 如果加了后缀还是不存在，则抛出错误</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;文件不存在&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> current; <span class="hljs-comment">// 返回路径</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="第二步：根据绝对路径创建一个模块"><a href="#第二步：根据绝对路径创建一个模块" class="headerlink" title="第二步：根据绝对路径创建一个模块"></a>第二步：根据绝对路径创建一个模块</h4><p>模块里有id,和exports。所以我们在Module里写入：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Module</span>(<span class="hljs-params">id</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">exports</span> = &#123;&#125;; <span class="hljs-comment">// 模块的结果</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>创建一个module, 并且要加载这个模块, 所以，在req函数内写入：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">req</span>(<span class="hljs-params">filename</span>) &#123;<br>  <span class="hljs-keyword">let</span> current = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">resolveFileName</span>(filename);<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Module</span>(current); <span class="hljs-comment">// 产生一个module</span><br>   <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">load</span>(); <span class="hljs-comment">// 加载</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>; <span class="hljs-comment">// 默认导出module.exports对象。</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="第三步：模块的加载"><a href="#第三步：模块的加载" class="headerlink" title="第三步：模块的加载"></a>第三步：模块的加载</h4><p>模块的加载就是读取文件的内容,由于我们不知道传过来的是js还是json,<br>因此我们要根据不同的后缀，调用不同的处理方法：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 模块的加载就是读取文件的内容</span><br><span class="hljs-title class_">Module</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">load</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> ext = path.<span class="hljs-title function_">extname</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);<br>  <span class="hljs-title class_">Module</span>.<span class="hljs-property">extensions</span>[ext](<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 根据不同的后缀调用不同的处理方法。</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样处理方法就会接收到一个module,如果是json,那直接返回一个json就行。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">Module.extensions = &#123;<br>  &quot;.js&quot;() &#123;<br>  &#125;,<br>  &quot;.json&quot;(module) &#123;<br>    let script = fs.readFileSync(module.id, &#x27;utf8&#x27;);<br>    module.exports = JSON.parse(script);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>到这里我们就能读取json文件的内容：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">let json = req(&#x27;./a&#x27;);<br>console.log(json);  //  &#123;a:&#x27;xxx&#x27;&#125;<br></code></pre></div></td></tr></table></figure><h4 id="第四步：读取js"><a href="#第四步：读取js" class="headerlink" title="第四步：读取js"></a>第四步：读取js</h4><p>还有一种可能是js, js需要将exports,传给用户，让用户自己赋值。<br>先创建一个a.js,内容如下:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">module.exports = &#x27;hello&#x27;;<br></code></pre></div></td></tr></table></figure><p>然后需要创建一个函数将用户传递的内容包裹起来：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">Module.wrapper = [<br>  &#x27;(function(module, exports, require, __filename, __dirname)&#123;&#x27;,<br><br>  &#x27;&#125;)&#x27;<br>]<br>Module.extensions = &#123;<br>  &quot;.js&quot;(module) &#123;<br>    let script = fs.readFileSync(module.id, &#x27;utf8&#x27;); // module.exports = &#x27;hello&#x27;;<br>    let fnStr = Module.wrapper[0] + script + Module.wrapper[1];<br>  &#125;,<br>  &quot;.json&quot;(module) &#123;<br>    let script = fs.readFileSync(module.id, &#x27;utf8&#x27;);<br>    module.exports = JSON.parse(script);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来要用到一个vm模块，它的<code>runInThisContext</code>方法能将字符串变成js代码。</p><blockquote><p>记得const vm &#x3D; require(‘vm’)；<br>转换完就像下面这样：<br>(function(module, exports, require, <code>__filename</code>, <code>__dirname</code>){module.exports &#x3D; ‘hello’;})</p></blockquote><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">Module.extensions = &#123;<br>  &quot;.js&quot;(module) &#123;<br>    let script = fs.readFileSync(module.id, &#x27;utf8&#x27;); // module.exports = &#x27;hello&#x27;;<br>    let fnStr = Module.wrapper[0] + script + Module.wrapper[1];<br>    let fn = vm.runInThisContext(fnStr); // 让字符串变成js代码<br>    fn.call(module.exports, module, module.exports, req, module.id, path.dirname(module.id));// 给用户更改对象<br>  &#125;,<br>  &quot;.json&quot;(module) &#123;<br>    let script = fs.readFileSync(module.id, &#x27;utf8&#x27;);<br>    module.exports = JSON.parse(script);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>第一个参数是改变this的指向，第二个是module,第三个是module.exports,第四个是文件名，第五个是父路径。</p></blockquote><h4 id="第五步：缓存module"><a href="#第五步：缓存module" class="headerlink" title="第五步：缓存module"></a>第五步：缓存module</h4><p>这样就能打印出js的内容，但是这样会有多次引用的问题，每次<code>req</code>同一文件的时候都会创建一个module.<br>所以我们用一个缓存，来实现多次加载，只有一次，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">Module._cache = &#123;&#125;;<br>function req(filename) &#123;<br>  let current = Module.resolveFileName(filename);<br>  if(Module._cache[current])&#123;<br>    return Module._cache[current].exports; // 如果加载过了，直接返回exports<br>  &#125;<br>  let module = new Module(current);<br>  Module._cache[current] = module;<br>  module.load();<br>  return module.exports; // 默认导出module.exports对象。<br>&#125;<br>let json = req(&#x27;./a&#x27;);<br>console.log(json);<br></code></pre></div></td></tr></table></figure><p>这样我们的req就完成了。</p><h3 id="module-exports和exports"><a href="#module-exports和exports" class="headerlink" title="module.exports和exports"></a>module.exports和exports</h3><p>module.exports和exports是相等的。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">// a.js<br>console.log(module.exports === exports); // true<br>module.exports = &#x27;hello&#x27;;<br></code></pre></div></td></tr></table></figure><p>但是为什么我们使用module.exports导出可以，直接用exports导出不行呢？</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">module.exports = &#x27;hello&#x27;; // =&gt; hello<br>exports = &#x27;hello&#x27; // &#123;&#125;<br></code></pre></div></td></tr></table></figure><p>这是因为，他们的关系是：</p><div class="hljs code-wrapper"><pre><code class="hljs">let exports = module.exports = &#123;&#125;;</code></pre></div><p>所以我们开发时应该采用<code>export.a</code> 或者 <code>module.exports</code>;<br>不要使用global,会导致全局污染。</p><h3 id="模块的查找路径"><a href="#模块的查找路径" class="headerlink" title="模块的查找路径"></a>模块的查找路径</h3><p>一般情况下会先查找文件，找不到的话，找文件夹，再找不到会报错。</p><h4 id="第三方文件夹查找"><a href="#第三方文件夹查找" class="headerlink" title="第三方文件夹查找"></a>第三方文件夹查找</h4><p>它会找node_modules下的同名文件下的index.js,如果找不到，会向上级查找。直到根目录。<br>如果文件夹下的入口文件不叫index.js，需要建一个package.json，声明入口文件，内容如下：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;a.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></div></td></tr></table></figure><p>这样就能查找到。如果没有main 会找index.js -&gt; index.json</p><h3 id="完整代码如下："><a href="#完整代码如下：" class="headerlink" title="完整代码如下："></a>完整代码如下：</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const path = require(&#x27;path&#x27;);<br>const fs = require(&#x27;fs&#x27;);<br>const vm = require(&#x27;vm&#x27;);<br><br>function Module(id) &#123;<br>  this.id = id;<br>  this.exports = &#123;&#125;; // 模块的结果<br>&#125;<br><br>Module.wrapper = [<br>  &#x27;(function(module, exports, require, __filename, __dirname)&#123;&#x27;,<br><br>  &#x27;&#125;)&#x27;<br>]<br>Module.extensions = &#123;<br>  &quot;.js&quot;(module) &#123;<br>    let script = fs.readFileSync(module.id, &#x27;utf8&#x27;); // module.exports = &#x27;hello&#x27;;<br>    let fnStr = Module.wrapper[0] + &#x27; &#x27; + script + Module.wrapper[1];<br>    let fn = vm.runInThisContext(fnStr); // 让字符串变成js代码<br>    fn.call(module.exports, module, module.exports, req, module.id, path.dirname(module.id));<br>  &#125;,<br>  &quot;.json&quot;(module) &#123;<br>    let script = fs.readFileSync(module.id, &#x27;utf8&#x27;);<br>    module.exports = JSON.parse(script);<br>  &#125;<br>&#125;<br>// 给我一个相对路径，我给你解析成绝对路径<br>Module.resolveFileName = function (filename) &#123;<br>  let absPath = path.resolve(__dirname, filename); // 1. 把相对路径转换为绝对路径<br>  let flag = fs.existsSync(absPath); // 判断文件是否存在<br>  let current;<br>  if (!flag) &#123;<br>    let keys = Object.keys(Module.extensions);<br>    for (let i = 0; i &lt; keys.length; i++) &#123;<br>      current = absPath + keys[i];<br>      let flag = fs.existsSync(current);<br>      if (flag) &#123;<br>        break;<br>      &#125; else &#123;<br>        current = null;<br>      &#125;<br>    &#125;<br>  &#125;<br>  if (!current) &#123; // 如果加了后缀还是不存在，则抛出错误<br>    throw new Error(&#x27;文件不存在&#x27;);<br>  &#125;<br>  return current;<br>&#125;<br><br>// 模块的加载就是读取文件的内容<br>Module.prototype.load = function () &#123;<br>  let ext = path.extname(this.id);<br>  Module.extensions[ext](this); // 根据不同的后缀调用不同的处理方法。<br>&#125;<br>Module._cache = &#123;&#125;;<br>function req(filename) &#123;<br>  let current = Module.resolveFileName(filename);<br>  if (Module._cache[current]) &#123;<br>    return Module._cache[current].exports; // 如果加载过了，直接返回exports<br>  &#125;<br>  let module = new Module(current);<br>  Module._cache[current] = module;<br>  module.load();<br>  return module.exports; // 默认导出module.exports对象。<br>&#125;<br>let json = req(&#x27;./a&#x27;);<br>console.log(json);<br></code></pre></div></td></tr></table></figure><h3 id="over"><a href="#over" class="headerlink" title="over"></a>over</h3><p>西塞山前白鹭飞，桃花流水鳜鱼肥。<br>「渔父歌」<br>张志和</p>]]></content>
    
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7虚拟机上`Minikube`安装Kubernetes</title>
    <link href="/2020/01/26/CentOS7%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8AMinikube%E5%AE%89%E8%A3%85Kubernetes/"/>
    <url>/2020/01/26/CentOS7%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8AMinikube%E5%AE%89%E8%A3%85Kubernetes/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>写这篇文章的原因是因为部署的时候遇到很多坑，而且我一个接着一个的跳进去，这篇文章为了防止再跳进去，希望这篇文章能帮到你。</p><blockquote><p>注意：本文只是建议，查阅时请带有主观意见和独立思考。</p></blockquote><h3 id="确保有安装环境"><a href="#确保有安装环境" class="headerlink" title="确保有安装环境"></a>确保有安装环境</h3><p>你需要有<code>docker</code>，<code>kubectl</code>，<code>minikube</code>环境。<br>具体推荐阿里云的这篇文章<a href="https://yq.aliyun.com/articles/221687">Minikube - Kubernetes 本地实验环境</a>。<br>或者直接进入<a href="https://kubernetes.io/zh/docs/tasks/tools/">官方文档</a>。</p><p>这一定难不倒你。</p><h3 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h3><p>我一开始看<a href="https://minikube.sigs.k8s.io/docs/start/linux/">官方文档</a>，里的安装教程，由于我是在 VM 虚拟机中运行的<br>所以就要使用 sudo minikube start –vm-driver&#x3D;none<br>于是开始报错：无法拉取镜像，开启 cluster 时出错。<br>记得每一次构建失败都要执行<code>minikube delete</code></p><h4 id="拉取镜像应该采用镜像储存库"><a href="#拉取镜像应该采用镜像储存库" class="headerlink" title="拉取镜像应该采用镜像储存库"></a>拉取镜像应该采用镜像储存库</h4><div class="hljs code-wrapper"><pre><code class="hljs">minikube start --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers</code></pre></div><p>如果这样可以那么恭喜你，可以关闭本文章继续学习了。<br>如果执行失败可以换成阿里云给出的解决方案。<br>下面代码中的<code>https://xxxxxx.mirror.aliyuncs.com</code>，你需要去阿里云<a href="https://cr.console.aliyun.com/cn-beijing/instances/mirrors">容器镜像服务&gt;镜像加速地址</a>,来获取您的加速器。<br>你还可以顺便给 docker 配置个镜像加速器</p><p><img src="/./aliyun.png" alt="阿里云图片"></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">minikube start --image-mirror-country cn \<br>--iso-url=https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/iso/minikube-v1.6.0.iso \<br>--registry-mirror=https://xxxxxx.mirror.aliyuncs.com<br></code></pre></div></td></tr></table></figure><blockquote><p>我到这一步还是不行</p></blockquote><h3 id="如果出现无法拉取镜像"><a href="#如果出现无法拉取镜像" class="headerlink" title="如果出现无法拉取镜像"></a>如果出现无法拉取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">🚜  拉取镜像 ...<br>❌  无法拉取映像，有可能是正常状况：running cmd: &quot;/bin/bash -c \&quot;<br>sudo env PATH=/var/lib/minikube/binaries/v1.17.0:$PATH<br>kubeadm config images pull --config /var/tmp/minikube/kubeadm.yaml\&quot;&quot;: /bin/bash -c &quot;<br>sudo env PATH=/var/lib/minikube/binaries/v1.17.0:$PATH<br>kubeadm config images pull --config /var/tmp/minikube/kubeadm.yaml&quot;: exit status 1<br></code></pre></div></td></tr></table></figure><h4 id="可以选择翻墙"><a href="#可以选择翻墙" class="headerlink" title="可以选择翻墙"></a>可以选择翻墙</h4><p>可以把物理机的翻墙工具设置成全局，相信对你来说不是难事。</p><h5 id="如果您在-CentOS-虚拟机上安装了-shadowsocks"><a href="#如果您在-CentOS-虚拟机上安装了-shadowsocks" class="headerlink" title="如果您在 CentOS 虚拟机上安装了 shadowsocks"></a>如果您在 CentOS 虚拟机上安装了 shadowsocks</h5><p>关闭代理，用您的物理机来代理</p><div class="hljs code-wrapper"><pre><code class="hljs">while read var; do unset $var; done &lt; &lt;(env | grep -i proxy | awk -F= &#39;&#123;print $1&#125;&#39;)</code></pre></div><blockquote><p>到此我解决了无法拉取镜像问题</p></blockquote><h3 id="遇到了开启-cluster-时出错"><a href="#遇到了开启-cluster-时出错" class="headerlink" title="遇到了开启 cluster 时出错"></a>遇到了开启 cluster 时出错</h3><div class="hljs code-wrapper"><pre><code class="hljs">💣  开启 cluster 时出错: init failed. cmd: &quot;/bin/bash -c \&quot;sudo env PATH=/var/lib/minikube/binaries/v1.17.0:$PATH kubeadm init --config /var/tmp/minikube/kubeadm.yaml  --ignore-preflight-errors=DirAvailable--etc-kubernetes-manifests,DirAvailable--var-lib-minikube,DirAvailable--var-lib-minikube-etcd,FileAvailable--etc-kubernetes-manifests-kube-scheduler.yaml,FileAvailable--etc-kubernetes-manifests-kube-apiserver.yaml,FileAvailable--etc-kubernetes-manifests-kube-controller-manager.yaml,FileAvailable--etc-kubernetes-manifests-etcd.yaml,Port-10250,Swap\&quot;&quot;: /bin/bash -c &quot;sudo env PATH=/var/lib/minikube/binaries/v1.17.0:$PATH kubeadm init --config /var/tmp/minikube/kubeadm.yaml  --ignore-preflight-errors=DirAvailable--etc-kubernetes-manifests,DirAvailable--var-lib-minikube,DirAvailable--var-lib-minikube-etcd,FileAvailable--etc-kubernetes-manifests-kube-scheduler.yaml,FileAvailable--etc-kubernetes-manifests-kube-apiserver.yaml,FileAvailable--etc-kubernetes-manifests-kube-controller-manager.yaml,FileAvailable--etc-kubernetes-manifests-etcd.yaml,Port-10250,Swap&quot;: exit status 1stdout:[init] Using Kubernetes version: v1.17.0[preflight] Running pre-flight checksstderr:W0127 01:14:50.575416    7722 common.go:77] your configuration file uses a deprecated API spec: &quot;kubeadm.k8s.io/v1beta1&quot;. Please use &#39;kubeadm config migrate --old-config old.yaml --new-config new.yaml&#39;, which will write the new, similar spec using a newer API version.W0127 01:14:50.576165    7722 common.go:77] your configuration file uses a deprecated API spec: &quot;kubeadm.k8s.io/v1beta1&quot;. Please use &#39;kubeadm config migrate --old-config old.yaml --new-config new.yaml&#39;, which will write the new, similar spec using a newer API version.W0127 01:14:50.578306    7722 validation.go:28] Cannot validate kube-proxy config - no validator is availableW0127 01:14:50.578334    7722 validation.go:28] Cannot validate kubelet config - no validator is available    [WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/    [WARNING Hostname]: hostname &quot;minikube&quot; could not be reached    [WARNING Hostname]: hostname &quot;minikube&quot;: lookup minikube on 192.168.180.2:53: no such hosterror execution phase preflight: [preflight] Some fatal errors occurred:    [ERROR FileContent--proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables contents are not set to 1[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`To see the stack trace of this error execute with --v=5 or higher</code></pre></div><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>它提示我们</p><div class="hljs code-wrapper"><pre><code class="hljs">[ERROR FileContent--proc-sys-net-bridge-bridge-nf-call-iptables]:/proc/sys/net/bridge/bridge-nf-call-iptables contents are not set to 1</code></pre></div><h5 id="输入命令"><a href="#输入命令" class="headerlink" title="输入命令"></a>输入命令</h5><div class="hljs code-wrapper"><pre><code class="hljs">echo &quot;1&quot; &gt;/proc/sys/net/bridge/bridge-nf-call-iptablesswaoiff-a</code></pre></div><p>然后 vim &#x2F;etc&#x2F;fstab，注释掉下面这一行：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">/dev/mapper/rhel-swap   swap                    swap    defaults        0 0</span><br><br></code></pre></div></td></tr></table></figure><p>查看是否成功<br>free -m<br>free 那边是 0 就是成功。</p><h5 id="重新构建"><a href="#重新构建" class="headerlink" title="重新构建"></a>重新构建</h5><div class="hljs code-wrapper"><pre><code class="hljs">minikube deleteminikube start --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers</code></pre></div><blockquote><p>到此我解决了所有问题。如果有人带我觉得这就是几分钟的事情。</p></blockquote><h3 id="成功图"><a href="#成功图" class="headerlink" title="成功图"></a>成功图</h3><p><img src="/./success.png"></p><h4 id="如果执行-minikube-dashboard-出现-503"><a href="#如果执行-minikube-dashboard-出现-503" class="headerlink" title="如果执行 minikube dashboard 出现 503"></a>如果执行 minikube dashboard 出现 503</h4><p>请将您的虚拟机升到 8G 的运行内存</p><h3 id="如果-kubectl-出现连接超时或不可达"><a href="#如果-kubectl-出现连接超时或不可达" class="headerlink" title="如果 kubectl 出现连接超时或不可达"></a>如果 kubectl 出现连接超时或不可达</h3><p>像这样</p><div class="hljs code-wrapper"><pre><code class="hljs">The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?</code></pre></div><p>而且使用 curl 的时候像这样</p><div class="hljs code-wrapper"><pre><code class="hljs">Could not resolve proxy: http//127.0.0.1; 未知的错误</code></pre></div><p>请检查您的代理，可以注释掉，运行 vi &#x2F;etc&#x2F;profile</p><blockquote><p>http_proxy&#x3D;http:&#x2F;&#x2F;代理地址:端口<br>ssl_proxy&#x3D;http:&#x2F;&#x2F;代理地址:端口</p></blockquote><p>如果看到这样的地址请注释掉</p><h3 id="结束语-😋"><a href="#结束语-😋" class="headerlink" title="结束语 😋"></a>结束语 😋</h3><blockquote><p>注意：以上问题是具体问题，请根据具体问题具体分析，仅供参考。</p></blockquote><p>如果有问题请留言，第一时间回复。<br>现在凌晨 1：33，饿了。</p><p>长歌吟松风，曲尽河星稀。<br>「下终南山过斛斯山人宿置酒」<br>李白</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019年度总结</title>
    <link href="/2019/12/28/2019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <url>/2019/12/28/2019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="你好陌生人📺"><a href="#你好陌生人📺" class="headerlink" title="你好陌生人📺"></a>你好陌生人📺</h3><p>时间真快啊，大三已经上了半学期了，下学期一上完6月份就要出去实习了。2019已经接近了尾声，是时候总结，明确目标，继续向前走了。</p><h3 id="我学了什么-🎨"><a href="#我学了什么-🎨" class="headerlink" title="我学了什么 🎨"></a>我学了什么 🎨</h3><p>今年的目标较为明确，学习锁定为前端,下面是大致学的东西，但是掌握还需要多多实践。代码就是要多敲，多想。<br>·   Typescript  PWA<br>·   小程序 云开发<br>·   koa2<br>·   webpack<br>今年逐渐把以前的PHP转换成Node.js了，前端工程化才是主流。</p><p>PWA是webAPP的未来，这个也是好东西，希望明年浏览器的支持会更好一点。但是听说国内不流行，泪奔。</p><p>学习Docker和K8S的目的一开始是要解决，单机数据库负载太大问题。</p><p>高并发也是一块需要学习的地方，多级缓存，层层拦截是要好好学习的。</p><p>今年开始注重编码习惯和方式，用ESLint来规范自己，如果自己的代码要给别人看的话，注释和团队规范也很重要。</p><p>今年也开始刷LeetCode了，以前总以为算法是算法工程师的事，我的目光还是太狭隘了。</p><p>好好学习，天天向上。</p><h3 id="我做了什么👾"><a href="#我做了什么👾" class="headerlink" title="我做了什么👾"></a>我做了什么👾</h3><p>今年还去玩了几次的硬件，学校买了一台Naoqi想做迎宾机器人，底层是linux内核，感觉做这个不是我的主线任务。于是就放弃了。<br>跟几个同学想做消防预警机器人来着，执行力不够，没办法分心去学习<code>Arduino</code>，就退出了。专心攻克软件开发。<br>以后有机会一定要搞个扫地机器人，解放一下劳动力。<br>然后还去打了一场CTF，业绩惨淡，还得跟师傅们好好学习，前年学的PHP反序列化漏洞也没学好。<br>网络安全确实是爱好，但是我比较适合御剑菜刀一把梭。<br>今年还把计算机二级C语言和三级网络安全技术给考了，这个好像没啥用，企业不看重，但是我前几天已经把四级网络安全工程师给报了，希望我能一次过。<br>今年听说前端也出证书了，有空一定得去试试。</p><h3 id="明年要做什么-🌈"><a href="#明年要做什么-🌈" class="headerlink" title="明年要做什么 🌈"></a>明年要做什么 🌈</h3><p>明年就是js基础继续巩固，万变不离其中。然后深入学习node.js这条是主线。<br>然后养成连猜带懵的看源码习惯，现在看懂源码我是不行的，我现在的基础是不牢固的，接下来就是好好巩固基础知识，和一些难点。<br>算法必刷的吧，虽然很菜，但是不积跬步，无以至千里。想要在前端有所建树，我觉得这块不能少。<br>希望能找到下一个风口，让我增加一下睡后收入。体验一下马爸爸的感觉。然后优化小程序。上线信用商城。<br>找机会学一下设计吧，设计好看，打代码有成就感。写软件，最主要的就是好看，和快。<br>前端的机器学习我也很感兴趣,如果能做出更智能的网站或者app就爽了，有些人认为js计算能力不行，<br>我觉得行不行得趟过这趟浑水才知道，tensorflow.js搞起来(落不落地我就不知道了)。</p><h3 id="今年读的书-📕"><a href="#今年读的书-📕" class="headerlink" title="今年读的书 📕"></a>今年读的书 📕</h3><ol><li>vue实战   这是小智送的公众号为大迁世界</li><li>狼书Node.js卷1</li><li>ES6入门标准</li><li>PWA开发实战</li><li>PWA实战</li><li>鸟叔的私房菜</li><li>白帽子讲web安全<br>这些书，ES6入门标准，与私房菜属于工具书，ES6标准对ES最新的标准总结的很全，私房菜也是很强。<br>白帽子讲web安全属于较老的书，是吴瀚清写的，对web安全的介绍，非常详细。<br>PWA开发实战是以一个PWA的网站为例子来介绍PWA的，对比PWA实战个人觉得内容没有后者丰富。<br>Vue实战已经送给学弟了，这本书用来学习挺好的，有很多的小例子，如：如何实现EventBus。<br>狼叔卷1主要给大家讲node源码，讲得挺有趣的，想要全面掌握node,这本书还是不错的。</li></ol><h3 id="今年的惊喜！-💑"><a href="#今年的惊喜！-💑" class="headerlink" title="今年的惊喜！ 💑"></a>今年的惊喜！ 💑</h3><p>今年虽然没有一个项目成功赚到钱的,但是今年成功脱单了。</p><h3 id="结束语-😋"><a href="#结束语-😋" class="headerlink" title="结束语 😋"></a>结束语 😋</h3><p>初从云梦开朱邸，更取金陵作小山。「永王东巡歌十一首」——李白</p>]]></content>
    
    
    
    <tags>
      
      <tag>年度总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue优化预渲染,骨架屏,Nuxt.js服务端渲染</title>
    <link href="/2019/12/26/2019-12-26-VUE-Vue%E4%BC%98%E5%8C%96%E9%A2%84%E6%B8%B2%E6%9F%93-%E9%AA%A8%E6%9E%B6%E5%B1%8F-Nuxt-js%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    <url>/2019/12/26/2019-12-26-VUE-Vue%E4%BC%98%E5%8C%96%E9%A2%84%E6%B8%B2%E6%9F%93-%E9%AA%A8%E6%9E%B6%E5%B1%8F-Nuxt-js%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1-编码优化🍞"><a href="#1-编码优化🍞" class="headerlink" title="1.   编码优化🍞"></a>1.   编码优化🍞</h2><h3 id="1-data属性"><a href="#1-data属性" class="headerlink" title="1.data属性"></a>1.data属性</h3><p>data中的数据都会增加getter和setter，会收集对应的watcher，只有在需要渲染到视图上的才需要放到data，所以没有响应式需求的不要放在data里面。<br>defineReactive源码</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//在Object上定义反应属性。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span> (<br>  obj,<br>  key,<br>  val,<br>  customSetter,<br>  shallow<br>) &#123;<br>  <span class="hljs-keyword">var</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>(); <br><br>  <span class="hljs-keyword">var</span> property = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(obj, key);<br>  <span class="hljs-keyword">if</span> (property &amp;&amp; property.<span class="hljs-property">configurable</span> === <span class="hljs-literal">false</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">var</span> getter = property &amp;&amp; property.<span class="hljs-property">get</span>;<br>  <span class="hljs-keyword">if</span> (!getter &amp;&amp; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;<br>    val = obj[key];<br>  &#125;<br>  <span class="hljs-keyword">var</span> setter = property &amp;&amp; property.<span class="hljs-property">set</span>;<br><br>  <span class="hljs-keyword">var</span> childOb = !shallow &amp;&amp; <span class="hljs-title function_">observe</span>(val);<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactiveGetter</span> () &#123; <br>      <span class="hljs-keyword">var</span> value = getter ? getter.<span class="hljs-title function_">call</span>(obj) : val;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123; <span class="hljs-comment">//把watcher放到target里</span><br>        dep.<span class="hljs-title function_">depend</span>();  <span class="hljs-comment">//依赖搜集</span><br>        <span class="hljs-keyword">if</span> (childOb) &#123; <span class="hljs-comment">//如果有子集</span><br>          childOb.<span class="hljs-property">dep</span>.<span class="hljs-title function_">depend</span>(); <span class="hljs-comment">//也塞进去，目的是兼容数组。</span><br>          <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>            <span class="hljs-title function_">dependArray</span>(value);<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> value<br>    &#125;,<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactiveSetter</span> (newVal) &#123; <span class="hljs-comment">//每次更新的时候</span><br>      <span class="hljs-keyword">var</span> value = getter ? getter.<span class="hljs-title function_">call</span>(obj) : val;<br>      <span class="hljs-comment">/* eslint-disable no-self-compare */</span><br>      <span class="hljs-keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;<br>        <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-comment">/* eslint-enable no-self-compare */</span><br>      <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;<br>        <span class="hljs-title function_">customSetter</span>();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (setter) &#123;<br>        setter.<span class="hljs-title function_">call</span>(obj, newVal);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        val = newVal;<br>      &#125;<br>      childOb = !shallow &amp;&amp; <span class="hljs-title function_">observe</span>(newVal);<br>      dep.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">//通知watcher去更新，执行watcher的update</span><br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-SPA页面采用keep-alive缓存组件"><a href="#2-SPA页面采用keep-alive缓存组件" class="headerlink" title="2.SPA页面采用keep-alive缓存组件"></a>2.SPA页面采用keep-alive缓存组件</h3><p>keep-alive会缓存我们的组件，它会把组件缓存到内存中，下一次访问的时候，会从缓存中拿出来。<br>keep-alive是个函数式组件，里面有个render()方法。他会把默认的插槽拿出来，找到第一个组件(里面只能放一个组件)。<br>拿到后先去判断是否有include和exclude，这两个是判断缓存哪一些，不缓存哪一些。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">render () &#123;<br>    const slot = this.$slots.default<br>    const vnode: VNode = getFirstComponentChild(slot)  // 获取第一个组件节点<br>    const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions<br>    if (componentOptions) &#123;<br>      // check pattern<br>      const name: ?string = getComponentName(componentOptions)<br>      const &#123; include, exclude &#125; = this<br>      if (<br>        // not included<br>        (include &amp;&amp; (!name || !matches(include, name))) ||<br>        // excluded<br>        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))<br>      ) &#123;<br>        return vnode<br>      &#125;<br><br>      // 缓存vnode<br>      const &#123; cache, keys &#125; = this<br>      const key: ?string = vnode.key == null<br>        // same constructor may get registered as different local components<br>        // so cid alone is not enough (#3269)<br>        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;)<br>        : vnode.key<br>      if (cache[key]) &#123; //如果有缓存，直接将缓存返回<br>        vnode.componentInstance = cache[key].componentInstance<br>        // make current key freshest<br>        remove(keys, key)<br>        keys.push(key)<br>      &#125; else &#123;<br>        cache[key] = vnode //缓存下来下次用<br>        keys.push(key)<br>        // 超过缓存限制，就从第一个开始删除<br>        if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;<br>          pruneCacheEntry(cache, keys[0], keys, this._vnode)<br>        &#125;<br>      &#125;<br><br>      vnode.data.keepAlive = true<br>    &#125;<br>    return vnode || (slot &amp;&amp; slot[0])<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-拆分组件"><a href="#3-拆分组件" class="headerlink" title="3.拆分组件"></a>3.拆分组件</h3><p>不拆分和拆分有什么区别呢？<br>vue有个特点，它是按组件刷新的。数据一变，就会刷新当前组件，如果都写到一起了，如果数据一变，整个组件都要刷新。<br>拆分之后，一个组件的数据变了，可以只更新那个小组件。核心就是：<strong>减少不必要的渲染（尽可能细化拆分组件）</strong><br>还有就是<strong>提高复用性，增加代码可维护性</strong>。</p><h3 id="4-v-if"><a href="#4-v-if" class="headerlink" title="4.v-if"></a>4.v-if</h3><p>当前值为false时内部指令不会执行，具有阻断功能。比如说面板，弹框，里面包含很多逻辑，用户不点我们可以使里面先不执行。</p><h3 id="5-key保证唯一性"><a href="#5-key保证唯一性" class="headerlink" title="5.key保证唯一性"></a>5.key保证唯一性</h3><p>·   vue默认采用就地复用原则，可以加key保证唯一性</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;show =! show&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">v-else</span>  <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>·   如果数据项的顺序被改变，Vue不会移动DOM元素来匹配数据项的顺序。它默认会比对内容，如果内容有变，就会多次去创建DOM，删除DOM。<br>这样的性能消耗更大，所以我们如果写循环代码，尽量用唯一的key来实现。这里面主要是DOM Diff的策略。</p><p>·   应该使用数据的id作为key的属性。</p><h3 id="6-Object-freeze"><a href="#6-Object-freeze" class="headerlink" title="6.Object.freeze"></a>6.Object.freeze</h3><p>vue会实现数据劫持，给每个数据增加getter和setter,如果希望数据只是用来展示到页面上而已，并不需要改数据视图会刷新。<br>这样的话，就可以用Object.freeze冻结数据。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">Object.freeze([&#123;value: 1&#125;,&#123;value: 2&#125;])<br></code></pre></div></td></tr></table></figure><p>在数据劫持时，属性不会被配置，不会从新定义</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const property = Object.getOwnPropertyDescriptor(obj, key)<br>if (property &amp;&amp; property.configurable === false) &#123;<br>return<br>&#125;<br></code></pre></div></td></tr></table></figure><p>深冻结</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">// 深冻结函数.<br>function deepFreeze(obj) &#123;<br>  // 取回定义在obj上的属性名<br>  var propNames = Object.getOwnPropertyNames(obj);<br>  // 在冻结自身之前冻结属性<br>  propNames.forEach(function(name) &#123;<br>    var prop = obj[name];<br>    // 如果prop是个对象，冻结它<br>    if (typeof prop == &#x27;object&#x27; &amp;&amp; prop !== null)<br>      deepFreeze(prop);<br>  &#125;);<br>  // 冻结自身(no-op if already frozen)<br>  return Object.freeze(obj);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="7-路由懒加载，异步组件"><a href="#7-路由懒加载，异步组件" class="headerlink" title="7.路由懒加载，异步组件"></a>7.路由懒加载，异步组件</h3><p>动态加载组件，依赖<code>webpack-codespliting</code>功能，不能单独去用，它会拆分这个路由。<br>比如：当我们这个路由匹配到了，它会调用这个函数将路由动态加载上去。<br>webpack如果遇到import语法，会单独打包出js文件，加载的时候使用<code>JSONP</code>的语法，动态加载上去。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"> const router = new VueRouter(&#123;<br>    router: [<br>        &#123;path: &#x27;/footer&#x27;,component: () =&gt; import(/* webpackChunkName: &quot;footer&quot; */ &#x27;../views/Footer.vue&#x27;),&#125;,<br>        &#123;path: &#x27;/about&#x27;,component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;),&#125;,<br>    ]<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>动态导入组件，如果我们有一个组件特别复杂，希望用户点了这个按钮，它才弹出来，这时候就可以使用异步组件。<br>它返回的是一个Promise，它会等待这个组件渲染完成再去显示。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">import Search from &quot;./Search&quot;;<br>export default &#123;<br>    components: &#123;<br>        Search: () =&gt; import(&quot;./Search&quot;);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意</p><p>如果您使用的是 Babel，你将需要添加 <a href="https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import/">syntax-dynamic-import</a> 插件，才能使 Babel 可以正确地解析语法。</p></blockquote><p>但是这里有个坑，不能直接传入一个变量，下面是概要，具体看<a href="https://webpack.js.org/api/module-methods/#import">官方文档</a></p><blockquote><p>无法使用完全动态的import语句，例如import(foo)。因为foo可能是系统或项目中任何文件的任何路径。这样把全部文件打包了是会报错的。</p></blockquote><p>我们还可以使用webpackInclude和webpackExclude选项，来减少webpack导入的文件数量，他们接受一个正则表达式。<br>webpackInclude和webpackExclude选项不会干扰前缀。例如：.&#x2F;locale。</p><p><code>webpackInclude</code>：在导入解析期间将与之匹配的正则表达式。仅将匹配的模块捆绑在一起。</p><p><code>webpackExclude</code>：在导入解析期间将与之匹配的正则表达式。匹配的任何模块都不会捆绑在一起。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">//官方文档中的例子<br>import(<br>  /* webpackInclude: /\.json$/ */<br>  /* webpackExclude: /\.noimport\.json$/ */<br>  `./locale/$&#123;language&#125;`<br>);<br></code></pre></div></td></tr></table></figure><h3 id="8-runtime运行时"><a href="#8-runtime运行时" class="headerlink" title="8.runtime运行时"></a>8.runtime运行时</h3><p>在开发时尽量采用单文件的方式（.vue），他不需要我们运行时去编译template。<br> webpack打包时会将模板进行编译(<a href="https://www.npmjs.com/package/vue-template-compiler">vue-template-compiler</a>)<br> 但是如果使用new Vue({template}),里面的template是在代码运行的时候去编译模板，对性能有损耗。</p><h3 id="9-数据持久化问题"><a href="#9-数据持久化问题" class="headerlink" title="9.数据持久化问题"></a>9.数据持久化问题</h3><p> 可以使用<code>vuex-persist</code>进行数据持久化，因为我们vue里的数据，一刷新就会丢，所以我们要把数据存到localStorage里。<br> 但是如果频繁的对localStorage进行操作，对性能的损耗也很大，<code>vuex-persist</code>提供了一个过滤功能来解决这个问题，您可以过滤掉不想引起存储更新的任何改变。<br> 第二个方法是进行节流。</p><blockquote><p>vuex-persist具体用法看其的<a href="https://github.com/championswimmer/vuex-persist">GitHub文档</a>；<br>window.localStorage（在PC重新启动后仍然存在，直到您清除浏览器数据为止）<br> window.sessionStorage（关闭浏览器选项卡时消失）</p></blockquote><h2 id="2-vue加载性能优化-🌓"><a href="#2-vue加载性能优化-🌓" class="headerlink" title="2.   vue加载性能优化 🌓"></a>2.   vue加载性能优化 🌓</h2><ol><li><p>第三方模块按需引入，如element-ui。也可以使用babel-plugin-component按需加载组件。</p><blockquote><p><a href="https://juejin.im/post/5b35c49bf265da598f156446">babel-plugin-component</a>用法和<a href="https://www.npmjs.com/package/babel-plugin-component">npm官方文档</a></p></blockquote></li><li><p>图片懒加载，滚动到可视区域动态加载。比如像<a href="https://www.npmjs.com/package/vue-lazyload">vue-lazyload</a>;</p></li><li><p>滚动渲染可视区域，数据较大时只渲染可视区域，如果一次性渲染太多的节点，可能会挂掉或者卡顿。</p><blockquote><p>具体用法看<a href="https://zhuanlan.zhihu.com/p/34585166">再谈前端虚拟列表的实现</a><br>也有现成的插件可以使用<a href="https://www.npmjs.com/package/vue-scroll">vue-scroll</a>。</p></blockquote></li></ol><h2 id="3-用户体验👍"><a href="#3-用户体验👍" class="headerlink" title="3.   用户体验👍"></a>3.   用户体验👍</h2><h3 id="1-app-skeleton"><a href="#1-app-skeleton" class="headerlink" title="1.  app-skeleton"></a>1.  app-skeleton</h3><p>配置webpack插件 <a href="https://www.npmjs.com/package/vue-skeleton-webpack-plugin">vue-skeleton-webpack-plugin</a><br>单页骨架屏</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">import Vue from &#x27;vue&#x27;<br>// 引入的骨架屏组件<br>import skeletonHome from &#x27;./skeleton/skeletonHome.vue&#x27;<br>export default new Vue(&#123;<br>    components: &#123;<br>        skeletonHome,<br>    &#125;,<br>    template: `<span class="hljs-tag">&lt;<span class="hljs-name">skeletonHome</span>/&gt;</span> `<br>&#125;);<br>plugins: [<br>    new SkeletonWebpackPlugin(&#123; // 我们编写的插件<br>        webpackConfig: &#123;<br>            entry: &#123;<br>                app: require(&#x27;./src/entry-skeleton.js&#x27;)<br>            &#125;<br>        &#125;<br>    &#125;)<br>]<br></code></pre></div></td></tr></table></figure><p>带路由的骨架屏，编写skeleton.js文件</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">import Vue from &#x27;vue&#x27;;<br>import Skeleton1 from &#x27;./Skeleton1&#x27;;<br>import Skeleton2 from &#x27;./Skeleton2&#x27;;<br><br>export default new Vue(&#123;<br>    components: &#123;<br>        Skeleton1,<br>        Skeleton2<br>    &#125;,<br>    template: `<br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">skeleton1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;skeleton1&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">skeleton2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;skeleton2&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    `<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>configureWebpack里的配置</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">new SkeletonWebpackPlugin(&#123;<br>    webpackConfig: &#123;<br>        entry: &#123;<br>            app: path.join(__dirname, &#x27;./src/skeleton.js&#x27;),<br>        &#125;,<br>    &#125;,<br>    router: &#123;<br>        mode: &#x27;history&#x27;,<br>        routes: [<br>            &#123;<br>                path: &#x27;/&#x27;,<br>                skeletonId: &#x27;skeleton1&#x27;<br>            &#125;,<br>            &#123;<br>                path: &#x27;/about&#x27;,<br>                skeletonId: &#x27;skeleton2&#x27;<br>            &#125;,<br>        ]<br>    &#125;,<br>    minimize: true,<br>    quiet: true,<br>&#125;)<br></code></pre></div></td></tr></table></figure><h4 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h4><p>先来创建一个单页的骨架屏</p><h5 id="1-先在根目录创建一个vue-config-js"><a href="#1-先在根目录创建一个vue-config-js" class="headerlink" title="1. 先在根目录创建一个vue.config.js"></a>1. 先在根目录创建一个vue.config.js</h5><p>粘贴下面代码</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">let SkeletonWebpackPlugin = require(&#x27;vue-skeleton-webpack-plugin&#x27;);<br>const path = require(&#x27;path&#x27;);<br>module.exports = &#123;<br>  configureWebpack:&#123;<br>    plugins:[<br>      new SkeletonWebpackPlugin(&#123; <br>          webpackConfig: &#123;<br>              entry: &#123;<br>                  app: path.resolve(&#x27;./src/entry-skeleton.js&#x27;)<br>              &#125;<br>          &#125;<br>      &#125;)<br>  ]<br>  &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h5 id="2-创建-src-entry-skeleton-js"><a href="#2-创建-src-entry-skeleton-js" class="headerlink" title="2. 创建.&#x2F;src&#x2F;entry-skeleton.js"></a>2. 创建.&#x2F;src&#x2F;entry-skeleton.js</h5><p>放上我们的骨架屏</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">import Vue from &#x27;vue&#x27;;<br><br>export default new Vue(&#123;<br>  render() &#123;<br>    return <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello Vue<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>;<br>  &#125;,<br>&#125;);<br></code></pre></div></td></tr></table></figure><h5 id="这样就ok啦"><a href="#这样就ok啦" class="headerlink" title="这样就ok啦"></a>这样就ok啦</h5><p>用npm run serve 试试！</p><blockquote><p>参考<br><a href="https://xiaoiver.github.io/coding/2017/07/30/%E4%B8%BAvue%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E9%AA%A8%E6%9E%B6%E5%B1%8F.html">为vue项目添加骨架屏</a><br><a href="https://juejin.im/post/5d457bad5188255d8249c7f4">基于 vue-skeleton-webpack-plugin 的骨架屏实战</a></p></blockquote><h4 id="姜文大佬实现的原理"><a href="#姜文大佬实现的原理" class="headerlink" title="姜文大佬实现的原理"></a>姜文大佬实现的原理</h4><p>实现骨架屏插件</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">class MyPlugin &#123;<br>    apply(compiler) &#123;<br>        compiler.plugin(&#x27;compilation&#x27;, (compilation) =&gt; &#123;<br>            compilation.plugin(<br>                &#x27;html-webpack-plugin-before-html-processing&#x27;,<br>                (data) =&gt; &#123;<br>                    data.html = data.html.replace(`<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`, `<br>                        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;home&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none&quot;</span>&gt;</span>首页 骨架屏<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;about&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none&quot;</span>&gt;</span>about页面骨架屏<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">                            <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">hash</span> == <span class="hljs-string">&#x27;#/about&#x27;</span> ||  location.<span class="hljs-property">pathname</span>==<span class="hljs-string">&#x27;/about&#x27;</span>)&#123;</span><br><span class="language-javascript">                                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;about&#x27;</span>).<span class="hljs-property">style</span>.<span class="hljs-property">display</span>=<span class="hljs-string">&quot;block&quot;</span></span><br><span class="language-javascript">                            &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="language-javascript">                                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;home&#x27;</span>).<span class="hljs-property">style</span>.<span class="hljs-property">display</span>=<span class="hljs-string">&quot;block&quot;</span></span><br><span class="language-javascript">                            &#125;</span><br><span class="language-javascript">                        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>                    `);<br>                    return data;<br>                &#125;<br>            )<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-app-shell"><a href="#2-app-shell" class="headerlink" title="2.  app-shell"></a>2.  app-shell</h3><p>一般配合PWA使用,百度的<a href="https://lavas.baidu.com/pwa">Lavas</a>。<br>使用serviceWorker，第一次加载，第二次到本地。</p><h2 id="4-SEO优化方案-🏃"><a href="#4-SEO优化方案-🏃" class="headerlink" title="4.   SEO优化方案 🏃"></a>4.   SEO优化方案 🏃</h2><h3 id="1-vue的预渲染插件"><a href="#1-vue的预渲染插件" class="headerlink" title="1.vue的预渲染插件"></a>1.vue的预渲染插件</h3><p><code>npm install prerender-spa-lpugin</code></p><p>缺陷是数据不够动态，可以使用ssr服务端渲染</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">const path = require(&#x27;path&#x27;)<br>const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;)<br><br>module.exports = &#123;<br>  plugins: [<br>    ...<br>    new PrerenderSPAPlugin(&#123;<br>      // Required - The path to the webpack-outputted app to prerender.<br>      staticDir: path.join(__dirname, &#x27;dist&#x27;),<br>      // Required - Routes to render.<br>      routes: [ &#x27;/&#x27;, &#x27;/about&#x27;, &#x27;/some/deep/nested/route&#x27; ],<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>里面主要用到一个包是puppeteer，他是一个无头浏览器，运行它会打开一个浏览器，但是你看不见它，<br>它会先将页面放在浏览器上去跑，然后生成节点，渲染成HTML,一般用作e2e,或爬虫。</p><h3 id="2-服务端渲染"><a href="#2-服务端渲染" class="headerlink" title="2.  服务端渲染"></a>2.  服务端渲染</h3><p>概念：放在浏览器进行就是浏览器渲染，放在服务器进行就是服务器渲染。就跟以前的模板渲染一样。</p><p>客户端渲染不利于SEO搜索引擎优化<br>服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的<br>SSR直接将HTML轴向传递给浏览器。大大加快了首屏加载时间。<br>SSR占用更多的CPU和内存资源<br>一些常用的浏览器API可能无法正常使用<br>在vue中只支持beforeCreate和created两个生命周期</p><h3 id="3-什么是nuxt"><a href="#3-什么是nuxt" class="headerlink" title="3. 什么是nuxt"></a>3. 什么是nuxt</h3><p>Nuxt.js是使用Webpack和Node.js进行封装的基于Vue的SSR框架</p><h4 id="nuxt特点"><a href="#nuxt特点" class="headerlink" title="nuxt特点"></a>nuxt特点</h4><p>优点：<br>更好的SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。首屏渲染速度快</p><p>缺点：<br>Node.js中渲染完整的应用程序，显然只比提供静态文件的服务器更多占用CPU资源。需要考虑服务器负载，缓存策略</p><p>具体查看<a href="https://zh.nuxtjs.org/guide/installation">nuxt.js官方文档</a></p><h3 id="4-webpack打包优化"><a href="#4-webpack打包优化" class="headerlink" title="4.  webpack打包优化"></a>4.  webpack打包优化</h3><ol><li>使用cdn方式加载第三方模块，设置<a href="https://webpack.docschina.org/configuration/externals/">externals</a>.</li></ol><p>例如，从 CDN 引入 jQuery，而不是把它打包：<br>index.html</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span></span><br><span class="hljs-tag">  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">integrity</span>=<span class="hljs-string">&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>webpack.config.js</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">module.exports = &#123;<br>  //...<br>  externals: &#123;<br>    jquery: &#x27;jQuery&#x27;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li><p>多线程打包<code>happypack</code><br>具体查看这篇文章<a href="https://juejin.im/post/5c6e0c3a518825621f2a6f45">使用 happypack 提升 Webpack 项目构建速度</a></p></li><li><p>splitChunks抽离公共文件</p></li><li><p>sourceMap的配置</p><blockquote><p>webpack性能优化具体看<a href="https://www.waterbang.top/2019/11/24/2019-11-24-webpack-webpack%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96/">webpack各种优化</a><br>webpack-bundle-analyzer 分析打包插件</p></blockquote></li></ol><h3 id="5-服务端缓存，客户端缓存"><a href="#5-服务端缓存，客户端缓存" class="headerlink" title="5.  服务端缓存，客户端缓存"></a>5.  服务端缓存，客户端缓存</h3><p>##6.   服务端gzip压缩<br>可以减小文件体积，传输速度更快。gzip是节省带宽和加快站点速度的有效方法。<br>具体查看<a href="https://juejin.im/post/5cb7ee0e51882532fe3440ea">「简明性能优化」双端开启Gzip指南</a></p><h2 id="结束语-🏐"><a href="#结束语-🏐" class="headerlink" title="结束语 🏐"></a>结束语 🏐</h2><p>人悄悄，帘外月胧明。「小重山·昨夜寒蛩不住鸣」——岳飞</p>]]></content>
    
    
    
    <tags>
      
      <tag>VUE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写Mini Vue-Router &amp;&amp; Mini Vuex</title>
    <link href="/2019/12/10/2019-12-10-VUE-vuex-vue-router%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <url>/2019/12/10/2019-12-10-VUE-vuex-vue-router%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="初始化项目-🏃"><a href="#初始化项目-🏃" class="headerlink" title="初始化项目 🏃"></a>初始化项目 🏃</h4><p>首先用vue-cli初始化我们的项目，分别选择</p><div class="hljs code-wrapper"><pre><code class="hljs">? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Router, Vuex, Linter? Use history mode for router? (Requires proper server setup for index fallback in production) No? Pick a linter / formatter config: Airbnb? Pick additional lint features: Lint on save, Lint and fix on commit? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files? Save this as a preset for future projects? No</code></pre></div><br><p>在<code>.eslintrc.js</code>里添加规则，</p><div class="hljs code-wrapper"><pre><code class="hljs">  rules: &#123;    &#39;no-console&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;,    &#39;no-debugger&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;,    &#39;no-sequences&#39;: 0,    &#39;no-param-reassign&#39;: 0,    &#39;implicit-arrow-linebreak&#39;: 0,    &#39;no-return-assign&#39;: 0,    &#39;no-underscore-dangle&#39;: 0,    &#39;no-restricted-globals&#39;: 0,    &#39;no-unused-expressions&#39;: 0,    &#39;no-unused-vars&#39;: 0,  &#125;,</code></pre></div><h2 id="Vue-router-🍭"><a href="#Vue-router-🍭" class="headerlink" title="Vue-router 🍭"></a>Vue-router 🍭</h2><p>首先我们将 <code>/router/index.js</code> 文件里的vue-router 改写成我们的,&#x2F;vue-router</p><div class="hljs code-wrapper"><pre><code class="hljs">//   /src/router/index.jsimport Vue from &#39;vue&#39;;import VueRouter from &#39;./vue-router&#39;;//改成自己的import Home from &#39;../views/Home.vue&#39;;import About from &#39;../views/About.vue&#39;;Vue.use(VueRouter);</code></pre></div><br><h3 id="初始化自己的vue-router-🎨"><a href="#初始化自己的vue-router-🎨" class="headerlink" title="初始化自己的vue-router 🎨"></a>初始化自己的vue-router 🎨</h3><p>第一步<code>Vue.use(VueRouter)</code>,默认调用了install方法，并传入了一个vue的构造函数。<br> 可以用来扩展属性或者组件或者指令。   </p><div class="hljs code-wrapper"><pre><code class="hljs">//   /src/router/vue-router.jslet Vue;// 存起来class Router &#123;&#125;;Router.install = (_Vue) =&gt; &#123;  Vue = _Vue; &#125;;export default Router;</code></pre></div><p>第二步，我们的根组件里面会传一个<code>router</code>,让子组件都可以拿到这个<code>router</code>。</p><div class="hljs code-wrapper"><pre><code class="hljs">//  /main.jsnew Vue(&#123;  router,  store,  render: h =&gt; h(App),&#125;).$mount(&#39;#app&#39;);</code></pre></div><p>我们可以直接这样写</p><div class="hljs code-wrapper"><pre><code class="hljs">Vue.prototype.router = xxxx;</code></pre></div><p>但是这样在每次<code>new Vue</code> 的时候都会带上router，我们希望在根组件以下才有。所以我们使用<code>Vue.mixin</code>,<br>它内部会把这个对象给每个属性，混合在一起。它内部就是将组件的生命周期做个数组，它会把mixin的方法放在前面，<br>组件的方法放在后面，像这样 <code>[beforeCreate,befoureCrate]</code>,执行的时候，循环。</p><div class="hljs code-wrapper"><pre><code class="hljs"> //   /src/router/vue-router.jsRouter.install = (_Vue) =&gt; &#123;  Vue = _Vue;  Vue.mixin(&#123;    beforeCreate() &#123; // 组件创建之前，走这方法      if(this.$options.router)&#123; //  判断根组件是谁      &#125;    &#125;,  &#125;)&#125;;</code></pre></div><p>这个<code>$options</code>,指的是<code>new Vue</code>传的内容，也就是下面代码的3，4，5行。</p><div class="hljs code-wrapper"><pre><code class="hljs">//  /main.jsnew Vue(&#123;  router,  store,  render: h =&gt; h(App),&#125;).$mount(&#39;#app&#39;);</code></pre></div><br><h4 id="完善mixin-🏋️‍♂️"><a href="#完善mixin-🏋️‍♂️" class="headerlink" title="完善mixin 🏋️‍♂️"></a>完善mixin 🏋️‍♂️</h4><p>让根组件下都有这个<code>router</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  /src/router/vue-router.js</span><br><span class="hljs-title class_">Router</span>.<span class="hljs-property">install</span> = <span class="hljs-function">(<span class="hljs-params">_Vue</span>) =&gt;</span> &#123;<br>  <span class="hljs-title class_">Vue</span> = _Vue;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;<br>    <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 组件创建之前，走这方法</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>) &#123; <span class="hljs-comment">//看看是不是根组件</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//  如果不是父亲就是儿子</span><br>        <span class="hljs-comment">//  让所有的子组件都有router属性，指向当前 router</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-property">router</span>;<br>      &#125;<br>    &#125;,<br>  &#125;);<br>&#125;;<span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;br&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">### 添加$route $router router-link router-view 🍕</span><br><span class="hljs-string">每个组件都有 `</span>$route<span class="hljs-string">` `</span>$router<span class="hljs-string">` 我们接下来来添加它们，并注册一下两个组件</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>javascript<br><span class="hljs-comment">//  /src/router/vue-router.js</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Vue</span>;<span class="hljs-comment">// 存起来</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Router</span> &#123;<br>&#125;<br><br><span class="hljs-title class_">Router</span>.<span class="hljs-property">install</span> = <span class="hljs-function">(<span class="hljs-params">_Vue</span>) =&gt;</span> &#123;<br>  <span class="hljs-title class_">Vue</span> = _Vue;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;<br>    <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 组件创建之前，走这方法</span><br>      <span class="hljs-comment">//  判断根组件是谁</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//  如果不是父亲就是儿子</span><br>        <span class="hljs-comment">//  让所有的子组件都有router属性，指向当前 router</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-property">router</span>;<br>      &#125;<br>        <span class="hljs-comment">//  $route $router</span><br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&#x27;$route&#x27;</span>, &#123;<br>        <span class="hljs-attr">value</span>: &#123;&#125;,<br>      &#125;);<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&#x27;$router&#x27;</span>, &#123;<br>        <span class="hljs-attr">value</span>: &#123;&#125;,<br>      &#125;);<br>    &#125;,<br>  &#125;);<br> <span class="hljs-comment">// router-link router-view</span><br>      <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;router-link&#x27;</span>, &#123;<br>        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;,<br>      &#125;);<br>      <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;router-view&#x27;</span>, &#123;<br>        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;,<br>      &#125;);<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Router</span>;<br></code></pre></div></td></tr></table></figure><h4 id="完善-router-link-🍔"><a href="#完善-router-link-🍔" class="headerlink" title="完善 router-link 🍔"></a>完善 router-link 🍔</h4><p>第一步，我们完善<code>to</code>。（<del>我们也就一步</del>）</p><div class="hljs code-wrapper"><pre><code class="hljs">&lt;!-- 字符串 --&gt;&lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt;</code></pre></div><p>像这样</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  /src/router/vue-router.js</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;router-link&#x27;</span>, &#123;<br><span class="hljs-attr">props</span>: &#123;<br>  <span class="hljs-attr">to</span>: <span class="hljs-title class_">String</span>,<br>&#125;,<br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#123;</span>`#$&#123;<span class="hljs-attr">this.to</span>&#125;`&#125;&gt;</span>&#123;this.$slots.default&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>;<br>&#125;,<br>&#125;);<br></code></pre></div></td></tr></table></figure><h3 id="接收路由，渲染组件-🚄"><a href="#接收路由，渲染组件-🚄" class="headerlink" title="接收路由，渲染组件 🚄"></a>接收路由，渲染组件 🚄</h3><p>我们在<code>/src/router/index.js</code>里，有个路由表，并在<code>new VueRouter</code>的时候传了进去，<br>接下来我们在VueRouter的构造函数里接收一下，并将它格式化为这样的格式：</p><div align=center>`{'/': Home, '/about':'xxx'}`</div>这样我切谁，就将对于的组件渲染上去。<p>我们的routes长这样。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  /src/router/index.js</span><br><span class="hljs-keyword">const</span> routes = [ <span class="hljs-comment">// &#123;&#x27;/&#x27;: Home, &#x27;/about&#x27;:&#x27;xxx&#x27;&#125;</span><br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;about&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">About</span>,<br>  &#125;,<br>];<br></code></pre></div></td></tr></table></figure><p>我们在构造函数里接收，并格式化<code>routes</code>。</p><div class="hljs code-wrapper"><pre><code class="hljs">//  /src/router/vue-router.jsclass Router &#123;  constructor(&#123; routes &#125;) &#123;    this.routeMap = routes.reduce((memo, current) =&gt;    (memo[current.path] = current.component, memo), &#123;&#125;);    console.log(this.routeMap);  &#125;&#125;</code></pre></div><p>上面的意思是：将值取出来（current）,将path赋给当前的memo，值为current.component。<br>打印后长这样<br><img src="/./routes1.png" alt="router1"></p><h4 id="渲染组件到-router-view-🚅"><a href="#渲染组件到-router-view-🚅" class="headerlink" title="渲染组件到 router-view 🚅"></a>渲染组件到 router-view 🚅</h4><p>我们先将路由固定为<code>home</code>页面</p><div class="hljs code-wrapper"><pre><code class="hljs"> //  /src/router/vue-router.js    class Router &#123;      constructor(&#123; routes &#125;) &#123;        this.routeMap = routes.reduce((memo, current) =&gt;        (memo[current.path] = current.component, memo), &#123;&#125;);        this.route = &#123; current: &#39;/&#39; &#125;;   // 增加了这行      &#125;    &#125;</code></pre></div><p>然后修改<code>router-view</code>来渲染。</p><div class="hljs code-wrapper"><pre><code class="hljs">  Vue.component(&#39;router-view&#39;, &#123;    render(h) &#123; //  这个this是个代理对象      return h(this.router.routeMap[this.router.route.current]);    &#125;,  &#125;);</code></pre></div><h4 id="监听几个事件-🚈"><a href="#监听几个事件-🚈" class="headerlink" title="监听几个事件 🚈"></a>监听几个事件 🚈</h4><p>监听<code>load</code>事件。（组件加载完会执行），先看看当前组件有没有hash.</p><blockquote><p>路由分为两种：一种是hash的<code>#</code> ，另一种是h5的API <code>/</code> .<br>hash不利已SEO优化，但是比较容易。</p></blockquote><p>监听<code>hashchange</code>事件，在改变的时候将路由改掉。</p><div class="hljs code-wrapper"><pre><code class="hljs">//  /src/router/vue-router.jsclass Router &#123;  constructor(&#123; routes &#125;) &#123;    this.routeMap = routes.reduce((memo, current) =&gt;      (memo[current.path] = current.component, memo), &#123;&#125;);    this.route = &#123; current: &#39;/ &#125;;    window.addEventListener(&#39;load&#39;, () =&gt; &#123;      location.hash ? &#39;&#39; : location.hash = &#39;/&#39;;    &#125;);    window.addEventListener(&#39;hashchange&#39;, () =&gt; &#123;      this.route.current = location.hash.slice(1);    &#125;);  &#125;&#125;</code></pre></div><p>但是我们的this.route.current并不是一个响应式数据，改了值以后视图不会刷新。<br><strong>如何将不是响应式的数据变成响应式数据呢？</strong></p><div class="hljs code-wrapper"><pre><code class="hljs"> Vue.util.defineReactive(this, &#39;route&#39;, &#123; current: &#39;/&#39; &#125;);</code></pre></div><p>上面代码的意思：就是给这个人（<code>this</code>）,定义一个这样的数据（<code>route</code>），值是（<code>&#123; current: &#39;/&#39; &#125;</code>） ；</p><p>接下来我们来写 <code>mini vuex</code>;</p><h2 id="Store-👳‍♀️"><a href="#Store-👳‍♀️" class="headerlink" title="Store 👳‍♀️"></a>Store 👳‍♀️</h2><p>store的模式跟router的套路一样。它 new 了一个 <code>Vuex.Store</code>导出后，放到<code>/main.js</code>里面来，<br>然后放到它的实例里面。让每个人都有this.$store。<br>让我们来写出我们的套路,（也是<del>写插件</del>的套路），新建<code>/src/store/vuex.js</code>,代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs">//  /src/store/vuex.jslet Vue;class Store &#123;&#125;const install = (_Vue) =&gt; &#123;  Vue = _Vue;&#125;;export default &#123;  Store,  install,&#125;;</code></pre></div><p>接下来我们需要接收一下new传进来的参数，并且给组件注入一个$store。</p><div class="hljs code-wrapper"><pre><code class="hljs">//  /src/store/vuex.jslet Vue;class Store &#123;  constructor(options) &#123;  &#125;&#125;const install = (_Vue) =&gt; &#123;  Vue = _Vue;  Vue.mixin(&#123;    beforeCreate() &#123;      if (this.$options &amp;&amp; this.$options.store) &#123;        this.$store = this.$options.store;      &#125; else &#123;        this.$store = this.$parent &amp;&amp; this.$parent.$store;      &#125;    &#125;,  &#125;)&#125;;export default &#123;  Store,  install,&#125;;</code></pre></div><h3 id="开始共享我们的数据-👲"><a href="#开始共享我们的数据-👲" class="headerlink" title="开始共享我们的数据 👲"></a>开始共享我们的数据 👲</h3><p>我们先在<code>/src/store/index.js</code>,放个值。</p><div class="hljs code-wrapper"><pre><code class="hljs"> state: &#123;    name: &#39;waterbang&#39;  &#125;,</code></pre></div><p>然后在<code>/src/store/index.js</code>,接收：</p><div class="hljs code-wrapper"><pre><code class="hljs">constructor(options) &#123;    this.state = options.state; &#125;</code></pre></div><p>这样我们就可以共享数据，并在组件内使用<code> &#123;&#123;this.$store.state&#125;&#125;</code>取到数据了。</p><h3 id="接着修改我们的数据-🧔"><a href="#接着修改我们的数据-🧔" class="headerlink" title="接着修改我们的数据 🧔"></a>接着修改我们的数据 🧔</h3><p>第一步，先在<code>/src/store/index.js</code>,里定义<code>mutations</code>里的函数:</p><div class="hljs code-wrapper"><pre><code class="hljs"> mutations: &#123;    setUsername(state) &#123;      state.name = &#39;water&#39;;    &#125;,  &#125;,  </code></pre></div><p>第二步，在<code>App.vue</code>里，定义<code>commit</code>：</p><div class="hljs code-wrapper"><pre><code class="hljs">  mounted() &#123;    this.$store.commit(&#39;setUsername&#39;);  &#125;,  </code></pre></div><p>第三步，由于commit是$store里的方法，我们接下来在我们的<code>vuex</code>里面来新建这个方法：</p><div class="hljs code-wrapper"><pre><code class="hljs">// /src/store/vuex.jsclass Store &#123;  constructor(options) &#123;    this.state = options.state;    this.mutations = options.mutations; // 取出mutations  &#125;  commit = (eventName) =&gt; &#123;    this.mutations[eventName](this.state); //   匹配对应的函数，并执行  &#125;&#125;</code></pre></div><p>但是，问题来了，到现在为止，我们刷新，视图还是不会变，这是因为我们的数据是直接传进来的,并不是响应式数据。</p><p>我们可以采用 <code>new Vue</code> 创建一个实例来解决，将状态变成响应式的，如果数据更新，则视图刷新。<br>如果想要深入了解响应式原理看这位大佬写的<a href="https://juejin.im/post/5d4ad8686fb9a06b2766b625">Vue原理解析（六）：全面深入理解响应式原理(上)-对象基础篇</a>。</p><div class="hljs code-wrapper"><pre><code class="hljs"> // /src/store/vuex.jsclass Store &#123;  constructor(options) &#123;    this.vm = new Vue(&#123;      data: &#123; state: options.state &#125;,    &#125;);    this.state = this.vm.state;    this.mutations = options.mutations;  &#125;  commit = (eventName) =&gt; &#123;    this.mutations[eventName](this.state);  &#125;&#125;</code></pre></div><p>这样就实现了基本的<code>mutations</code>。</p><h4 id="actions-🎅"><a href="#actions-🎅" class="headerlink" title="actions 🎅"></a>actions 🎅</h4><p>接下来轮到了<code>actions</code>。</p><p>第一步先来增加一下<code>actions</code>里的方法。</p><div class="hljs code-wrapper"><pre><code class="hljs">actions: &#123;    setUsername(&#123; commit &#125;) &#123;      setTimeout(() =&gt; &#123;        commit(&#39;setUsername&#39;);      &#125;, 1000);    &#125;,  &#125;,  </code></pre></div><p>然后到App.vue里修改一下内容。</p><div class="hljs code-wrapper"><pre><code class="hljs"> mounted() &#123;    this.$store.dispatch(&#39;setUsername&#39;);  &#125;,</code></pre></div><p>最后我们到<code>/src/store/vuex.js</code>，里增加我们的<code>dispatch</code>方法。</p><div class="hljs code-wrapper"><pre><code class="hljs">class Store &#123;  constructor(options) &#123;    this.vm = new Vue(&#123;      data: &#123; state: options.state &#125;,    &#125;);    this.state = this.vm.state;    this.mutations = options.mutations;    this.actions = options.actions;  &#125;  commit = (eventName) =&gt; &#123;    this.mutations[eventName](this.state);  &#125;  dispatch = (eventName) =&gt; &#123;    this.actions[eventName](this); //这里的this是当前的Store  &#125;&#125;</code></pre></div><p>然后我们的<code>actions</code>完成了,刷新后过一秒更新数据。</p><h2 id="结束语-🏐"><a href="#结束语-🏐" class="headerlink" title="结束语 🏐"></a>结束语 🏐</h2><p>花雾萦风缥缈，歌珠滴水清圆。「西江月·别梦已随流水」——苏轼。</p>]]></content>
    
    
    
    <tags>
      
      <tag>VUE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWA-离线优先中的缓存模式</title>
    <link href="/2019/12/01/2019-12-1-PWA-%E7%A6%BB%E7%BA%BF%E4%BC%98%E5%85%88%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/12/01/2019-12-1-PWA-%E7%A6%BB%E7%BA%BF%E4%BC%98%E5%85%88%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是离线优先"><a href="#什么是离线优先" class="headerlink" title="什么是离线优先"></a>什么是离线优先</h4><p>离线优先允许用户在网络不好的情况下，也能放心的使用这个应用，并且的数据不会丢失。<br>离线优先意味着，总是基于当前网络，获得最佳体验。</p><br><h3 id="常用的缓存模式-🍭"><a href="#常用的缓存模式-🍭" class="headerlink" title="常用的缓存模式 🍭"></a>常用的缓存模式 🍭</h3><p>下面来看几种常见的缓存模式。</p><h4 id="仅缓存"><a href="#仅缓存" class="headerlink" title="仅缓存"></a>仅缓存</h4><p>这种模式对静态资源非常实用，代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs">self.addEventLister(&quot;fetch&quot;,function(event)&#123;    event.respondWith(    caches.match(event.request);    );&#125;);</code></pre></div><br><h4 id="缓存优先，网络作为回退方案"><a href="#缓存优先，网络作为回退方案" class="headerlink" title="缓存优先，网络作为回退方案"></a>缓存优先，网络作为回退方案</h4><p>这个模式也会从缓存中相应请求。然而，如果在缓存中找不到内容，service worker 会从网络中请求并返回：</p><div class="hljs code-wrapper"><pre><code class="hljs">self.addEventListener(&quot;fetch&quot;,function(event)&#123;    event.respondWith(        caches.match(event.resquest).then((response)=&gt;&#123;            return response|| fetch(event.request);        &#125;)    )&#125;);</code></pre></div><br><h4 id="仅网络"><a href="#仅网络" class="headerlink" title="仅网络"></a>仅网络</h4><p>经典的web模型，尝试从网络中请求，网络不通，则请求失败。</p><div class="hljs code-wrapper"><pre><code class="hljs">self.addEventListener(&quot;fetch&quot;,function(event)&#123;    event.respondWith(    fetch(event.request)   );&#125;);</code></pre></div><br>    <h4 id="网络优先，缓存做为回退方案。"><a href="#网络优先，缓存做为回退方案。" class="headerlink" title="网络优先，缓存做为回退方案。"></a>网络优先，缓存做为回退方案。</h4><p>总是向网络发起请求，请求失败则返回缓存中的版本。</p><div class="hljs code-wrapper"><pre><code class="hljs">self.addEventListener(&quot;fetch&quot;,function(event)&#123;    event.respondWith(        caches.match(event.resquest).catch(()=&gt;&#123;           return caches.match(event.request);        &#125;)    )&#125;);</code></pre></div><br><h4 id="网络优先，缓存作为回退方案，通用回退作为兜底方案"><a href="#网络优先，缓存作为回退方案，通用回退作为兜底方案" class="headerlink" title="网络优先，缓存作为回退方案，通用回退作为兜底方案"></a>网络优先，缓存作为回退方案，通用回退作为兜底方案</h4><div class="hljs code-wrapper"><pre><code class="hljs">self.addEventListener(&quot;fetch&quot;,function(event)&#123;    event.respondWith(        caches.match(event.resquest).catch(()=&gt;&#123;           return caches.match(event.request).then((response)=&gt;&#123;            return response || caches.match(&quot;/generic.png&quot;);           &#125;);        &#125;)    );&#125;);</code></pre></div><br>    <h4 id="按需缓存"><a href="#按需缓存" class="headerlink" title="按需缓存"></a>按需缓存</h4><p>对于不经常改变的资源以及service worker install 事件期间不想缓存的资源，我们可以扩展<code>缓存优先，网络作为回退方案</code>的模式。将网络返回的请求保存到缓存中。</p><div class="hljs code-wrapper"><pre><code class="hljs">self.addEventListener(&quot;fetch&quot;, function (event) &#123;    event.respondWith(        caches.open(&#39;cache-name&#39;).then((cache) =&gt; &#123;                return caches.match(event.request).then((cachedResponse) =&gt; &#123;                    return cachedResponse || fetch(event.request).then((networkResponse)&#123;                        cache.put(event.request, networkResponse.clone());                        return networkResponse;                    &#125;)                &#125;);            &#125;)    );&#125;);</code></pre></div><p>在响应保存到缓存中时，我们对其使用了一个clone方法。</p><div class="hljs code-wrapper"><pre><code class="hljs">    fetch(event.request).then((networkResponse)&#123;        cache.put(event.request, networkResponse.clone());        return networkResponse;    &#125;)；</code></pre></div><p>这是因为我们打算不止一次使用它（将其放入缓存并使用它来相应事件）。这样就要确保使用clone命令来复制它。</p><br><h4 id="缓存优先，网络作为回退方案，并频繁更新缓存"><a href="#缓存优先，网络作为回退方案，并频繁更新缓存" class="headerlink" title="缓存优先，网络作为回退方案，并频繁更新缓存"></a>缓存优先，网络作为回退方案，并频繁更新缓存</h4><p>对于经常修改的资源（如用户头像），我们可以修改<code>缓存优先，网络作为回退方案</code>的模式。即使在缓存中找到，也总会从缓存中请求资源。</p><div class="hljs code-wrapper"><pre><code class="hljs">self.addEventListener(&quot;fetch&quot;, function (event) &#123;    event.respondWith(        caches.open(&#39;cache-name&#39;).then((cache) =&gt; &#123;            return caches.match(event.resquest).then((cachedResponse) =&gt; &#123;                    const fetchPromise = fetch(event.request).then((networkResponse)&#123;                        cache.put(event.request, networkResponse.clone());                        return networkResponse;                    &#125;);                    return cachedResponse || fetchPromise;                &#125;);            &#125;)    );&#125;);</code></pre></div><br><h4 id="网络优先，缓存作为回退方案，并频繁更新缓存。"><a href="#网络优先，缓存作为回退方案，并频繁更新缓存。" class="headerlink" title="网络优先，缓存作为回退方案，并频繁更新缓存。"></a>网络优先，缓存作为回退方案，并频繁更新缓存。</h4><p>该模式总会试图从网络中获取最新版本，仅在网络请求失败的时候才回退到缓存版本。<br>每当网络访问成功时，会将当前缓存更新为视为网络响应的内容。</p><div class="hljs code-wrapper"><pre><code class="hljs">self.addEventListener(&quot;fetch&quot;, function (event) &#123;    event.respondWith(        caches.open(&#39;cache-name&#39;).then((cache) =&gt; &#123;            return caches.match(event.resquest).then((cachedResponse) =&gt; &#123;                cache.put(event.request, networkResponse.clone());                return networkResponse;                &#125;).catch(()=&gt;&#123;                    return cache.match(event.request);                &#125;);            &#125;)    );&#125;);</code></pre></div><br>    <h3 id="总结一下缓存策略-🎄"><a href="#总结一下缓存策略-🎄" class="headerlink" title="总结一下缓存策略 🎄"></a>总结一下缓存策略 🎄</h3><ol><li>使用<code>缓存优先，网络作为回退方案，并频繁更新缓存模式</code>返回index.html文件。</li><li>使用<code>缓存优先，网络作为回退方案</code>,返回首页需要展示的所有静态文件。</li><li>从网络中返回谷歌地图的javascript文件，如果请求失败，则返回一个代替的脚本。</li><li>使用<code>网络优先，缓存作为回退方案，并频繁更新缓存模式</code>,返回events.json文件。</li><li>使用<code>按需缓存模式</code>返回事件的图片文件，如果网络不可用并且图片没有缓存，则退回到默认的通用图片。</li><li><code>数据分析</code>请求直接通过，不做处理。</li></ol><br><h4 id="结束🐟"><a href="#结束🐟" class="headerlink" title="结束🐟"></a>结束🐟</h4><p>握手西风泪不干，年来多在别离间。「于中好·握手西风泪不干」——纳兰性德</p>]]></content>
    
    
    
    <tags>
      
      <tag>Progressive Web App</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript-使用typescript构建vue应用</title>
    <link href="/2019/11/25/2019-11-25-TypeScript-%E4%BD%BF%E7%94%A8typescript%E6%9E%84%E5%BB%BAvue%E5%BA%94%E7%94%A8/"/>
    <url>/2019/11/25/2019-11-25-TypeScript-%E4%BD%BF%E7%94%A8typescript%E6%9E%84%E5%BB%BAvue%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="砍柴先磨刀-🎄"><a href="#砍柴先磨刀-🎄" class="headerlink" title="砍柴先磨刀 🎄"></a>砍柴先磨刀 🎄</h3><p>我们使用VSCode来进行编码，首先我们要安装<code>TSLint</code>和<code>TSLint Vue</code>来规范和校验我们的编码。（代码质量第一位）<br>(<em>这两个家伙会经常发生失灵的情况</em>)</p><h4 id="配置TSLint"><a href="#配置TSLint" class="headerlink" title="配置TSLint"></a>配置TSLint</h4><ol><li><p>打开 File-&gt;Preferences-&gt;Settings</p></li><li><p>搜索TSLint</p></li><li><p>打开Settings.json</p></li><li><p>将下面代码复制进去</p><div class="hljs code-wrapper"><pre><code class="hljs">    //setting.json  &#123;    &quot;editor.codeActionsOnSave&quot;: &#123;        &quot;source.fixAll.tslint&quot;: true    &#125;,  &#125;</code></pre></div></li><li><p>我是关闭vsCode然后再打开生效的。</p></li></ol><h4 id="创建类的Vue模板"><a href="#创建类的Vue模板" class="headerlink" title="创建类的Vue模板"></a>创建类的Vue模板</h4><ol><li><p>点击File-&gt;Preferences-&gt;User Snippets </p></li><li><p>然后点击 New Snippets 新建文件 <code>vuets-code-snippet.json.code-snippets</code></p></li></ol><img src="./snippets.png" ><ol start="3"><li><p>将下列模板复制进去</p><p>&#x2F;&#x2F;vuets-code-snippet.json.code-snippets<br>{<br>“Print to console”: {<br>    “prefix”: “vuets”,<br>    “body”: [<br>        “<template>“,<br>        “”,<br>        “</template>“,<br>        “<script lang='ts'>",<br>        "import { Component, Vue, Prop } from 'vue-property-decorator';",<br>        "import  from '@/components/ .vue'",<br>        "@Component({",<br>        "    components: {",<br>        "        ",<br>        "    }",<br>        "})",<br>        "export default class componentName extends Vue {",<br>        "    @Prop(type)private propName = propValue;",<br>        "    private variableName: typeName = variableValue;",<br>        "    public methodName() {",<br>        "        ",<br>        "    }",<br>        "}",<br>        "</script>“,<br>        “<style lang='less' scoped >“,<br>        “”,<br>        “</style>“<br>    ],<br>    “description”: “basic vue typescript template”<br>}<br>}</p></li><li><p>然后在.vue文件就可以打出<code>vuets</code> 加<code>Tab</code> 就可以生成模板啦。</p></li></ol><h3 id="使用vue-cli创建项目"><a href="#使用vue-cli创建项目" class="headerlink" title="使用vue-cli创建项目"></a>使用vue-cli创建项目</h3><p> 选择typescript,其他按照需求来</p><div class="hljs code-wrapper"><pre><code class="hljs">  (*) Babel  (*) TypeScript  ( ) Progressive Web App (PWA) Support  (*) Router  (*) Vuex  (*) CSS Pre-processors  (*) Linter / Formatter  ( ) Unit Testing  ( ) E2E Testing</code></pre></div><h4 id="献上代码规范"><a href="#献上代码规范" class="headerlink" title="献上代码规范"></a>献上代码规范</h4><p>直接复制下面代码粘贴到你的<code>tslint.json</code>就可以了，然后想深入了解可以看<a href="https://ts.xcatliu.com/engineering/lint">官方tslint.json设置篇</a></p><div class="hljs code-wrapper"><pre><code class="hljs">&#123;  &quot;defaultSeverity&quot;: &quot;warning&quot;,  &quot;extends&quot;: [      &quot;tslint:recommended&quot;  ],  &quot;linterOptions&quot;: &#123;      &quot;exclude&quot;: [          &quot;node_modules/**&quot;      ]  &#125;,  &quot;no-trailing-whitespace&quot;: false,  &quot;rules&quot;: &#123;      &quot;quotemark&quot;: false,      &quot;indent&quot;: [true, &quot;spaces&quot;, 4],      &quot;interface-name&quot;: false,      &quot;ordered-imports&quot;: false,      &quot;object-literal-sort-keys&quot;: false,      &quot;no-console&quot;: false,      &quot;no-debugger&quot;: false,           &quot;no-unused-expression&quot;: [true, &quot;allow-fast-null-checks&quot;],       &quot;no-unused-variable&quot;: false,       &quot;triple-equals&quot;: true,      &quot;no-parameter-reassignment&quot;: true,      &quot;no-conditional-assignment&quot;: true,      &quot;no-construct&quot;: true,       &quot;no-duplicate-super&quot;: true,       &quot;no-duplicate-switch-case&quot;: true,      &quot;no-object-literal-type-assertion&quot;: true,       &quot;no-return-await&quot;: true,       &quot;no-sparse-arrays&quot;: true,       &quot;no-string-throw&quot;: true,      &quot;no-switch-case-fall-through&quot;: true,       &quot;prefer-object-spread&quot;: true,       &quot;radix&quot;: true,       &quot;cyclomatic-complexity&quot;: [          true,          20      ],       &quot;deprecation&quot;: true,       &quot;use-isnan&quot;: true,       &quot;no-duplicate-imports&quot;: true,       &quot;no-mergeable-namespace&quot;: true,       &quot;encoding&quot;: true,       &quot;import-spacing&quot;: true,      &quot;interface-over-type-literal&quot;: true,      &quot;new-parens&quot;: true,      &quot;no-angle-bracket-type-assertion&quot;: true,       &quot;no-consecutive-blank-lines&quot;: [          true,          3      ]      &#125;&#125;</code></pre></div><h3 id="我们来实现todoItem"><a href="#我们来实现todoItem" class="headerlink" title="我们来实现todoItem"></a>我们来实现todoItem</h3><h4 id="抽离接口文件"><a href="#抽离接口文件" class="headerlink" title="抽离接口文件"></a>抽离接口文件</h4><p>接口是可以导出的，我们将接口抽离出来<br>在src目录下新建types文件夹，新建todo.ts文件，内容如下</p><div class="hljs code-wrapper"><pre><code class="hljs">export interface ITodo &#123;    text: string;    complete: boolean;&#125;</code></pre></div><h4 id="创建基础文件"><a href="#创建基础文件" class="headerlink" title="创建基础文件"></a>创建基础文件</h4><p>我们可以先了解：<a href="https://www.npmjs.com/package/vue-property-decorator">Vue属性装饰器</a>,让我们更快的编码。</p><blockquote><p>@Prop<br>  @PropSync<br>  @Model<br>  @Watch<br>  @Provide<br>  @Inject<br>  @ProvideReactive<br>  @InjectReactive<br>  @Emit<br>  @Ref<br>  @Component（由 vue-class-component提供）<br>  Mixins（mixins 由 vue-class-component 提供的名为helper的函数）</p></blockquote><h5 id="Home-vue应该像这样"><a href="#Home-vue应该像这样" class="headerlink" title="Home.vue应该像这样"></a>Home.vue应该像这样</h5><div class="hljs code-wrapper"><pre><code class="hljs">/src/views/Home.vue&lt;template&gt;  &lt;div&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(item,index) in lists&quot; :key=&quot;index&quot;&gt;        &lt;TodoItem :item=&quot;item&quot; :index=&quot;index&quot; @say=&quot;say&quot;&gt;&lt;/TodoItem&gt;      &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&#39;ts&#39;&gt;import &#123; Component, Vue &#125; from &quot;vue-property-decorator&quot;;import TodoItem from &quot;../components/TodoItem&quot;;import &#123; ITodo &#125; from &quot;../types/todo&quot;;@Component(&#123;  components: &#123;    TodoItem,  &#125;,&#125;)export default class Home extends Vue &#123;  public lists: ITodo[] = [    &#123; text: &quot;打代码&quot; &#125;,    &#123; text: &quot;睡觉&quot; &#125;,  ];  get count() &#123;    return this.lists.length;  &#125;  public say(): void &#123;    console.log(&quot;你在干啥&quot;);  &#125;&#125;&lt;/script&gt;&#125;</code></pre></div><p>我们先来看一下@Component里面是什么东西</p><div class="hljs code-wrapper"><pre><code class="hljs">import Vue, &#123; ComponentOptions &#125; from &#39;vue&#39;;import &#123; VueClass &#125; from &#39;./declarations&#39;;export &#123; createDecorator, VueDecorator, mixins &#125; from &#39;./util&#39;;declare function Component&lt;V extends Vue&gt;(options: ComponentOptions&lt;V&gt; &amp; ThisType&lt;V&gt;): &lt;VC extends VueClass&lt;V&gt;&gt;(target: VC) =&gt; VC;declare namespace Component &#123;   //外部命名空间声明    var registerHooks: (keys: string[]) =&gt; void;&#125;declare function Component&lt;VC extends VueClass&lt;Vue&gt;&gt;(target: VC): VC;declare namespace Component &#123;    var registerHooks: (keys: string[]) =&gt; void;&#125;export default Component;  //这里我们看得懂</code></pre></div><p>他给我们吐出了一个Component，所以他其实干了这样事</p><div class="hljs code-wrapper"><pre><code class="hljs">export default &#123;    component:&#123;&#125;,    props: &#123;&#125;,    watch: &#123; &#125;&#125;</code></pre></div><h5 id="在-components里新建TodoItem-tsx"><a href="#在-components里新建TodoItem-tsx" class="headerlink" title="在 &#x2F;components里新建TodoItem.tsx"></a>在 &#x2F;components里新建TodoItem.tsx</h5><p>内容如下</p><div class="hljs code-wrapper"><pre><code class="hljs">    /components/TodoItem.tsx import &#123; Component, Vue, Prop &#125; from &#39;vue-property-decorator&#39;; import &#123; ITodo &#125; from &#39;../types/todo&#39;;  @Component export default class TodoItem extends Vue &#123;     @Prop(Object) public item !: ITodo;  //属性传递的方法     @Prop(Number) public index !: number;     public save() &#123;         this.$emit(&#39;say&#39;);     &#125;     public render() &#123;         return &lt;h1&gt;&#123;this.item.text&#125;&lt;button on-click=&#123;this.save&#125;&gt;触发方法&lt;/button&gt;&lt;/h1&gt;;     &#125; &#125;</code></pre></div><p>让我们来认识一下这个语法糖</p><div class="hljs code-wrapper"><pre><code class="hljs">//原来的写法props: &#123;    item: &#123;        type: ITodo,        defalut: &#39;&#39;    &#125;&#125;//语法糖的写法@Prop(Object) public item !: ITodo;  //属性传递的方法</code></pre></div><p>加<code>！</code>的意思是如果是空的，就不校验，代表这个值一定有。</p><h5 id="Emit语法糖"><a href="#Emit语法糖" class="headerlink" title="@Emit语法糖"></a>@Emit语法糖</h5><p>以上代码实现父向子传递数据，和子触发父方法。<br>但是这样写不够好看，官方给我们提供了一个更加美观的装饰器(<code>Emit</code>)。将TodoItem.tsx内容改写如下</p><div class="hljs code-wrapper"><pre><code class="hljs">/src/components/TodoItem.tsximport &#123; Component, Vue, Prop, Emit &#125; from &#39;vue-property-decorator&#39;;import &#123; ITodo &#125; from &#39;../types/todo&#39;;@Componentexport default class TodoItem extends Vue &#123;    @Prop(Object) public item !: ITodo;    @Prop(Number) public index !: number;    @Emit(&#39;say&#39;) //我要触发的是父亲的方法    public save() &#123;         return &quot;hello&quot;;    &#125;    public render() &#123;        return &lt;h1&gt;&#123;this.item.text&#125;&lt;button on-click=&#123;this.save&#125;&gt;触发方法&lt;/button&gt;&lt;/h1&gt;;    &#125;&#125;</code></pre></div><p><code> @Emit(&#39;say&#39;)</code>传入的是父亲的方法，但是如果父亲的方法和要装饰的方法名称相同，里面的内容可以不传<code> @Emit()</code></p><p>那传参怎么传呢？ 我们现在已经return出了一个<code>hello</code>，现在只需要改写一下父亲的方法</p><div class="hljs code-wrapper"><pre><code class="hljs">public say(msg: string): void &#123;    console.log(msg);  &#125;</code></pre></div><p>这样就能接收到数据。</p><h4 id="实现点击加1的操作"><a href="#实现点击加1的操作" class="headerlink" title="实现点击加1的操作"></a>实现点击加1的操作</h4><div class="hljs code-wrapper"><pre><code class="hljs">/src/components/TodoItem.tsximport &#123; Component, Vue, Prop, Emit &#125; from &#39;vue-property-decorator&#39;;import &#123; ITodo &#125; from &#39;../types/todo&#39;;@Componentexport default class TodoItem extends Vue &#123;    public count: number = 1;  //声明常量方法    @Prop(Object) public item !: ITodo;    @Prop(Number) public index !: number;    @Emit(&#39;say&#39;)    public save() &#123;       return &quot;hello&quot;;    &#125;    public increment() &#123;        this.count += 1;    &#125;    public render() &#123;        return &lt;h1&gt;&#123;this.item.text&#125;&lt;button on-click=&#123;this.save&#125;&gt;触发方法&lt;/button&gt;        &#123;this.count&#125;        &lt;button on-click=&#123;this.increment&#125;&gt;点击加一&lt;/button&gt;        &lt;/h1&gt;;    &#125;&#125;</code></pre></div><h5 id="现在我想监控count变化"><a href="#现在我想监控count变化" class="headerlink" title="现在我想监控count变化"></a>现在我想监控count变化</h5><p>Watch装饰器可以满足我们的要求，但是它只能监控方法，或类。</p><div class="hljs code-wrapper"><pre><code class="hljs">/src/components/TodoItem.tsximport &#123; Component, Vue, Prop, Emit, Watch &#125; from &#39;vue-property-decorator&#39;;import &#123; ITodo &#125; from &#39;../types/todo&#39;;@Componentexport default class TodoItem extends Vue &#123;    public count: number = 1;    @Prop(Object) public item !: ITodo;    @Prop(Number) public index !: number;    @Emit(&#39;say&#39;)    public save() &#123;       return &quot;hello&quot;;    &#125;    @Watch(&#39;count&#39;) //监控    public fn()&#123;        console.log(&quot;count加1了&quot;);    &#125;    public increment() &#123;        this.count += 1;    &#125;    public render() &#123;        return &lt;h1&gt;&#123;this.item.text&#125;&lt;button on-click=&#123;this.save&#125;&gt;触发方法&lt;/button&gt;        &#123;this.count&#125;        &lt;button on-click=&#123;this.increment&#125;&gt;点击加一&lt;/button&gt;        &lt;/h1&gt;;    &#125;&#125;</code></pre></div><h4 id="加上vuex"><a href="#加上vuex" class="headerlink" title="加上vuex"></a>加上vuex</h4><h5 id="我们首先改写我们的Home-vue"><a href="#我们首先改写我们的Home-vue" class="headerlink" title="我们首先改写我们的Home.vue"></a>我们首先改写我们的Home.vue</h5><p>该写完应该像下面这样</p><div class="hljs code-wrapper"><pre><code class="hljs">/src/views/Home.vue&lt;template&gt;  &lt;div&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(item,index) in lists&quot; :key=&quot;index&quot;&gt;        &lt;TodoItem :item=&quot;item&quot; :index=&quot;index&quot; @say=&quot;say&quot;&gt;&lt;/TodoItem&gt;      &lt;/li&gt;    &lt;/ul&gt;    &#123;&#123;this.lists&#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&#39;ts&#39;&gt;import &#123; Component, Vue &#125; from &quot;vue-property-decorator&quot;;import TodoItem from &quot;../components/TodoItem&quot;;import &#123; ITodo &#125; from &quot;../types/todo&quot;;import &#123; State, Mutation, Action &#125; from &quot;vuex-class&quot;; //引入@Component(&#123;  components: &#123;    TodoItem,  &#125;,&#125;)export default class Home extends Vue &#123;  @State(&quot;lists&quot;) public lists!: [];  //@State  get count() &#123;    return this.lists.length;  &#125;   @Mutation(&quot;hello&quot;) public say!: () =&gt; void; //触发mutation里的方法  private mounted() &#123;    this.say();  &#125;  //   public say(msg: string): void &#123;  //     console.log(msg);  //   &#125;&#125;&lt;/script&gt;</code></pre></div><h5 id="编写-store-index-ts-文件"><a href="#编写-store-index-ts-文件" class="headerlink" title="编写&#x2F;store&#x2F;index.ts 文件"></a>编写&#x2F;store&#x2F;index.ts 文件</h5><div class="hljs code-wrapper"><pre><code class="hljs">/src/store/index.tsimport Vue from &#39;vue&#39;;import Vuex from &#39;vuex&#39;;Vue.use(Vuex);// tslint:disable-next-line: no-duplicate-importsimport &#123; ITodo &#125; from &#39;../types/todo&#39;;interface IList &#123;  lists: ITodo[];&#125;export default new Vuex.Store&lt; IList&gt;(&#123;  state: &#123;    lists: [      &#123;text: &#39;吃饭&#39;, complete: true&#125;,      &#123;text: &#39;打代码&#39;, complete: false&#125;,    ],  &#125;,  mutations: &#123;    hello() &#123;      console.log(1);    &#125;,  &#125;,  actions: &#123;  &#125;,  modules: &#123;  &#125;,&#125;);</code></pre></div><h4 id="结束🐟"><a href="#结束🐟" class="headerlink" title="结束🐟"></a>结束🐟</h4><p>芙蓉湖上芙蓉花，秋风未落如朝霞。「送荪友」——纳兰性德</p>]]></content>
    
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack各种优化</title>
    <link href="/2019/11/24/2019-11-24-webpack-webpack%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96/"/>
    <url>/2019/11/24/2019-11-24-webpack-webpack%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack各种优化"><a href="#webpack各种优化" class="headerlink" title="webpack各种优化"></a>webpack各种优化</h1><p><a href="http://www.zhufengpeixun.cn/">珠峰架构课</a>webpack课程。</p><p>这是<a href="http://www.zhufengpeixun.cn/">珠峰架构课</a>课件，不是本人编写。</p><p>上一章节我们已经掌握了webpack常见的所有配置</p><p>这一节我们来看看如何实现webpack中的优化，我们先来编写最基本的webpack配置，然后依次实现各种优化！</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptconst MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const path = require(&quot;path&quot;);module.exports = mode =&gt; &#123;  return &#123;    mode: mode,    entry: &quot;./src/main.js&quot;,    output: &#123;      filename: &quot;bundle.js&quot;,      path: path.resolve(__dirname, &quot;dist&quot;)    &#125;,    module: &#123;      rules: [        &#123;          test: /\.(png|jpg|gif)$/,          use: &quot;file-loader&quot;        &#125;,        &#123;          test: /\.js$/,          use: &quot;babel-loader&quot; // .babelrc已经配置支持react        &#125;,        &#123;          test: /\.css$/,          use: [            mode !== &quot;development&quot;              ? MiniCssExtractPlugin.loader              : &quot;style-loader&quot;,            &quot;css-loader&quot;          ]        &#125;      ]    &#125;,    plugins: [      new PurgecssPlugin(&#123;        paths: glob.sync(`$&#123;path.join(__dirname, &quot;src&quot;)&#125;/**/*`, &#123; nodir: true &#125;) // 不匹配目录，只匹配文件      &#125;),      mode !== &quot;development&quot; &amp;&amp;        new MiniCssExtractPlugin(&#123;          filename: &quot;css/[name].css&quot;        &#125;),      new HtmlWebpackPlugin(&#123;        template: &quot;./src/template.html&quot;,        filename: &quot;index.html&quot;      &#125;)    ].filter(Boolean)  &#125;;&#125;;</code></pre></div><p><code>.babelrc</code>配置文件</p><div class="hljs code-wrapper"><pre><code class="hljs">//json&#123;    &quot;presets&quot;: [        &quot;@babel/preset-env&quot;,        &quot;@babel/preset-react&quot;    ]&#125;</code></pre></div><h2 id="1-删除无用的Css样式"><a href="#1-删除无用的Css样式" class="headerlink" title="1.删除无用的Css样式"></a>1.删除无用的Css样式</h2><p>先来看编写的代码</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptimport &#39;./style.css&#39;import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;ReactDOM.render(&lt;div&gt;hello&lt;/div&gt;,document.getElementById(&#39;root&#39;));//cssbody&#123;    background: red&#125;.class1&#123;    background: red&#125;</code></pre></div><blockquote><p>这里的<code>.class1</code>显然是无用的，我们可以搜索<code>src</code>目录下的文件，删除无用的样式</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptconst glob = require(&#39;glob&#39;);const PurgecssPlugin = require(&#39;purgecss-webpack-plugin&#39;);// 需要配合mini-css-extract-plugin插件mode !== &quot;development&quot; &amp;&amp; new PurgecssPlugin(&#123;    paths: glob.sync(`$&#123;path.join(__dirname, &quot;src&quot;)&#125;/**/*`, &#123; nodir: true &#125;) // 不匹配目录，只匹配文件&#125;),</code></pre></div><h2 id="2-图片压缩插件"><a href="#2-图片压缩插件" class="headerlink" title="2.图片压缩插件"></a>2.图片压缩插件</h2><p>将打包后的图片进行优化</p><div class="hljs code-wrapper"><pre><code class="hljs">npm install image-webpack-loader --save-dev</code></pre></div><p>在file-loader之前使用压缩图片插件</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptloader: &quot;image-webpack-loader&quot;,options: &#123;  mozjpeg: &#123;    progressive: true,    quality: 65  &#125;,  // optipng.enabled: false will disable optipng  optipng: &#123;    enabled: false,  &#125;,  pngquant: &#123;    quality: [0.90, 0.95],    speed: 4  &#125;,  gifsicle: &#123;    interlaced: false,  &#125;,  // the webp option will enable WEBP  webp: &#123;    quality: 75  &#125;&#125;</code></pre></div><blockquote><p>可以发现图片大小是有了明显的变化</p></blockquote><h2 id="3-CDN加载文件"><a href="#3-CDN加载文件" class="headerlink" title="3.CDN加载文件"></a>3.CDN加载文件</h2><p>我们希望通过cdn的方式引入资源</p><div class="hljs code-wrapper"><pre><code class="hljs">    //javascript   const AddAssetHtmlCdnPlugin = require(&#39;add-asset-html-cdn-webpack-plugin&#39;)   new AddAssetHtmlCdnPlugin(true,&#123;       &#39;jquery&#39;:&#39;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&#39;   &#125;)   </code></pre></div><p>但是在代码中还希望引入<code>jquery</code>来获得提示</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptimport $ from &#39;jquery&#39;console.log(&#39;$&#39;,$)</code></pre></div><p>但是打包时依然会将<code>jquery</code>进行打包</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptexternals:&#123;  &#39;jquery&#39;:&#39;$&#39;&#125;</code></pre></div><p>在配置文件中标注<code>jquery</code>是外部的，这样打包时就不会将jquery进行打包了</p><h2 id="4-Tree-shaking-Scope-Hoisting"><a href="#4-Tree-shaking-Scope-Hoisting" class="headerlink" title="4.Tree-shaking &amp;&amp; Scope-Hoisting"></a>4.Tree-shaking &amp;&amp; Scope-Hoisting</h2><h3 id="4-1-Tree-shaking"><a href="#4-1-Tree-shaking" class="headerlink" title="4.1 Tree-shaking"></a>4.1 Tree-shaking</h3><p>顾名思义就是将没用的内容摇晃掉,来看下面代码</p><p><code>main.js</code></p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptimport &#123; minus &#125; from &quot;./calc&quot;;console.log(minus(1,1));</code></pre></div><p><code>calc.js</code></p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptimport &#123;test&#125; from &#39;./test&#39;;export const sum = (a, b) =&gt; &#123;  return a + b + &#39;sum&#39;;&#125;;export const minus = (a, b) =&gt; &#123;  return a - b + &#39;minus&#39;;&#125;;</code></pre></div><p><code>test.js</code></p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptexport const test = ()=&gt;&#123;    console.log(&#39;hello&#39;)&#125;console.log(test());</code></pre></div><blockquote><p>观察上述代码其实我们主要使用<code>minus</code>方法,<code>test.js</code>代码是有副作用的! </p></blockquote><p>默认<code>mode:production</code>时，会自动<code>tree-shaking</code>,但是打包后<code>&#39;hello&#39;</code>依然会被打印出来,这时候我们需要配置不使用副作用</p><p>在<code>package.json</code>中配置</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascript&quot;sideEffects&quot;:false,</code></pre></div><p>如果这样设置，默认就不会导入<code>css</code>文件啦，因为我们引入css也是通过<code>import &#39;./style.css&#39;</code></p><p>这里重点就来了,<code>tree-shaking</code>主要针对<strong>es6模块</strong>,我们可以使用<code>require</code>语法导入css,但是这样用起来有点格格不入,所以我们可以配置<code>css</code>文件不是副作用</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascript&quot;sideEffects&quot;:[    &quot;**/*.css&quot;]</code></pre></div><p>在开发环境下默认<code>tree-shaking</code>不会生效,可以配置标识提示</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptoptimization:&#123;  usedExports:true &#125;</code></pre></div><h3 id="4-2-Scope-Hoisting"><a href="#4-2-Scope-Hoisting" class="headerlink" title="4.2 Scope Hoisting"></a>4.2 Scope Hoisting</h3><p>作用域提升,可以减少代码体积，节约内存</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptlet a = 1;let b = 2;let c = 3;let d = a+b+cexport default d;// 引入dimport d from &#39;./d&#39;;console.log(d)</code></pre></div><blockquote><p>最终打包后的结果会变成 <code>console.log(6)</code></p></blockquote><ul><li>代码量明显减少</li><li>减少多个函数后内存占用也将减少</li></ul><h2 id="5-DllPlugin-DllReferencePlugin"><a href="#5-DllPlugin-DllReferencePlugin" class="headerlink" title="5.DllPlugin &amp;&amp; DllReferencePlugin"></a>5.DllPlugin &amp;&amp; DllReferencePlugin</h2><p>每次构建时第三方模块都需要重新构建，这个性能消耗比较大，我们可以先把第三方库打包成动态链接库，以后构建时只需要查找构建好的库就好了，这样可以大大节约构建时间</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptimport React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;ReactDOM.render(&lt;h1&gt;hello&lt;/h1&gt;,document.getElementById(&#39;root&#39;))</code></pre></div><h3 id="5-1-DllPlugin"><a href="#5-1-DllPlugin" class="headerlink" title="5.1 DllPlugin"></a>5.1 DllPlugin</h3><blockquote><p>这里我们可以先将<code>react</code>、<code>react-dom</code>单独进行打包</p></blockquote><p>单独打包创建<code>webpack.dll.js</code></p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptconst path = require(&#39;path&#39;);const DllPlugin = require(&#39;webpack/lib/DllPlugin&#39;);module.exports = &#123;    entry:[&#39;react&#39;,&#39;react-dom&#39;],    mode:&#39;production&#39;,    output:&#123;        filename:&#39;react.dll.js&#39;,        path:path.resolve(__dirname,&#39;dll&#39;),        library:&#39;react&#39;    &#125;,    plugins:[        new DllPlugin(&#123;            name:&#39;react&#39;,            path:path.resolve(__dirname,&#39;dll/manifest.json&#39;)        &#125;)    ]&#125;</code></pre></div><p>执行<code>&quot;webpack --config webpack.dll.js</code>命令，可以看到dll目录下创建了两个文件分别是<code>manifest.json</code>,<code>react.dll.js</code></p><p>关系是这个酱紫的，到时候我们会通过<code>manifest.json</code>找到<code>react.dll.js</code>文件中的模块进行加载</p><h3 id="5-2-DllReferencePlugin"><a href="#5-2-DllReferencePlugin" class="headerlink" title="5.2 DllReferencePlugin"></a>5.2 DllReferencePlugin</h3><p>在我们的项目中可以引用刚才打包好的动态链接库</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptconst DllReferencePlugin = require(&#39;webpack/lib/DllReferencePlugin&#39;);const AddAssetHtmlWebpackPlugin = require(&#39;add-asset-html-webpack-plugin&#39;);// 构建时会引用动态链接库的内容new DllReferencePlugin(&#123;  manifest:path.resolve(__dirname,&#39;dll/manifest.json&#39;)&#125;),// 需要手动引入react.dll.jsnew AddAssetHtmlWebpackPlugin(  &#123; filepath: path.resolve(__dirname,&#39;dll/react.dll.js&#39;) &#125;)</code></pre></div><p>使用DllPlugin可以大幅度提高构建速度</p><h2 id="6-动态加载"><a href="#6-动态加载" class="headerlink" title="6.动态加载"></a>6.动态加载</h2><p>实现点击后动态加载文件</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptlet btn = document.createElement(&#39;button&#39;);btn.innerHTML = &#39;点击加载视频&#39;;btn.addEventListener(&#39;click&#39;,()=&gt;&#123;    import(&#39;./video&#39;).then(res=&gt;&#123;        console.log(res.default);    &#125;);&#125;);document.body.appendChild(btn);</code></pre></div><p>给动态引入的文件增加名字</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptoutput:&#123;  chunkFilename:&#39;[name].min.js&#39;&#125;import(/* webpackChunkName: &quot;video&quot; */ &#39;./video&#39;).then(res=&gt;&#123;    console.log(res.default);&#125;)</code></pre></div><blockquote><p>这样打包后的结果最终的文件就是 <code>video.min.js</code></p></blockquote><h2 id="7-打包文件分析工具"><a href="#7-打包文件分析工具" class="headerlink" title="7.打包文件分析工具"></a>7.打包文件分析工具</h2><p>安装<code>webpack-bundle-analyzer</code>插件</p><div class="hljs code-wrapper"><pre><code class="hljs">npm install --save-dev webpack-bundle-analyzer</code></pre></div><p>使用插件</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptconst &#123;BundleAnalyzerPlugin&#125; = require(&#39;webpack-bundle-analyzer&#39;);mode !== &quot;development&quot; &amp;&amp; new BundleAnalyzerPlugin()</code></pre></div><p>默认就会展现当前应用的分析图表</p><h2 id="8-SplitChunks"><a href="#8-SplitChunks" class="headerlink" title="8.SplitChunks"></a>8.SplitChunks</h2><p>我们在来看下SplitChunks这个配置，他可以在编译时抽离第三方模块、公共模块</p><p>将项目配置成多入口文件</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptentry:&#123;  a:&#39;./src/a.js&#39;,  b:&#39;./src/b.js&#39;&#125;</code></pre></div><p>我们让a,b两个模块同时引用<code>jquery</code>,别忘了去掉之前的<code>externals</code>配置</p><p><img src="http://img.fullstackjavascript.cn/analyze-1.png"></p><p>配置<code>SplitChunks</code>插件</p><p>默认配置在此，我一个个描述下含义</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptsplitChunks: &#123;  chunks: &#39;async&#39;, // 分割异步模块  minSize: 30000, // 分割的文件最小大小  maxSize: 0,   minChunks: 1, // 引用次数  maxAsyncRequests: 5, // 最大异步请求数  maxInitialRequests: 3, // 最大初始化请求数  automaticNameDelimiter: &#39;~&#39;, // 抽离的命名分隔符  automaticNameMaxLength: 30, // 名字最大长度  name: true,  cacheGroups: &#123; // 缓存组    vendors: &#123; // 先抽离第三方      test: /[\\/]node_modules[\\/]/,      priority: -10    &#125;,    default: &#123;       minChunks: 2,      priority: -20, // 优先级      reuseExistingChunk: true    &#125;  &#125;&#125;</code></pre></div><blockquote><p>我们将<code>async</code>改为<code>initial</code></p></blockquote><p><img src="http://img.fullstackjavascript.cn/analyze-2.png"></p><p>我们在为每个文件动态导入<code>lodash</code>库,并且改成<code>async</code></p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptimport(&#39;lodash&#39;)</code></pre></div><p><img src="http://img.fullstackjavascript.cn/analyze-3.png"></p><blockquote><p>为每个入口引入<code>c.js</code>,并且改造配置文件</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptsplitChunks: &#123;  chunks: &#39;all&#39;,  name: true,  cacheGroups: &#123;    vendors: &#123;      test: /[\\/]node_modules[\\/]/,      priority: -10    &#125;,    default: &#123;      minSize:1, // 不是第三方模块，被引入两次也会被抽离      minChunks: 2,      priority: -20,    &#125;  &#125;&#125;</code></pre></div><p><img src="http://img.fullstackjavascript.cn/analyze-4.png"></p><blockquote><p>这样再反过来看<code>chunks</code>的参数是不是就了然于胸啦！</p></blockquote><h2 id="9-热更新"><a href="#9-热更新" class="headerlink" title="9.热更新"></a>9.热更新</h2><p>模块热替换（HMR - Hot Module Replacement）是 webpack 提供的最有用的功能之一。它允许在运行时替换，添加，删除各种模块，而无需进行完全刷新重新加载整个页面</p><ul><li>保留在完全重新加载页面时丢失的应用程序的状态</li><li>只更新改变的内容，以节省开发时间</li><li>调整样式更加快速，几乎等同于就在浏览器调试器中更改样式</li></ul><p>启用热更新，默认样式可以支持热更新，如果不支持热更新则采用强制刷新</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptdevServer:&#123;  hot:true&#125;new webpack.NamedModulesPlugin(),</code></pre></div><p>让<code>js</code>支持热更新</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptimport sum from &#39;./sum&#39;;console.log(sum(1,2));if(module.hot)&#123; // 如果支持热更新    module.hot.accept(); // 当入口文件变化后重新执行当前入口文件&#125;</code></pre></div><h2 id="10-IgnorePlugin"><a href="#10-IgnorePlugin" class="headerlink" title="10.IgnorePlugin"></a>10.IgnorePlugin</h2><p>忽略 <code>import</code>和<code>require</code>语法</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptnew webpack.IgnorePlugin(/^\.\/locale$/, /moment$/)</code></pre></div><h2 id="11-费时分析"><a href="#11-费时分析" class="headerlink" title="11.费时分析"></a>11.费时分析</h2><p>可以计算每一步执行的运行速度</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptconst SpeedMeasureWebpackPlugin = require(&#39;speed-measure-webpack-plugin&#39;);const smw = new SpeedMeasureWebpackPlugin();  module.exports =smw.wrap(&#123;&#125;);</code></pre></div><h2 id="12-noParse"><a href="#12-noParse" class="headerlink" title="12.noParse"></a>12.noParse</h2><p><code>module.noParse</code>，对类似jq这类依赖库，内部不会引用其他库，我们在打包的时候就没有必要去解析，这样能够增加打包速率</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptnoParse:/jquery/</code></pre></div><h2 id="13-resolve"><a href="#13-resolve" class="headerlink" title="13.resolve"></a>13.resolve</h2><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptresolve: &#123;  extensions: [&quot;.js&quot;,&quot;.jsx&quot;,&quot;.json&quot;,&quot;.css&quot;],  alias:&#123;&#125;,  modules:[&#39;node_modules&#39;]&#125;,</code></pre></div><h2 id="14-include-exclude"><a href="#14-include-exclude" class="headerlink" title="14.include&#x2F;exclude"></a>14.include&#x2F;exclude</h2><p>在使用<code>loader</code>时,可以指定哪些文件不通过<code>loader</code>,或者指定哪些文件通过<code>loader</code></p><div class="hljs code-wrapper"><pre><code class="hljs">//javascript&#123;  test: /\.js$/,  use: &quot;babel-loader&quot;,  // include:path.resolve(__dirname,&#39;src&#39;),  exclude:/node_modules/&#125;,</code></pre></div><h2 id="15-happypack"><a href="#15-happypack" class="headerlink" title="15.happypack"></a>15.happypack</h2><p>多线程打包，我们可以将不同的逻辑交给不同的线程来处理</p><div class="hljs code-wrapper"><pre><code class="hljs">//bashnpm install --save-dev happypack</code></pre></div><p>使用插件</p><div class="hljs code-wrapper"><pre><code class="hljs">//javascriptconst HappyPack = require(&#39;happypack&#39;);rules:[  &#123;    test: /\.js$/,    use: &#39;happypack/loader?id=jsx&#39;  &#125;,  &#123;    test: /\.less$/,    use: &#39;happypack/loader?id=styles&#39;  &#125;,]new HappyPack(&#123;  id: &#39;jsx&#39;,  threads: 4,  loaders: [ &#39;babel-loader&#39; ]&#125;),new HappyPack(&#123;  id: &#39;styles&#39;,  threads: 2,  loaders: [ &#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39; ]&#125;)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWA-CacheStorageAPI</title>
    <link href="/2019/11/22/2019-11-22-PWA-CacheStorageAPI/"/>
    <url>/2019/11/22/2019-11-22-PWA-CacheStorageAPI/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/TalAter/gotham_imperial_hotel">《PWA实战》</a>记录。[以]塔勒·埃特尔 著 张俊达 译</p></blockquote><br><h3 id="CacheStorage-API"><a href="#CacheStorage-API" class="headerlink" title="CacheStorage API"></a>CacheStorage API</h3><p>CacheStorage是一种全新的缓存层，你拥有完全的控制权。(遵循<a href="https://baike.baidu.com/item/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5">同源策略</a>)</p><br><h4 id="在CacheStorage中储存请求"><a href="#在CacheStorage中储存请求" class="headerlink" title="在CacheStorage中储存请求"></a>在CacheStorage中储存请求</h4><p>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs">//serviceworker.jsself.addEventListener(&quot;install&quot;,function(event)&#123;       event.waitUntil(        caches.open(&quot;gih-cache&quot;).then(function(cache)&#123;            return cache.add(&#39;/index-offline.html&#39;);        &#125;)       );&#125;);</code></pre></div><p>首先我们来理解一下新的命令<br><code>caches.open()</code> :<br>打开并返回一个现有的缓存，如果没有找到对应名称的缓存，就创建它并返回。(并且它返回的是一个用promise包裹的cache对象。)</p><p><code>cache.add()</code> :<br>这个方法将请求文件并将文件放入缓存中，传入的参数就是对应的键名。<br>在install事件中，通过<code>waitUntil</code>等待缓存完成，确保了在整个链条中如果遇到任何问题，service sorker都不会被安装。</p><br><h4 id="在CacheStorage中取回请求"><a href="#在CacheStorage中取回请求" class="headerlink" title="在CacheStorage中取回请求"></a>在CacheStorage中取回请求</h4><p>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs">//servicesocker.js  self.addEventListener(&quot;fetch&quot;,function(event)&#123;    event.respondWith(        fetch(event.request).catch(function()&#123;            return caches.match(&quot;/indedx-offline.html&quot;);        &#125;)    );&#125;);</code></pre></div><p>新的命令：<br><code>match(request,[options])</code> :<br>第一个参数是需要在缓存中寻找的内容，可以是request对象或者URL。<br>第二个参数是非必传的选项对象。（比如 caches.match(event.request,{<code>ignoreSearch:true</code>} 这样将会匹配到请求的URL，同时忽略查询的参数。 ）<br><code>match</code>返回的是一个pormise，由<code>resolve</code>方法包裹的在缓存中找到的第一个response对象。当找不到任何内容时，它返回<br>undefined。<br>因为在找不到内容时，返回的pormise也不会进入<code>reject</code>,所以应该在返回之前判断是否找到匹配。</p><div class="hljs code-wrapper"><pre><code class="hljs">//就像这样caches.match(&quot;/login.png&quot;).then(function(response)&#123;    if(response)&#123;    return response;    &#125;&#125;);</code></pre></div><br><h4 id="缓存多个请求"><a href="#缓存多个请求" class="headerlink" title="缓存多个请求"></a>缓存多个请求</h4><p>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs">//servicesocker.js  const CACHE_NAME = &quot;gih-cache&quot;;const CACHED_URLS = [    &quot;index-offline.html&quot;,    &quot;https:maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&quot;,    &quot;/css/gih-offline.css&quot;,    &quot;/img/jumbo-background-sm.jpg&quot;,    &quot;/img/logo-header.png&quot;]; self.addEventListener(&quot;install&quot;,function(event)&#123;       event.waitUntil(        caches.open(CACHE_NAME).then(function(cache)&#123;            return cache.addAll(CACHED_URLS);        &#125;)       );&#125;)</code></pre></div><p>新的命令：<br><code>cache.addAll()</code> :<br>与cache,add()类似，但是其接收的是一组URL，并全部储存到缓存，如果任何一个请求失败，将会返回<code>promise.reject</code>。</p><br><h4 id="接收每个请求"><a href="#接收每个请求" class="headerlink" title="接收每个请求"></a>接收每个请求</h4><p>示例：</p><div class="hljs code-wrapper"><pre><code class="hljs">//servicesocker.js  self.addEventListener(&quot;fetch&quot;,function(event)&#123;    event.respondWith(        fetch(event.request).catch(function()&#123;            return caches.match(event.request).then(function(response)&#123;                if(response)&#123;                    return response;                &#125;else if(event.request.header.get(&quot;accept&quot;).includes(&quot;text/html&quot;))&#123;                    return caches.match(&quot;/index-offline.html&quot;);                &#125;            &#125;);        &#125;)    );&#125;);</code></pre></div><p>在这个请求中，新的fetch事件仍然试图向网络发起请求权，但是如果请求失败，则继续处理catch块中的函数。</p><br><h5 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a><code>陷阱</code></h5><p>通过传递request对象（例如：caches.match(event.request)）来查找缓存中的条目有一个潜在的陷阱需要注意。<br>例如：您的网站有一个爆款活动，用户从a页面点击进入活动页面，<br>您缓存的内容长这样（<code>https://waterbang.top/activity.html?source=a</code>）。<br>用户从b页面点击进入，您的内容长这样（<code>https://waterbang.top/activity.html？id=2&amp;source=b</code>）。<br>如果您从a页面使用caches.match(event.request),尝试去寻找(<code>/activity.html?source=a</code>),会找不到任何内容。<br>如果你可以确保查询字符串对于页面内容不会产生影响。可以使用ignoreSearch选项，通知match() 方法忽略字符串查询。</p><div class="hljs code-wrapper"><pre><code class="hljs">caches.match(event.request,&#123;ignoreSearch: true&#125;)</code></pre></div><p>这样会匹配到请求的URL的条目，同时会忽略查询参数。</p><br><h3 id="HTTP缓存和HTTP头"><a href="#HTTP缓存和HTTP头" class="headerlink" title="HTTP缓存和HTTP头"></a>HTTP缓存和HTTP头</h3><p>CacheStorage不能取代过去的HTTP缓存。<br>如果你的服务器提供的文件包含一个HTTP头，说明该文件可以缓存一年（<code>Cache-Control: max-age=31536000</code>）,<br>游览器就会一直使用游览器缓存来提供这个文件。<br>如果你在一周之后更新了main.css并且打算更新service worker，让其重新调用cache.addAll([“.&#x2F;main.css”]),那么该文件会从游览器缓存中返回，而不是网络中返回</p><br><h3 id="缓存管理，清除旧缓存"><a href="#缓存管理，清除旧缓存" class="headerlink" title="缓存管理，清除旧缓存"></a>缓存管理，清除旧缓存</h3><p>我们不仅要创建缓存，还应该负责的处理不再需要的旧资源缓存<br>熟悉新的命令：<br><code>caches.delete(cacheName) </code>:<br>接收一个缓存名字做为参数，并删除对应的缓存。</p><p><code>caches.keys()</code> :<br>该函数能获取所有的缓存名称，返回一个promise，成功的时候会得到一个包含缓存名称的数组。</p><div class="hljs code-wrapper"><pre><code class="hljs">caches.keys().then(function()&#123;    cacheName.forEach(function(cacheName)&#123;        caches.delete(cacheName);    &#125;)&#125;)</code></pre></div> <br> <h5 id="我们如何管理我们的缓存"><a href="#我们如何管理我们的缓存" class="headerlink" title="我们如何管理我们的缓存"></a>我们如何管理我们的缓存</h5><p> 任何时候，我们的应用最多需要两份缓存，一份是当前激活的service worker,<br> 另外一份是正在安装但是未激活的service worker（如果存在的话）。<br> 我们上面的缓存请求的代码已经完成了，接下来我们要实现：当新的service worker激活的时候，<br> 安全清除旧的service worker创建的缓存。<br> 我们可以在serviceworker.js文件底部，添加一个新的监听事件来完成 ——<code>activate</code>事件</p><div class="hljs code-wrapper"><pre><code class="hljs">//servicesocker.js  self.addEventListener(&quot;activate&quot;,function(event) &#123;  event.waitUntil(    caches.keys().then(function(cacheNames)&#123;      return Promise.all(        cacheNames.map(function(cacheName)&#123;          if(CACHE_NAME !== cacheName &amp;&amp; cacheName.startsWith(&quot;git-cache&quot;))&#123;            return caches.delete(cacheName);          &#125;        &#125;)      );    &#125;)  );&#125;);</code></pre></div><p>让我们看看我们的代码<br>首先我们用<code>event.waitUntil</code>,来让service worker 完成激活之前，先等待我们删除旧的缓存。<br>由于caches.keys返回的是一个promise,其成功时会返回一个数组，该数组包含所有缓存的名称。<br>我们需要拿到这个数组，然后创建一个promise，来迭代数组中的每个缓存（_Array.map()_），并且用Promise.all()返回。</p><p>Promise.all() 接收一个promise数组，并且返回一个单独的promise，如果数组中的任何一个promise返回失败（reject）,<br>那么这整个都会创建失败，只有全部完成才会返回完成。</p><br><h4 id="重用已缓存的响应"><a href="#重用已缓存的响应" class="headerlink" title="重用已缓存的响应"></a>重用已缓存的响应</h4><p>当我们每次去安装service worker的时候，都会去创建一份新的缓存。这样是低效的，我们如果可以在创建新缓存的时候，<br>先去遍历一遍不可变文件的列表，然后从现有的缓存中复制到新的缓存。</p><div class="hljs code-wrapper"><pre><code class="hljs">//serviceworker.jsconst immutableRequests = [ //我们的不可变资源  &quot;/fancy_header_background.mp4&quot;,  &quot;vendor/bootstrap/3.3.7/bootstrap.min.css&quot;,  &quot;/css/style-v355.css&quot;];const mutableRequest = [ //每次创建新缓存都要去网络中请求的URL  &quot;app-settings.json&quot;,  &quot;index.html&quot;];self.addEventListener(&quot;install&quot;,function(event)&#123;  event.waitUntil(caches.open(&quot;cache-v2&quot;)).then(function(cache)&#123;    let newImmutableRequests =[];    return Promise.all(      immutableRequests.map(function(url)&#123;        return caches.match(url).then(function(response)&#123;          if(response)&#123;            return response;          &#125;else&#123;            newImmutableRequests.push(url);            return Promise.resolve();          &#125;        &#125;);      &#125;)    ).then(function()&#123;      return cache.addAll(newImmutableRequests.concat(mutableRequest));    &#125;);  &#125;);&#125;);</code></pre></div><p>在大部分的service worker中，上面这种模式是适用的，但是作者给我们提供了一种更加方便的方法。</p><div class="hljs code-wrapper"><pre><code class="hljs">importScript(cache.adderall.js);self.addEventListener(&quot;install&quot;,function(event)&#123;    event.waitUntil(        caches.open(&quot;cache-v2&quot;).then(function(cache)&#123;            return adderall.addAll(cache,IMMUTABLE_URLS&lt;MUTABLE_URLS);        &#125;)    )&#125;)</code></pre></div><p>点击<a href="https://github.com/TalAter/cache.adderall">cache.adderall</a>，进一步了解。</p><h4 id="结束🐟"><a href="#结束🐟" class="headerlink" title="结束🐟"></a>结束🐟</h4><blockquote><p>清晨入古寺，初日照高林。——「题破山寺后禅院」  常建           </p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Progressive Web App</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWA-生命周期</title>
    <link href="/2019/11/21/2019-11-21-PWA-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2019/11/21/2019-11-21-PWA-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/TalAter/gotham_imperial_hotel">《PWA实战》</a>记录。[以]塔勒·埃特尔 著 张俊达 译</p></blockquote><h3 id="理解service-worker作用域"><a href="#理解service-worker作用域" class="headerlink" title="理解service worker作用域"></a>理解service worker作用域</h3><p>我们如果把serviceworker.js文件放置到根目录中，那么其就可以控制来自站点中任何地方的所有请求。<br>如果我们把它放置到js目录中，只有源于该<code>子目录</code>的请求才会通过它。</p><p>你可以在注册的时候传一个service worker的时候传入一个scope选项，用来覆盖service worker默认的作用域。<br>这样可以将它的作用域限制在目录较小的子集。（但是不能扩大作用域）</p><div class="hljs code-wrapper"><pre><code class="hljs">//这两个具有相同的作用域navigator.serviceWorker.register(&quot;/sw.js&quot;);navigator.serviceWorker.register(&quot;/sw.js&quot;,&#123;scope:&quot;/&quot;&#125;);//这两个各自控制了一个不同的目录navigator.serviceWorker.register(&quot;/sw-login.js&quot;,&#123;scope:&quot;/login&quot;&#125;);navigator.serviceWorker.register(&quot;/sw-regist.js&quot;,&#123;scope:&quot;/regist&quot;&#125;);</code></pre></div><br><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol><li><p>解析成功&#x3D;&gt; Parsed : 首次注册Service Worker，一般用来判断游览器是否支持Service Worker。</p></li><li><p>安装&#x3D;&gt; Installing : 这个状态发生在Service Worker注册之后，一般用<code>waitUntil</code>来对一些静态资源进行缓存。<br>该事件有两个回调方法<br> <code>event.waitUntil()</code> :  传入一个Promise参数，该函数会延长事件的存在时间，直到传入的Promise完成。<br> <code>self.skipWaiting()</code> : self 是当前context的global变量，执行该方法表示，强制把当前正处在等待（<code>waiting</code>）状态的Service Worker 进入激活（<code>activate</code>）状态</p><blockquote><p>在install事件中，可以通过waitUntil等待缓存完成，这样确保了在整个链条中如果遇到任何问题，service sorker都不会被安装。</p></blockquote></li><li><p>安装后&#x3D;&gt; Installed&#x2F;waiting : 一旦Service Worker安装成功，就会进入<code>installed</code>状态。<br>除非另一个激活的Service Worker依然在控制应用，在这种情况下会维持<code>waiting</code>的状态，等待其他的Service Worker线程关闭。</p></li><li><p>激活&#x3D;&gt; Activating : 在这个状态下允许 其他 没有被Service Worker控制的客户端，完成worker的安装，并且清除了其他的worker以及关联缓存的旧缓存资源，等待新的Service Worker线程被激活。<br>该事件有两个回调方法<br> <code>event.waitUntil()</code>： 传入一个Promise参数，该函数会延长事件的存在时间，直到传入的Promise完成。<br> <code>self.clients.claim()</code>：在 activate 事件回调中执行该方法表示取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面，之后会被停止。</p></li><li><p>激活后( Activated )：在这个状态会处理 activate 事件回调 (提供了更新缓存策略的机会)。并可以处理功能性的事件 fetch (请求)、sync (后台同步)、push (推送)。</p></li><li><p>废弃状态 ( Redundant )：这个状态表示一个 Service Worker 的生命周期结束。<br>进入redundant状态的原因可能为这几种：<br>a. 安装 (install) 失败<br>b. 激活 (activating) 失败<br>c. 新版本的 Service Worker 替换了它并成为激活状态</p></li></ol><h4 id="结束🐟"><a href="#结束🐟" class="headerlink" title="结束🐟"></a>结束🐟</h4><blockquote><p>无限枝头好颜色，可怜开不为重阳。——「咏菊」丘浚</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Progressive Web App</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack-从零搭建自己的webpack开发环境</title>
    <link href="/2019/11/18/2019-11-18-webpack-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84webpack%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2019/11/18/2019-11-18-webpack-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84webpack%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="从0搭建自己的webpack开发环境"><a href="#从0搭建自己的webpack开发环境" class="headerlink" title="从0搭建自己的webpack开发环境"></a>从0搭建自己的webpack开发环境</h1><p><a href="http://www.zhufengpeixun.cn/">珠峰架构课</a>webpack课程,里面的姜文老师和张老师是大牛！</p><p>这是<a href="http://www.zhufengpeixun.cn/">珠峰架构课</a>课件，不是本人编写。</p><h2 id="1-什么是Webpack？"><a href="#1-什么是Webpack？" class="headerlink" title="1.什么是Webpack？"></a>1.什么是Webpack？</h2><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler),当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle<br><img src="http://img.zhufengpeixun.cn/webpack.jpeg"></p><p>使用Webpack作为前端构建工具：</p><ul><li>代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</li><li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li><li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li><li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li><li>代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li><li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li></ul><p><strong>在<code>webpack</code>应用中有两个核心</strong>:</p><ul><li><ol><li>模块转换器，用于把模块原内容按照需求转换成新内容，可以加载非 JS 模块</li></ol></li><li><ol start="2"><li>扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。</li></ol></li></ul><h2 id="2-初始化项目"><a href="#2-初始化项目" class="headerlink" title="2.初始化项目"></a>2.初始化项目</h2><div class="hljs code-wrapper"><pre><code class="hljs">├── src   # 源码目录│   ├── a-module.js│   └── index.js</code></pre></div><p>编写 <em>a-module.js</em></p><div class="hljs code-wrapper"><pre><code class="hljs">module.exports = &#39;hello&#39;;</code></pre></div><p>编写 <em>index.js</em> </p><div class="hljs code-wrapper"><pre><code class="hljs">let a = require(&#39;./a-module&#39;);console.log(a);</code></pre></div><blockquote><p>这里我们使用<code>CommonJS</code>模块的方式引入，这种方式默认在浏览器上是无法运行的，我们希望通过 <code>webpack</code> 来进行打包！</p></blockquote><h2 id="3-webpack快速上手"><a href="#3-webpack快速上手" class="headerlink" title="3.webpack快速上手"></a>3.webpack快速上手</h2><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><div class="hljs code-wrapper"><pre><code class="hljs">//bashnpm init -ynpm install webpack webpack-cli --save-dev </code></pre></div><p><code>webpack</code>默认支持0配置,配置<code>scripts</code>脚本</p><div class="hljs code-wrapper"><pre><code class="hljs">&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;webpack&quot;&#125;</code></pre></div><p>执行<code>npm run build</code>,默认会调用 <code>node_modules/.bin</code>下的<code>webpack</code>命令，内部会调用<code>webpack-cli</code>解析用户参数进行打包。默认会以 <code>src/index.js</code> 作为入口文件。</p><blockquote><p>这里也可以使用<code>npx webpack</code>,<code>npx</code> 是 5.2版本之后<code>npm</code>提供的命令可以执行<code>.bin</code>下的可执行文件</p></blockquote><p><img src="http://img.fullstackjavascript.cn/webpack1.png"></p><p>我们可以发现已经产生了<code>dist</code>目录，此目录为最终打包出的结果。<code>main.js</code>可以在html中直接引用,这里还提示我们默认<code>mode</code> 为<code>production</code></p><h3 id="3-2-webpack-config-js"><a href="#3-2-webpack-config-js" class="headerlink" title="3.2 webpack.config.js"></a>3.2 webpack.config.js</h3><p>我们打包时一般不会采用0配置，<code>webpack</code>在打包时默认会查找当前目录下的 <code>webpack.config.js or webpackfile.js</code> 文件。</p><p>通过配置文件进行打包</p><div class="hljs code-wrapper"><pre><code class="hljs">const path = require(&#39;path&#39;);module.exports = &#123;    entry:&#39;./src/index.js&#39;,    output:&#123;        filename:&#39;bundle.js&#39;, // 打包出的结果文件        path:path.resolve(__dirname,&#39;dist&#39;) // 打包到dist目录下    &#125;&#125;</code></pre></div><h3 id="3-3-配置打包的mode"><a href="#3-3-配置打包的mode" class="headerlink" title="3.3 配置打包的mode"></a>3.3 配置打包的mode</h3><p>我们需要在打包时提供<code>mode</code>属性来区分是开发环境还是生产环境,来实现配置文件的拆分</p><div class="hljs code-wrapper"><pre><code class="hljs">├── build│   ├── webpack.base.js│   ├── webpack.dev.js│   └── webpack.prod.js</code></pre></div><p><strong>我们可以通过指定不同的文件来进行打包</strong></p><p>配置<code>scripts</code>脚本</p><div class="hljs code-wrapper"><pre><code class="hljs">&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;webpack --config ./build/webpack.prod&quot;,  &quot;dev&quot;: &quot;webpack --config ./build/webpack.dev&quot;&#125;</code></pre></div><p>可以通过 <code>config</code> 参数指定,使用哪个配置文件来进行打包 </p><p><strong>通过env参数区分</strong></p><div class="hljs code-wrapper"><pre><code class="hljs">&quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;webpack --env.production --config ./build/webpack.base&quot;,    &quot;dev&quot;: &quot;webpack --env.development --config ./build/webpack.base&quot;&#125;</code></pre></div><p>改造<code>webpack.base</code>文件默认导出函数，会将环境变量传入到函数的参数中</p><div class="hljs code-wrapper"><pre><code class="hljs">module.exports = (env)=&gt;&#123;    console.log(env); // &#123; development: true &#125;&#125;</code></pre></div><p><strong>合并配置文件</strong></p><p>我们可以判断当前环境是否是开发环境来加载不同的配置,这里我们需要做配置合并<br>安装<code>webpack-merge</code>:</p><div class="hljs code-wrapper"><pre><code class="hljs">npm install webpack-merge --save-dev</code></pre></div><p><code>webpack.dev</code>配置</p><div class="hljs code-wrapper"><pre><code class="hljs">module.exports = &#123;    mode:&#39;development&#39;&#125;</code></pre></div><p><code>webpack.prod</code>配置</p><div class="hljs code-wrapper"><pre><code class="hljs">module.exports = &#123;    mode:&#39;production&#39;&#125;</code></pre></div><p><code>webpack.base</code>配置</p><div class="hljs code-wrapper"><pre><code class="hljs">const path = require(&#39;path&#39;);const merge = require(&#39;webpack-merge&#39;);// 开发环境const dev = require(&#39;./webpack.dev&#39;);// 生产环境const prod = require(&#39;./webpack.prod&#39;);const base = &#123; // 基础配置    entry:&#39;./src/index.js&#39;,    output:&#123;        filename:&#39;bundle.js&#39;,        path:path.resolve(__dirname,&#39;../dist&#39;)    &#125;&#125;module.exports = (env) =&gt;&#123;    if(env.development)&#123;        return merge(base,dev);    &#125;else&#123;        return merge(base,prod)    &#125;&#125;</code></pre></div><p>后续的开发中，我们会将公共的逻辑放到<code>base</code>中,开发和生产对的配置也分别进行存放！</p><h2 id="4-webpack-dev-server"><a href="#4-webpack-dev-server" class="headerlink" title="4.webpack-dev-server"></a>4.webpack-dev-server</h2><p>配置开发服务器，可以在实现在内存中打包,并且自动启动服务</p><div class="hljs code-wrapper"><pre><code class="hljs">npm install webpack-dev-server --save-dev&quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;webpack --env.production --config ./build/webpack.base&quot;,    &quot;dev&quot;: &quot;webpack-dev-server --env.development --config ./build/webpack.base&quot;&#125;</code></pre></div><p>通过执行<code>npm run dev</code>来启启动开发环境</p><p><img src="http://img.fullstackjavascript.cn/webpack2.png"></p><p>默认会在当前根目录下启动服务</p><p><strong>配置开发服务的配置</strong></p><div class="hljs code-wrapper"><pre><code class="hljs">const path = require(&#39;path&#39;)module.exports = &#123;    mode:&#39;development&#39;,    devServer:&#123;        // 更改静态文件目录位置        contentBase:path.resolve(__dirname,&#39;../dist&#39;),        compress:true, // 开启gzip        port:3000, // 更改端口号    &#125;&#125;</code></pre></div><h2 id="5-打包Html插件"><a href="#5-打包Html插件" class="headerlink" title="5.打包Html插件"></a>5.打包Html插件</h2><h3 id="5-1-单入口打包"><a href="#5-1-单入口打包" class="headerlink" title="5.1 单入口打包"></a>5.1 单入口打包</h3><p>自动产生html，并引入打包后的文件</p><p>编辑<code>webpack.base</code>文件</p><div class="hljs code-wrapper"><pre><code class="hljs">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);plugins:[    new HtmlWebpackPlugin(&#123;        filename:&#39;index.html&#39;, // 打包出来的文件名        template:path.resolve(__dirname,&#39;../public/index.html&#39;),        hash:true, // 在引用资源的后面增加hash戳        minify:&#123;            removeAttributeQuotes:true // 删除属性双引号        &#125;    &#125;)]</code></pre></div><h3 id="5-2-多入口打包"><a href="#5-2-多入口打包" class="headerlink" title="5.2 多入口打包"></a>5.2 多入口打包</h3><p>根据不同入口 生成多个js文件，引入到不同html中</p><div class="hljs code-wrapper"><pre><code class="hljs">── src    ├── entry-1.js    └── entry-2.js</code></pre></div><p>多入口需要配置多个entry</p><div class="hljs code-wrapper"><pre><code class="hljs">entry:&#123;    jquery:[&#39;jquery&#39;], // 打包jquery    entry1:path.resolve(__dirname,&#39;../src/entry-1.js&#39;),    entry2:path.resolve(__dirname,&#39;../src/entry-2.js&#39;)&#125;,output:&#123;    filename:&#39;[name].js&#39;,    path:path.resolve(__dirname,&#39;../dist&#39;)&#125;,</code></pre></div><p>产生多个Html文件</p><div class="hljs code-wrapper"><pre><code class="hljs">new HtmlWebpackPlugin(&#123;    filename:&#39;index.html&#39;,     template:path.resolve(__dirname,&#39;../public/template.html&#39;),    hash:true,     minify:&#123;        removeAttributeQuotes:true    &#125;,    chunks:[&#39;jquery&#39;,&#39;entry1&#39;], // 引入的chunk 有jquery,entry&#125;),new HtmlWebpackPlugin(&#123;    filename:&#39;login.html&#39;,    template:path.resolve(__dirname,&#39;../public/template.html&#39;),    hash:true,    minify:&#123;        removeAttributeQuotes:true    &#125;,    inject:false, // inject 为false表示不注入js文件    chunksSortMode:&#39;manual&#39;, // 手动配置代码块顺序    chunks:[&#39;entry2&#39;,&#39;jquery&#39;]&#125;)</code></pre></div><p>以上的方式不是很优雅，每次都需要手动添加<code>HtmlPlugin</code>应该动态产生<code>html</code>文件，像这样:</p><div class="hljs code-wrapper"><pre><code class="hljs">let htmlPlugins = [  &#123;    entry: &quot;entry1&quot;,    html: &quot;index.html&quot;  &#125;,  &#123;    entry: &quot;entry2&quot;,    html: &quot;login.html&quot;  &#125;].map(  item =&gt;    new HtmlWebpackPlugin(&#123;      filename: item.html,      template: path.resolve(__dirname, &quot;../public/template.html&quot;),      hash: true,      minify: &#123;        removeAttributeQuotes: true      &#125;,      chunks: [&quot;jquery&quot;, item.entry]    &#125;));plugins: [...htmlPlugins]</code></pre></div><h2 id="6-清空打包结果"><a href="#6-清空打包结果" class="headerlink" title="6.清空打包结果"></a>6.清空打包结果</h2><p>可以使用<code>clean-webpack-plugin</code>手动清除某个文件夹内容:</p><p><strong>安装</strong></p><div class="hljs code-wrapper"><pre><code class="hljs">npm install --save-dev clean-webpack-pluginconst &#123; CleanWebpackPlugin &#125; = require(&#39;clean-webpack-plugin&#39;);new CleanWebpackPlugin(&#123;    // 清空匹配的路径    cleanOnceBeforeBuildPatterns: [path.resolve(&#39;xxxx/*&#39;),&#39;**/*&#39;],&#125;)</code></pre></div><p>这样就可以清空指定的目录了,我们可以看到<code>webpack</code>插件的基本用法就是 <code>new Plugin</code>并且放到<code>plugins</code>中</p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序-5毛钱信条</title>
    <link href="/2019/11/17/2019-11-17-%E5%B0%8F%E7%A8%8B%E5%BA%8F-5%E6%AF%9B%E9%92%B1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <url>/2019/11/17/2019-11-17-%E5%B0%8F%E7%A8%8B%E5%BA%8F-5%E6%AF%9B%E9%92%B1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="五毛钱信条"><a href="#五毛钱信条" class="headerlink" title="五毛钱信条"></a>五毛钱信条</h3><p>首先用大白话概括一下小程序功能：将你的承诺变成信条，发送给别人，在别人需要的时候来找你兑现。<br>（假如我要请你吃冰淇淋，但是你现在不想吃，我给你发个信条，在你想吃的时候找我兑现🚲）</p><div align=center><img src="./miniProgram.jpg" width="150" height="100"><p >扫描小程序体验</p></div><p>这次写小程序刚好赶上了小程序开放了云开发，真的是个人开发者的福音。<br>但是我觉得云开发还是辅助就好，一个好的小程序必须得后端加云开发，这样会显得更加成熟一点。</p><p><a href="https://github.com/watebang/creed">github地址</a></p><br><h4 id="界面🌈"><a href="#界面🌈" class="headerlink" title="界面🌈"></a>界面🌈</h4><ol><li>页面内容采用了<a href="http://doc.mini.7yue.pro/">Lin-ui</a> 林间有风团队出品👍（七月老师真的大牛，🏃去买课）。</li><li>自定义tarBar采用的是<a href="https://github.com/SuRuiGit/wxapp-customTabbar">wxapp-customTabbar</a> SuRuiGit大佬 出品👍。</li></ol><br><p><img src="./item.png" width="150" height="100"> <img src="./home-1.png" width="150" height="100"></p><br>  <h4 id="遇到的问题🈶"><a href="#遇到的问题🈶" class="headerlink" title="遇到的问题🈶"></a>遇到的问题🈶</h4><ol><li><p>在云开发中<strong>所有</strong>更改别人数据的操作需要通过云函数来完成。（直接贴个码)</p><div class="hljs code-wrapper"><pre><code class="hljs">  // 云函数入口文件    const cloud = require(&#39;wx-server-sdk&#39;)    cloud.init()    const db = cloud.database();    // 云函数入口函数    exports.main = async (event, context) =&gt; &#123;      try &#123;        return db.collection(&#39;item&#39;).doc(event._id)          .update(&#123;            data: &#123;              lover: event.lover,              lock:1            &#125;          &#125;)          .then(res =&gt; &#123;            return res;          &#125;)          .catch(err =&gt; &#123;            return err          &#125;)      &#125; catch (e) &#123;        console.error(e)      &#125;    &#125;</code></pre></div></li></ol><br>      <p>记得每次写完云函数<strong>记得上传</strong>，然后这样使用✅。</p><div class="hljs code-wrapper"><pre><code class="hljs">    /**     * 更改状态     */    upItemState(_id,lock)&#123;      return wx.cloud.callFunction(&#123;        name: &#39;upItemState&#39;,        data: &#123;          _id: _id,          lock: lock,        &#125;      &#125;).then(res =&gt; &#123;        return res;      &#125;).catch(err =&gt; &#123;        return err;      &#125;)    &#125;</code></pre></div><br><h4 id="分享两个使用函数-📊"><a href="#分享两个使用函数-📊" class="headerlink" title="分享两个使用函数 📊"></a>分享两个使用函数 📊</h4><p>我在做home页面的动画时候，如果点击得很快，文字和头像就会跳来跳去，就加了个防抖。<br>但是我偷懒防抖做得很简单，下面的是正规军。（不知道哪里复制粘贴的）<br><br>  </p><div class="hljs code-wrapper"><pre><code class="hljs">/**   * @desc 函数防抖   * @param func 函数   * @param wait 延迟执行毫秒数   * @param immediate true 表立即执行，false 表非立即执行   */  debounce(func, wait, immediate) &#123;    let timeout;    return function() &#123;      let context = this;      let args = arguments;      if (timeout) clearTimeout(timeout);      if (immediate) &#123;        var callNow = !timeout;        timeout = setTimeout(() =&gt; &#123;          timeout = null;        &#125;, wait)        if (callNow) func.apply(context, args)      &#125; else &#123;        timeout = setTimeout(function() &#123;          func.apply(context, args)        &#125;, wait);      &#125;    &#125;  &#125;   /**   * @desc 函数节流   * @param func 函数   * @param wait 延迟执行毫秒数   */   throttle(func, wait) &#123;  let previous = 0;  return function () &#123;    let now = Date.now();    let context = this;    let args = arguments;    if (now - previous &gt; wait) &#123;      func.apply(context, args);      previous = now;    &#125;  &#125;&#125;</code></pre></div> <br><h4 id="学到了什么-🉐"><a href="#学到了什么-🉐" class="headerlink" title="学到了什么 🉐"></a>学到了什么 🉐</h4><ol><li>小程序组件化开发。</li><li>小程序云开发。</li><li>复习了ES6。</li><li>如何实现递归下拉刷新最新数据。</li><li>将学习到的函数式编程运用到小程序。</li><li>如何在小程序使用自定义tarBar</li></ol><h4 id="结束语-🏐"><a href="#结束语-🏐" class="headerlink" title="结束语 🏐"></a>结束语 🏐</h4><blockquote><p>春风未了秋风到，老去万缘轻。——「少年游·枫林红透晚烟青」蒋捷</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP-ThinkPHP5.1实现sign校验API</title>
    <link href="/2019/09/01/2019-9-1-PHP-ThinkPHP5.1%E5%AE%9E%E7%8E%B0sign%E6%A0%A1%E9%AA%8CAPI/"/>
    <url>/2019/09/01/2019-9-1-PHP-ThinkPHP5.1%E5%AE%9E%E7%8E%B0sign%E6%A0%A1%E9%AA%8CAPI/</url>
    
    <content type="html"><![CDATA[<h2 id="ThinkPHP5-1实现sign校验API"><a href="#ThinkPHP5-1实现sign校验API" class="headerlink" title="ThinkPHP5.1实现sign校验API"></a>ThinkPHP5.1实现sign校验API</h2><p>本文适合有ThinkPHP经验的同学。</p><p>但是这个设计是根据用户登录产生的token加静态key作为解密的密钥，token过期时间为7200秒，增加了解密难度。</p><p>我直接写流程，加密是aes，具体往下翻，有错误请联系我😁</p><p>如果您刚从5.0升级到5.1</p><p>官方的文档写得很详细，<a href="https://www.kancloud.cn/manual/thinkphp5_1/354155#5051_218">ThinkPHP.5.1升级指导</a> 。</p><br><h3 id="1-建立sign的配置文件"><a href="#1-建立sign的配置文件" class="headerlink" title="1.建立sign的配置文件"></a>1.建立sign的配置文件</h3><p>进入config目录，创建aes.php,如下。(ps：在5.1版本需要在config目录配置)</p><div class="hljs code-wrapper"><pre><code class="hljs">    return [    &#39;aeskey&#39;=&gt;&#39;这是你的key&#39;,//aes加密的密钥  客户端和服务端一致    &#39;app_sign_time&#39;=&gt;7200,//sign失效时间，微信也是这时间    &#39;app_sign_cache_time&#39;=&gt;20,//sign缓存的有效时间    ];  </code></pre></div><p>当你需要使用的时候这样用</p><div class="hljs code-wrapper"><pre><code class="hljs">    config(&#39;aes.app_sign_cache_time&#39;);    </code></pre></div><br><h3 id="2-建立BaseController-php，这个是所有控制器的父类，继承Controller类"><a href="#2-建立BaseController-php，这个是所有控制器的父类，继承Controller类" class="headerlink" title="2.建立BaseController.php，这个是所有控制器的父类，继承Controller类"></a>2.建立BaseController.php，这个是所有控制器的父类，继承Controller类</h3><br><p>BaseController代码如下</p><div class="hljs code-wrapper"><pre><code class="hljs">      /**         * @var string         */        private $headers = &#39;&#39;;            /**--初始化的方法  其他接口类只需要继承这个BaseController类 不需要再继承Controller         * @throws Exception         */        public function initialize() &#123;              $this-&gt;checkRequest();              /*  &#125; catch (Exception $e) &#123;                return [                    &#39;code&#39;=&gt;1,                    &#39;message&#39;=&gt;$e                ];            &#125;*/            &#125;            /** --验证数据是否合法 检查每次请求         * @throws Exception         */        public  function  checkRequest()&#123;            //首先获取header所有参数            $headers = request()-&gt;header();                //进行参数校验            if(empty($headers[&#39;sign&#39;]))&#123;                throw new Exception(&#39;sign不存在！&#39;,1);            &#125;                //如果sign校验不能通过            if(!IAuth::checkSignPass($headers))&#123;                throw new Exception(&#39;sign校验失败失败！&#39;,1);            &#125;            //sign做唯一性处理  写入Cache缓存            Cache::set($headers[&#39;sign&#39;],1,config(&#39;aes.app_sign_cache_time&#39;));            //赋值给类的属性            $this-&gt;headers = $headers;            &#125;</code></pre></div><br><h3 id="3-创建Aes-php"><a href="#3-创建Aes-php" class="headerlink" title="3.创建Aes.php"></a>3.创建Aes.php</h3><p>在application&#x2F;api&#x2F;common&#x2F;lib&#x2F;Aes.php 创建文件，实际位置看您的情况。</p><p>代码如下</p><div class="hljs code-wrapper"><pre><code class="hljs">    class Aes    &#123;            private $key = null;        private $iv = null;        /**         *         * @param $key --密钥         * @return String         */        public function __construct() &#123;            $this-&gt;key =Cache::get(&#39;token&#39;).config(&#39;aes.aeskey&#39;);两者拼接            $this-&gt;key = hash(&#39;sha256&#39;, $this-&gt;key, true);            $this-&gt;iv = substr($this-&gt;key, 0, 16);        &#125;                public function encrypt($input)        &#123;            $data = openssl_encrypt($input, &#39;AES-256-CBC&#39;, $this-&gt;key, OPENSSL_RAW_DATA, $this-&gt;iv);            $data = base64_encode($data);            return $data;        &#125;            public function decrypt($input)        &#123;            $decrypted = openssl_decrypt(base64_decode($input), &#39;AES-256-CBC&#39;, $this-&gt;key, OPENSSL_RAW_DATA, $this-&gt;iv);            return $decrypted;        &#125;            //增加当前时间        private function dataFiller($input)&#123;            return $input.&#39;&amp;time=&#39;.time();        &#125;        &#125;            </code></pre></div><br><h3 id="4-创建验证授权验证规则方法"><a href="#4-创建验证授权验证规则方法" class="headerlink" title="4.创建验证授权验证规则方法"></a>4.创建验证授权验证规则方法</h3><p>我是创建在application&#x2F;api&#x2F;common&#x2F;lib&#x2F;IAuth.php。<br>您可以创建在应用公共文件common下比较方便。</p><p>代码如下</p><div class="hljs code-wrapper"><pre><code class="hljs">    /**         * @param array --检验sign是否能通过，具体规则可以自己与前端商量         * @return boolean         */        public static  function  checkSignPass($data)&#123;            //解密            $str = (new Aes())-&gt;decrypt($data[&#39;sign&#39;]);            //如果解密之后为空            if(empty($str))&#123;                return false;            &#125;            //将$str解析成多个变量            parse_str($str,$arr);                //判断是否在有效时间内            if(time()-ceil($arr[&#39;time&#39;] ) &gt; config(&#39;aes.app_sign_time&#39;))&#123;                return false;            &#125;            //唯一性判定 如果存在 返回false            $echo = Cache::get($data[&#39;sign&#39;]);            if($echo)&#123;                return false;            &#125;            return true;        &#125;        </code></pre></div><p>这样就欧啦！<br>前端可以在拦截器里写加密参数的方法，所有发送的参数加上时间搓，加密后再发送。<br>记得前后端的密钥是一样的哦。<br>经过api的参数都会和时间一起被校验。</p><br><h3 id="自我测试"><a href="#自我测试" class="headerlink" title="自我测试"></a>自我测试</h3><br><h4 id="1-BaseController的以下代码注释掉，因为我们要自我加密"><a href="#1-BaseController的以下代码注释掉，因为我们要自我加密" class="headerlink" title="1. BaseController的以下代码注释掉，因为我们要自我加密"></a>1. BaseController的以下代码注释掉，因为我们要自我加密</h4><div class="hljs code-wrapper"><pre><code class="hljs">     $this-&gt;checkRequest();</code></pre></div><br><h4 id="2-先登录一下让服务端记录token"><a href="#2-先登录一下让服务端记录token" class="headerlink" title="2. 先登录一下让服务端记录token"></a>2. 先登录一下让服务端记录token</h4><img src="./login.png" width="700" height="300"><br><h4 id="3-这是测试控制器里的方法，模拟前端加密"><a href="#3-这是测试控制器里的方法，模拟前端加密" class="headerlink" title="3. 这是测试控制器里的方法，模拟前端加密"></a>3. 这是测试控制器里的方法，模拟前端加密</h4><div class="hljs code-wrapper"><pre><code class="hljs">    public function test($data,$time)&#123;            return (new Aes())-&gt;encrypt(&#39;data=&#39;.$data.&#39;&amp;time=&#39;.$time);        &#125;</code></pre></div><br><h5 id="进行加密"><a href="#进行加密" class="headerlink" title="进行加密"></a>进行加密</h5><img src="./jiami.png" width="700" height="300"><br><h4 id="4-将加密获得的sign拿到header中"><a href="#4-将加密获得的sign拿到header中" class="headerlink" title="4. 将加密获得的sign拿到header中"></a>4. 将加密获得的sign拿到header中</h4><img src="./headers.png" width="700" height="300"><br><h4 id="5-放开BaseController注释的代码"><a href="#5-放开BaseController注释的代码" class="headerlink" title="5.放开BaseController注释的代码"></a>5.放开BaseController注释的代码</h4><p>这样就能测试sign的有效性，和唯一性，api只能请求一次，第二次会抛出错误。</p><br><h3 id="结束🐟"><a href="#结束🐟" class="headerlink" title="结束🐟"></a>结束🐟</h3><blockquote><p>江南柳，叶小未成阴。 ——「望江南·江南柳」欧阳修</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>ThinkPHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello</title>
    <link href="/2019/07/05/Hello/"/>
    <url>/2019/07/05/Hello/</url>
    
    <content type="html"><![CDATA[<h4 id="你好这个博客还在建设当中，博主正在努力学习，发原创高质量贴。🐸"><a href="#你好这个博客还在建设当中，博主正在努力学习，发原创高质量贴。🐸" class="headerlink" title="你好这个博客还在建设当中，博主正在努力学习，发原创高质量贴。🐸"></a>你好这个博客还在建设当中，博主正在努力学习，发原创高质量贴。🐸</h4><p>好好学习，天天向上</p>]]></content>
    
    
    
    <tags>
      
      <tag>巨型玉米饼</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
