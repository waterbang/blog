

<!DOCTYPE html>
<html lang="ch_CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="waterbang">
  <meta name="keywords" content="waterbang">
  
    <meta name="description" content="前言由于个人学习的知识学一门忘一门，因此在这里总结一些比较容易忘记的细节内容，以备复习。  参考 ：杨旭&lt;&lt;Rust 编程语言中级教程&gt;&gt; ,《Rust for Rustaceans》  引用rust 提供的引用是指针的一种高级抽象。引用就是指针。  引用始终引用的是有效数据 引用与 usize 的倍数对齐 引用可以动态大小的类型提供上述保障  引用会保证在内存中对齐，没有">
<meta property="og:type" content="article">
<meta property="og:title" content="rust的特性备忘">
<meta property="og:url" content="https://www.waterbang.top/2024/05/16/rust%E7%9A%84%E7%89%B9%E6%80%A7%E5%A4%87%E5%BF%98/index.html">
<meta property="og:site_name" content="waterbang">
<meta property="og:description" content="前言由于个人学习的知识学一门忘一门，因此在这里总结一些比较容易忘记的细节内容，以备复习。  参考 ：杨旭&lt;&lt;Rust 编程语言中级教程&gt;&gt; ,《Rust for Rustaceans》  引用rust 提供的引用是指针的一种高级抽象。引用就是指针。  引用始终引用的是有效数据 引用与 usize 的倍数对齐 引用可以动态大小的类型提供上述保障  引用会保证在内存中对齐，没有">
<meta property="og:locale" content="ch_CN">
<meta property="og:image" content="https://www.waterbang.top/2024/05/16/rust%E7%9A%84%E7%89%B9%E6%80%A7%E5%A4%87%E5%BF%98/title.jpeg">
<meta property="article:published_time" content="2024-05-16T13:54:54.000Z">
<meta property="article:modified_time" content="2024-12-21T11:43:23.249Z">
<meta property="article:author" content="waterbang">
<meta property="article:tag" content="rust">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://www.waterbang.top/2024/05/16/rust%E7%9A%84%E7%89%B9%E6%80%A7%E5%A4%87%E5%BF%98/title.jpeg">
  
  
  <title>rust的特性备忘 🏮 waterbang</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.waterbang.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"🍦"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"58e161bf4b884b2aa577f323f137ac0f","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>waterbang</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Startseite
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archiv
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Etiketten
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                Über mich
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Weblinks
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post-banner.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="rust的特性备忘">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      waterbang
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2024-05-16 21:54" pubdate>
        May 16, 2024 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      108 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">rust的特性备忘</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：5 hours ago
                
              </p>
            
            <div class="markdown-body">
              <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于个人学习的知识学一门忘一门，因此在这里总结一些比较容易忘记的细节内容，以备复习。</p>
<blockquote>
<p>参考 ：杨旭&lt;&lt;Rust 编程语言中级教程&gt;&gt; ,《Rust for Rustaceans》</p>
</blockquote>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>rust 提供的引用是指针的一种高级抽象。引用就是指针。</p>
<ul>
<li>引用始终引用的是有效数据</li>
<li>引用与 usize 的倍数对齐</li>
<li>引用可以动态大小的类型提供上述保障</li>
</ul>
<p>引用会保证在内存中对齐，没有对齐的部分会填充字节，从而不会影响代码的运行速度。</p>
<p>例如：i32 类型在内存中占用的空间为 4 字节。</p>
<blockquote>
<p>rust 会把不没有固定长度的类型存储在内部指针的附近,这样可以让程序永远不会超出程序在内存中运行的空间，产生溢出漏洞，</p>
</blockquote>
<h2 id="Raw-Pointers（原始指针）"><a href="#Raw-Pointers（原始指针）" class="headerlink" title="Raw Pointers（原始指针）"></a>Raw Pointers（原始指针）</h2><p>原始指针是没有 Rust 标准保障的内存地址，即本质上都是需要 unsafe 块包裹的。<br>它的速度极快，但是不安全。</p>
<ul>
<li>不可变 Raw Pointer： <code>*const T</code></li>
<li>可变的 Raw Pointer：<code>*mutT</code></li>
</ul>
<blockquote>
<p>注意： <code>*constT</code>，这三个标记放在一起表示的是一个类型</p>
<p>例子： <code>*const String</code></p>
</blockquote>
<p><code>*const T</code> 和 <code>*mutT</code> 之间差异很小，可以互相转换。</p>
<p>Rust 的引用（&amp;mutT 和 &amp;T ）会编译为原始指针。这意味着无需冒险进入 unsafe 块，就可以获得原始指针的性能。</p>
<h3 id="例子：把引用转为原始指针"><a href="#例子：把引用转为原始指针" class="headerlink" title="例子：把引用转为原始指针"></a>例子：把引用转为原始指针</h3><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>:<span class="hljs-type">i64</span> = <span class="hljs-number">42</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">a_ptr</span>: *<span class="hljs-keyword">const</span> <span class="hljs-type">i64</span> = &amp;a <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i64</span>;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a: &#123;&#125; (&#123;:p&#125;)&quot;</span>,a,a_ptr);<br>&#125;<br><span class="hljs-comment">// ouput=&gt; a: 42 (0x7ff7bd530670)</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>{:p} 可以打印指针地址</p>
</blockquote>
<p>解引用 （dereference）：通过指针从 RAM 内存提取数据的过程 叫做对指针进行解引用</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: <span class="hljs-type">i64</span> = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a_ptr</span>: *<span class="hljs-keyword">const</span> <span class="hljs-type">i64</span> = &amp;a <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i64</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a_addr</span>: <span class="hljs-type">usize</span> = <span class="hljs-keyword">unsafe</span> &#123; std::mem::<span class="hljs-title function_ invoke__">transmute</span>(a_ptr) &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a: &#123;&#125; (&#123;:p&#125;... 0x&#123;:x&#125;)&quot;</span>, a, a_ptr, a_addr + <span class="hljs-number">7</span>);<br>&#125;<br><span class="hljs-comment">// output=&gt; a: 42 (0x7ff7bacca370... 0x7ff7bacca377)</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>std::mem::transmute :将一种类型的值的位重新解释为另一种类型。两种类型必须具有相同的大小。如果不能保证这一点，编译将失败。</p>
</blockquote>
<h3 id="重要的提示-🔥"><a href="#重要的提示-🔥" class="headerlink" title="重要的提示 🔥"></a>重要的提示 🔥</h3><ul>
<li>在底层，引用（&amp;T 和 &amp;mutT）被实现为原始指针。但引用带有额外的保障，应该始终作为首选使用</li>
<li>访问 原始指针 的值总是 unsafe 的</li>
<li>原始指针 不拥有值的所有权</li>
<li>在访问时编译器不会检查数据的合法性</li>
<li>允许多个 原始指针 指向同一数据</li>
<li>Rust 无法保证共享数据的合法性</li>
</ul>
<h4 id="什么时候可以使用原始指针"><a href="#什么时候可以使用原始指针" class="headerlink" title="什么时候可以使用原始指针"></a>什么时候可以使用原始指针</h4><ul>
<li>某些 OS 或第三方库需要使用，例如与 C 交互。</li>
<li>共享对某些内容的访问至关重要，运行时性能要求高。</li>
</ul>
<h2 id="Smart-Pointer（智能指针）"><a href="#Smart-Pointer（智能指针）" class="headerlink" title="Smart Pointer（智能指针）"></a>Smart Pointer（智能指针）</h2><p>智能指针倾向于包装原始指针，附加更多的能力，不仅仅是对内存地址解引用。</p>
<h3 id="Box"><a href="#Box" class="headerlink" title="Box&lt;T&gt;"></a><code>Box&lt;T&gt;</code></h3><p>可以把任何东西都放在 Box 里。可接受几乎任何类型的长期存储。新的安全编程时代的主力军。</p>
<ul>
<li>优点：将值集中存储在 Heap。</li>
<li>缺点：大小增加。</li>
</ul>
<h3 id="Rc"><a href="#Rc" class="headerlink" title="Rc&lt;T&gt;"></a><code>Rc&lt;T&gt;</code></h3><p><code>Rc&lt;T&gt;</code>是 Rust 的能干而吝啬的簿记员。它知道谁借了什么，何时借了什么。</p>
<ul>
<li>优点：对值的共享访问。</li>
<li>缺点：大小增加。运行时成本增加，线程不安全。</li>
</ul>
<h3 id="Arc"><a href="#Arc" class="headerlink" title="Arc&lt;T&gt;"></a><code>Arc&lt;T&gt;</code></h3><p><code>Arc&lt;T&gt;</code>是 Rust 的大使。它可以跨线程共享值，保证这些值不会相互干扰。</p>
<ul>
<li>优点：对值的共享访问，线程安全。</li>
<li>缺点：大小增加,运行时成本增加。</li>
</ul>
<h3 id="Cell"><a href="#Cell" class="headerlink" title="Cell&lt;T&gt;"></a><code>Cell&lt;T&gt;</code></h3><p>变态专家，具有改变不可变值的能力。</p>
<ul>
<li>优点：内部可变性。</li>
<li>缺点：大小增加,性能降低。</li>
</ul>
<h3 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell&lt;T&gt;"></a><code>RefCell&lt;T&gt;</code></h3><p>对不可变引用执行改变的能力，但有代价。</p>
<ul>
<li>优点：内部可变性，可与仅接受不可变引用的 <code>Rc</code>、<code>Arc</code> 嵌套使用。</li>
<li>缺点：大小增加，运行时成本增加，缺乏编译时保障。</li>
</ul>
<h3 id="Cow"><a href="#Cow" class="headerlink" title="Cow&lt;T&gt;"></a><code>Cow&lt;T&gt;</code></h3><p>封闭并提供对借用数据的不可变访问，并在需要修改所有权时延迟克隆数据。</p>
<ul>
<li>优点：当只是只读访问时可以避免写入。</li>
<li>缺点：大小可能会增加.</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a><code>String</code></h3><p>可处理可变长度的文本，展示了如何构建安全的抽象。</p>
<ul>
<li>优点：动态按需增长，在运行时保证正确编码。</li>
<li>缺点：过度分配内存大小。</li>
</ul>
<h3 id="Vec"><a href="#Vec" class="headerlink" title="Vec&lt;T&gt;"></a><code>Vec&lt;T&gt;</code></h3><p>程序最常用的存储系统；它在创建和销毁值时保持数据有序。</p>
<ul>
<li>优点：动态按需增长。</li>
<li>缺点：过度分配内存大小。</li>
</ul>
<h3 id="RawVec"><a href="#RawVec" class="headerlink" title="RawVec&lt;T&gt;"></a><code>RawVec&lt;T&gt;</code></h3><p>是<code>Vec&lt;T&gt;</code>和其它动态大小类型的基石，知道如何按需给你的数据提供一个家。</p>
<ul>
<li>优点：动态按需增长。与内存分配器一起配合寻找空间。</li>
<li>缺点：代码上一般用不到。</li>
</ul>
<h3 id="Unique"><a href="#Unique" class="headerlink" title="Unique&lt;T&gt;"></a><code>Unique&lt;T&gt;</code></h3><p>作为值的唯一所有者，可保证拥有完全控制权。</p>
<ul>
<li>优点：需要独占值的类型（如 String）的基础.</li>
<li>缺点：代码上一般用不到。</li>
</ul>
<h3 id="Shared"><a href="#Shared" class="headerlink" title="Shared&lt;T&gt;"></a><code>Shared&lt;T&gt;</code></h3><p>分享所有权。</p>
<ul>
<li>优点：共享所有权,可以将内存与 T 的宽度对齐，即使是空的时候。</li>
<li>缺点：代码上一般用不到。</li>
</ul>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>有 3 个比较重要的内存区域<code>stack</code>,<code>heap</code>,<code>static</code>。</p>
<ul>
<li>stack 比较快，在内存中比较整齐。</li>
<li>heap 比较慢，在内存中比较混乱。</li>
</ul>
<h2 id="stack-栈内存"><a href="#stack-栈内存" class="headerlink" title="stack 栈内存"></a>stack 栈内存</h2><p>Stack 是一段内存. 其调用顺序是 LIFO（后进先出）的。<br>程序把它作为一个暂存空间，用于函数调用,main 函数就接近 Stack 底部。</p>
<p>想把数据放在 Stack，编译器必须知道类型的大小。</p>
<blockquote>
<p>首选使用 Stack,也就是实现了 Sized 的类型。</p>
</blockquote>
<h3 id="Stack-Frame"><a href="#Stack-Frame" class="headerlink" title="Stack Frame"></a>Stack Frame</h3><p>Stack Frame 与 rust 的声明周期相关。</p>
<p>每个函数都拥有自己的 Frame 当函数返回时，它的 Frame 就被回收了,构成函数本地变量值的那些字节不会立即擦除， 但访问它们也是不安全的。</p>
<p>因为它们可能被后续的函数调用所重写（如果后续函数调用的 Frame 与回收的这个有重合的话）。</p>
<p>但即使没有被重写，它们也可能包含无法合法使用的值。例如函数返回后被移动的值。</p>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>当一个函数即需要兼容 <code>&amp;str</code>和 <code>String</code>的参数。</p>
<blockquote>
<p>$str 存在 Stack 上，String 存储在 Heap 上。</p>
</blockquote>
<p><code>AsRef&lt;T&gt;</code> 要求参数实现到 T 这个类型的引用，即使参数不是这样的类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_strong</span>&lt;T: <span class="hljs-built_in">AsRef</span>&lt;<span class="hljs-type">str</span>&gt;&gt;(password:T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>  password.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">len</span>() &gt; <span class="hljs-number">6</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>Into&lt;String&gt;</code> 要求参数转化为 String 这个类型。但是会涉及比较多的步骤。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_strong</span>&lt;T: <span class="hljs-built_in">Into</span>&lt;<span class="hljs-type">String</span>&gt;&gt;(password:T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>  password.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">len</span>() &gt; <span class="hljs-number">6</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="Heap-堆内存"><a href="#Heap-堆内存" class="headerlink" title="Heap 堆内存"></a>Heap 堆内存</h2><p>Heap 在内存中是混乱的，它是一个内存池，并没有绑定到当前程序的调用栈，是为在编译时没有已知大小的类型准备的。</p>
<p>例如：</p>
<ul>
<li>切片类型 [T]</li>
<li>随着程序运行动态改变的 String,Vec<T></li>
<li>trait 对象，它允许程序员来模拟一些动态语言的特性：通过允许将多个类型放进一个容器</li>
<li>一些类型的大小不会改变，但是无法告诉编译器需要分配多少内存</li>
</ul>
<p>Heap 允许你显式的分配连续的内存块。当这么做时，你会得到一个指针，它指向内存块开始的地方。</p>
<p>Heap 内存中的值会一直有效，直到你对它显式的释放。如果你想让值活得比当前函数 frame 的生命周期还长，就很有用。</p>
<h3 id="Heap-线程安全"><a href="#Heap-线程安全" class="headerlink" title="Heap 线程安全"></a>Heap 线程安全</h3><p>如果想把值送到另一个线程，当前线程可能根本无法与那个线程共享 stack frames，你就可以把它存放在 heap 上。</p>
<p>因为函数返回时 heap 上的分配并不会消失，所以你在一个地方为值分配内存，把指向它的指针传给另一个线程，就可以让那个线程继续安全的操作于这个值。</p>
<p>换一种说法：当你分配 heap 内存时，结果指针会有一个无约束的生命周期，你的程序让它活多久都行。</p>
<h3 id="Heap-机制"><a href="#Heap-机制" class="headerlink" title="Heap 机制"></a>Heap 机制</h3><p>Heap 上面的变量必须通过指针访问。Rust 里与 Heap 交互的首要机制就是 Box 类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>:<span class="hljs-type">i32</span> = <span class="hljs-number">40</span>; <span class="hljs-comment">// Stack</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>:<span class="hljs-type">Box</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">60</span>); <span class="hljs-comment">// Heap</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span>:<span class="hljs-type">i32</span> = a + *b; <span class="hljs-comment">// 用指针访问。</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>当<code>Box:new（value）</code>时，值就会放在 heap 上，返回的<code>Box&lt;T&gt;</code>就是指向 heap 上该值的指针。当 box 被丢弃时，内存就被释放。</p>
<p>如果忘记释放 heap 内存，就会导致内存泄漏<br>有时你就想让内存泄露。</p>
<p>例子：在生命周期没有结束的时候手动释放。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = *a + *b;<br>    <span class="hljs-title function_ invoke__">drop</span>(a);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="如何让内存泄露-🔥"><a href="#如何让内存泄露-🔥" class="headerlink" title="如何让内存泄露 🔥"></a>如何让内存泄露 🔥</h4><p>例如有一个只读的配置，整个程序都需要访间它。就可以把它分配在 heap 上。</p>
<p>通过 Box:leak 得到一个’static 引用，从而显式的让其进行泄露。</p>
<h2 id="Static-静态内存"><a href="#Static-静态内存" class="headerlink" title="Static 静态内存"></a>Static 静态内存</h2><ul>
<li>static 内存实际是一个统称，它指的是程序编译后的文件中几个密切相关的区域。<ul>
<li>当程序执行时，这些区域会自动加载到你程序的内存里。</li>
</ul>
</li>
<li>static 内存里的值在你的程序的整个执行期间会一直存活。</li>
<li>程序的 static 内存是包含程序二进制代码的（通常映射为只读的）。<ul>
<li>随着程序的执行，它会在本文段的二进制代码中挨个指令进行遍历，而当函数被调用时就进行跳跃。</li>
</ul>
</li>
<li>static 内存会持有使用 static 声明的变量的内存，也包括某些常量值， 例如字符串。</li>
</ul>
<h3 id="‘static"><a href="#‘static" class="headerlink" title="‘static"></a>‘static</h3><p>‘static 是特殊的生命周期,它的名字就是来自于 static 内存区，它将引用标记为只要 static 内存还存在（程序关闭前），那么引用就合法。</p>
<p>static 变量的内存在程序开始运行时就分配了，到 static 内存中变量的引用，按定义来说，就是’static 的，因为在程序关闭前它不会被释放。</p>
<p>一旦你创建了一个’static 生命周期的引用，就程序的其余部分而言，它所指向的内容都可能在 static 内存中，因为程序想要使用它多久就可以使用多久。</p>
<h4 id="T-static"><a href="#T-static" class="headerlink" title="T:&#39;static"></a><code>T:&#39;static</code></h4><p>其表示类型 T 可以存活我们想要的任何时长（直到程序关闭），同时这也要求 T 是拥有所有权的和自给自足的。</p>
<p>要求这个类型不借用其他的值，要么借用的值也都是<code>‘static</code>的。</p>
<h3 id="const-与-static-的区别"><a href="#const-与-static-的区别" class="headerlink" title="const 与 static 的区别"></a>const 与 static 的区别</h3><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> x:<span class="hljs-type">i32</span> = <span class="hljs-number">123</span>;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>const 关键字会把紧随它的东西声明为常量</li>
<li>常量可在编译时完全计算出来。</li>
<li>在编译期间，任何引用常量的代码会被替换为常量的计算结果值</li>
<li>常量没有内存或关联其它存储（因为它不是一个地方）</li>
<li>可以把常量理解为某个特殊值的方便的名称</li>
</ul>
<h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><p>Rust 内存模型的核心思想：所有的值都只有一个所有者。</p>
<p>只有一个位置（通常是作用域）来负责释放每个值。</p>
<ul>
<li>这是通过借用检查器来实现的。</li>
<li>如果值移动了（赋值新变量、推到 Vec、置于 Heap），其所有者也变成新的位置了。</li>
</ul>
<p>有些类型不遵守这个规则。</p>
<ul>
<li>如果值的类型实现了 Copy trait，重新赋值时到新内存地址时发生的是复制，而不是移动。</li>
<li>大多数原始类型，例如整数、浮点类型等，都实现了 Copy。</li>
</ul>
<h3 id="如何实现-Copy"><a href="#如何实现-Copy" class="headerlink" title="如何实现 Copy"></a>如何实现 Copy</h3><p>实现 Copy trait 必须可以按位（bit）来复制值,不包括以下类型。</p>
<ol>
<li>含有 non-Copy 类型的类型</li>
<li>拥有这类资源的类型：当类型的值被丢弃时，必须被释放该资源。</li>
</ol>
<p>假设 Box 是 Copy 的，并且进行赋值 <code>box1 = box2</code><br>那么它们在走出内存的时候，都会认为在 Heap 上，有一段内存是属于自己的。<br>都会去释放这个内存，这样就会产生问题。</p>
<h2 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h2><h3 id="T-共享引用（不可变的引用）"><a href="#T-共享引用（不可变的引用）" class="headerlink" title="&amp;T 共享引用（不可变的引用）"></a>&amp;T 共享引用（不可变的引用）</h3><p>共享引用背后的值不可变，因此又叫不可变引用。</p>
<p><code>&amp;T</code>就是可以共享的指针，可以同时存在任意数量的引用的引用指向同一个值，每个共享的引用都实现了 Copy.</p>
<h3 id="mut-T-可变引用"><a href="#mut-T-可变引用" class="headerlink" title="&amp;mut T 可变引用"></a>&amp;mut T 可变引用</h3><p>可变引用都是单一线程独占的,可变引用只允许你修改引用所指向的内存地址。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>:<span class="hljs-type">i32</span> = <span class="hljs-number">42</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">y</span>: &amp;<span class="hljs-type">i32</span> = &amp;x;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">z</span>:&amp;<span class="hljs-keyword">mut</span> &amp;<span class="hljs-type">i32</span> = &amp;<span class="hljs-keyword">mut</span> y; <span class="hljs-comment">//  可以通过z来修改y的值</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>y 前面有 mut 关键字，因此也可以修改成其他值的引用，简单来说就是 y 可以修改成其他值，但是不可以通过 y 来修改 x 的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">y</span>: &amp;<span class="hljs-type">i32</span> = &amp;x;<br></code></pre></div></td></tr></table></figure>

<p>z 前面没有 mut 关键字，因此 z 不能持有其它的引用，只能持有 y 的引用。<br>但是可以通过 z 来修改 y 的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">z</span>:&amp;<span class="hljs-keyword">mut</span> &amp;<span class="hljs-type">i32</span> = &amp;<span class="hljs-keyword">mut</span> y;<br></code></pre></div></td></tr></table></figure>

<h3 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h3><p>类型可以通过共享引用来修改值。主要分为两种。</p>
<h4 id="通过共享引用获得可变引用"><a href="#通过共享引用获得可变引用" class="headerlink" title="通过共享引用获得可变引用"></a>通过共享引用获得可变引用</h4><p>有<code>Mutex</code>,<code>RefCell</code> ，它们如果对某个值提供了可变引用，那么同时只会存在一个可变引用。</p>
<p>依赖 <code>UnsafeCell</code>类型，这是通过共享引用修改值的唯一方式。</p>
<h4 id="通过共享引用可以替换值"><a href="#通过共享引用可以替换值" class="headerlink" title="通过共享引用可以替换值"></a>通过共享引用可以替换值</h4><p><code>std:syn:atomic</code>,<code>srd::cell::Cell</code>,它们没有提供可变引用到内部值，提供的是就地操作值的方法。</p>
<blockquote>
<p>例：无法获得到 usize 或 i32 的直接引用，但是可以读取和替换值</p>
</blockquote>
<h3 id="Cell-类型"><a href="#Cell-类型" class="headerlink" title="Cell 类型"></a>Cell 类型</h3><p>Cell 提供对值的整体替换，返回值的副本，其无法跨线程共享，内部值不会发生并发修改，即便是通过共享引用发生的修改。</p>
<p>不会提供到 Cell 内部的值的引用，因此可以一直移动它。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Rust 里每个引用都有生命周期，它就是引用保持合法的作用域， 大多数时候是隐式和推断出来的。<br>对某个变量取得引用时生命周期开始，当变量移动或离开作用域时生命周期结束。</p>
<h3 id="借用检查器-（Borrow-Checker）"><a href="#借用检查器-（Borrow-Checker）" class="headerlink" title="借用检查器 （Borrow Checker）"></a>借用检查器 （Borrow Checker）</h3><p>每当具有某个生命周期 a 的引用被使用，借用检查器都会检查‘a<br>是否还存活,流程如下：</p>
<ol>
<li>追踪路径直到‘a 开始（获得引用）的地方</li>
<li>从这开始，检查沿着路径是否存在冲突</li>
<li>保证引用指向一个可安全访问的值</li>
</ol>
<h4 id="生命周期重启-（生命周期更新）"><a href="#生命周期重启-（生命周期更新）" class="headerlink" title="生命周期重启 （生命周期更新）"></a>生命周期重启 （生命周期更新）</h4><figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span>:<span class="hljs-type">Box</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">z</span> =  &amp;x; <span class="hljs-comment">// z的生命周期开始了</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span> &#123;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,z);<br>  x = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(i); <span class="hljs-comment">// x的生命周期在这里被更新了</span><br>  z = &amp;x; <span class="hljs-comment">// 这里必须更新z的生命周期，也就是更新了x的引用,不更新引用将会报错，因为x一直处于被z借用的状态，无法被重新赋值。</span><br>&#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,z);<br></code></pre></div></td></tr></table></figure>

<p>借用检测器是保守的，如果不确定某个借用是否合法，借用检查器就会拒绝该借用。</p>
<p>借用检查器有时需要帮助来理解某个借用为什么是合法的，这也是 Unsafe Rust 存在的部分原因。</p>
<h2 id="泛型生命周期"><a href="#泛型生命周期" class="headerlink" title="泛型生命周期"></a>泛型生命周期</h2><p>主要是为了借用检查器能检查一些在类型中存储引用的生命周期。<br>例如：在该类型方法中返回引用，且存活比 self 的长。</p>
<p>rust 允许你基于一个或多个生命周期将类型的定义泛型化。但是这会让类型签名更加的复杂，因此需要遵循以下两点：</p>
<ul>
<li>只有类型包含多个引用时，你才应该使用多个生命周期参数</li>
<li>它方法返回的引用只应绑定到其中一个引用的生命周期</li>
</ul>
<p>多个类型引用示例</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StrSplit</span>&lt;<span class="hljs-symbol">&#x27;s</span>, <span class="hljs-symbol">&#x27;p</span>&gt; &#123;<br>    delimiter: &amp;<span class="hljs-symbol">&#x27;p</span> <span class="hljs-type">str</span>, <span class="hljs-comment">// 第二个泛型生命周期</span><br>    document: &amp;<span class="hljs-symbol">&#x27;s</span> <span class="hljs-type">str</span>,  <span class="hljs-comment">// 第一个泛型生命周期</span><br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;s</span>, <span class="hljs-symbol">&#x27;p</span>&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">StrSplit</span>&lt;<span class="hljs-symbol">&#x27;s</span>, <span class="hljs-symbol">&#x27;p</span>&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = &amp;<span class="hljs-symbol">&#x27;s</span> <span class="hljs-type">str</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>        todo!()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">str_before</span>(s: &amp;<span class="hljs-type">str</span>, c: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">str</span>&gt; &#123;<br>    StrSplit &#123;<br>        document: s,<br>        delimiter: &amp;c.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-comment">// 这里的生命周期是比较短的，是当前函数所拥有的</span><br>    &#125;<br>    .<span class="hljs-title function_ invoke__">next</span>()<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="生命周期扩展-（Variance）"><a href="#生命周期扩展-（Variance）" class="headerlink" title="生命周期扩展 （Variance）"></a>生命周期扩展 （Variance）</h3><p>如果 A 是 B 的子类，那么 A 至少和 B 一样有用。这跟其他类型的继承或者叫扩展是相同的。</p>
<p>比如：如果函数接收 &amp;’a str 的参数，那么就可以传入 &amp;’static str 的参数。因为’static 是 a 的“子类”，‘static 至少跟任何‘a 存活的一样长。</p>
<h4 id="三种-Variance"><a href="#三种-Variance" class="headerlink" title="三种 Variance"></a>三种 Variance</h4><ul>
<li><p>covariant(协变)： 某类型只能用“子类型”替代</p>
<ul>
<li>例如：&amp;’staticT 可替代 &amp;’aT</li>
</ul>
</li>
<li><p>invariant(不变)：必须提供指定的类型</p>
<ul>
<li>例如：&amp;mutT，对于 T 来说就是 invariant 的</li>
</ul>
</li>
<li><p>contravariant(逆变)：函数对参数的要求越低，参数可发挥的作用越大</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x1</span> : &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 更有用一些</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x2</span>: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_fun1</span>(&amp;<span class="hljs-symbol">&#x27;static</span> str1) <span class="hljs-comment">// 限制更大</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_fun2</span>(&amp;<span class="hljs-symbol">&#x27;a</span> str2) <span class="hljs-comment">// 限制宽松</span><br></code></pre></div></td></tr></table></figure>

<p>如上所示，在函数中，限制更宽松将会更有用一些，而在外部的话，存活得更久则更有用一些。</p>
<p>下面的示例为什么只有一个字段却使用两个生命周期呢？</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MutStr</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt; &#123;<br>    s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">r</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br>    *MutStr &#123; s: &amp;<span class="hljs-keyword">mut</span> r &#125;.s = <span class="hljs-string">&quot;world&quot;</span>; <span class="hljs-comment">// 对外部的r创建了一个可变的引用</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r); <span class="hljs-comment">// 打印 world</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>上述示例中，<code>&#39;a</code>是可变的，<code>&#39;b</code>是不可变的。而在</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">*MutStr &#123; s: &amp;<span class="hljs-keyword">mut</span> r &#125;.s = <span class="hljs-string">&quot;world&quot;</span>;<br></code></pre></div></td></tr></table></figure>

<p>的时候，对创建的 s 进行了修改，其对应的就是<code>&#39;a</code>这个生命周期。</p>
<p>而 <code>*MutStr</code>结构体里面的 s 是静态的，因为 r 的生命周期是静态的，因此对于着 <code>&#39;b</code> 这个不可变的生命周期。</p>
<h2 id="内存对齐-repr-transparent"><a href="#内存对齐-repr-transparent" class="headerlink" title="内存对齐 repr(transparent)"></a>内存对齐 repr(transparent)</h2><h3 id="repr-C"><a href="#repr-C" class="headerlink" title="#[repr(C)]"></a><code>#[repr(C)]</code></h3><p>C 的对齐方案编译较快，但是运行较慢。</p>
<p>这个对齐方式在内存中有一定的限制，需要将所有字段按原 struct 定义的顺序放置。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[repr(C)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>  tiny:<span class="hljs-type">bool</span>, <span class="hljs-comment">// 1byte 填充3个，和normal组成8个</span><br>  normal:<span class="hljs-type">u32</span>, <span class="hljs-comment">// 4bytes</span><br>  small:<span class="hljs-type">u8</span>, <span class="hljs-comment">// 1 byte  填充 7个对齐8个</span><br>  long:<span class="hljs-type">u64</span>, <span class="hljs-comment">// 8bytes</span><br>  short:<span class="hljs-type">u16</span>, <span class="hljs-comment">// 2bytes 填充6个进行对齐</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这个结构体最大的是 long 拥有 8bytes，因此 tiny 后面将会填充 3 个字节，跟 normal4 个字节组合成 8 个字节。</p>
<p>而 small 拥有 1 个字节，它将继续填充 7 个字节，跟 8 字节对齐。</p>
<p>后面的 short 也将继续填充 6 字节，跟 8 字节对齐。一共 32 字节。</p>
<h3 id="repr-Rust"><a href="#repr-Rust" class="headerlink" title="#[repr(Rust)]"></a><code>#[repr(Rust)]</code></h3><p><code>repr(Rust)</code>允许重新对字段排序，可按大小递减的顺序排列。</p>
<p>对于 Foo 例子来说就不需要填充了：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[repr(Rust)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>  long:<span class="hljs-type">u64</span>, <span class="hljs-comment">// 8bytes</span><br>  normal:<span class="hljs-type">u32</span>, <span class="hljs-comment">// 4bytes // 下面组成8字节，跟上面的对齐</span><br>  short:<span class="hljs-type">u16</span>, <span class="hljs-comment">// 2bytes</span><br>  small:<span class="hljs-type">u8</span>, <span class="hljs-comment">// 1 byte</span><br>  tiny:<span class="hljs-type">bool</span>, <span class="hljs-comment">// 1byte</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>直接把最大的字段放前面，这样一下子就知道需要对齐到多少字节。一共 16bytes。</p>
<p>对布局的保证少了，编译器有余地进行重新安排，代码会更高效。但是编译时间会长一点。</p>
<h3 id="repr-packed-无填充布局"><a href="#repr-packed-无填充布局" class="headerlink" title="$[repr(packed)] 无填充布局"></a><code>$[repr(packed)]</code> 无填充布局</h3><p>可以告诉编译器字段之间无需任何填充，但是需要承担不对齐访问的性能损失，并且可能会导致代码运行速度慢.<br>极端情况下，如果 CPU 仅支持对齐操作，可导致程序崩溃。</p>
<p>什么场景下使用：</p>
<ul>
<li>内存有限，类型实例较多</li>
<li>通过低带宽网络连接发送内存表示</li>
</ul>
<h3 id="repr-align-n-给特定字段或类型更大的对齐"><a href="#repr-align-n-给特定字段或类型更大的对齐" class="headerlink" title="#[repr(align(n))] 给特定字段或类型更大的对齐"></a><code>#[repr(align(n))]</code> 给特定字段或类型更大的对齐</h3><p>这个主要是用来避免伪共享。</p>
<blockquote>
<p>伪共享 （false sharing）：两个不同的 CPU 访问共享同一个缓存行的不同变量时， 就发生了伪共享。理论上它们可以并行操作，但最终它们都争相更新缓存中的同一个条目。它可导致并发类程序中的巨大性能降级。</p>
</blockquote>
<h2 id="Sized-类型和宽指针"><a href="#Sized-类型和宽指针" class="headerlink" title="Sized 类型和宽指针"></a>Sized 类型和宽指针</h2><h3 id="Sized"><a href="#Sized" class="headerlink" title="Sized"></a>Sized</h3><p>rust 中除了两个常见的类型 Trait 对象和切片(slice)类型，大多数类型自动实现了 Sized,它的大小在编译时就已知了。</p>
<p>自定义的 Type Bound 自动包含<code>T:Sized</code>，除非你写明<code>T:?Sized</code>。</p>
<h3 id="宽指针-Wide-Pointer"><a href="#宽指针-Wide-Pointer" class="headerlink" title="宽指针(Wide Pointer)"></a>宽指针(Wide Pointer)</h3><p>宽指针就是普通指针，附加了一个字大小(word-sized)的字段。</p>
<p>如果需要接收 DST（trait 对象，切片等）类型就需要宽指针，当引用 DST 时，编译器就会自动为你组建一个宽指针。</p>
<p>通过将非 Sized 类型放在宽指针后边，就可弥补 Sized 和非 Sized 类型间的差距。</p>
<p>例如：切片 slice, 它的附加信息就是切片的长度。</p>
<blockquote>
<p>备注：Box 和 Arc 都支持存储宽指针，所以它们都支持<code>T:?Sized</code></p>
</blockquote>
<h2 id="编译和分派"><a href="#编译和分派" class="headerlink" title="编译和分派"></a>编译和分派</h2><h3 id="静态分派-static-dispatch"><a href="#静态分派-static-dispatch" class="headerlink" title="静态分派 (static dispatch)"></a>静态分派 (static dispatch)</h3><p>静态分派的意思是需要为每个类型复制一份（方法体），每份都有自己的地址，可用来跳转。</p>
<p>编译器会复制泛型类型以及所有的实现块。并把每个实例的泛型参数使用具体类型替换。</p>
<p>例如：Vec<i32>，就是对 Vec 做一个完整的复制，所有遇到的 T 都换成 i32。</p>
<blockquote>
<p>注意：编译器其实不会做完整的复制粘贴，它只复制你用的代码.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">String</span> &#123;<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">contains</span>(&amp;<span class="hljs-keyword">self</span>,p <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Pattern</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>    p.<span class="hljs-title function_ invoke__">is_contained_in</span>(<span class="hljs-keyword">self</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>p 参数是 <code>impl Pattern</code>类型，针对不同的 Pattern 类型，该方法都会复制一遍。</p>
<p>因为我们需要知道 is_contained_in 方法的地址，以便进行调用。CPU 需要知道在哪跳转和继续执行。<br>对于任何给定的 Pattern，编译器知道那个地址是 Pattern 类型实现 Trait 方法的地址。<br>不存在一个可给任意类型用的通用地址。</p>
<h4 id="单态化-monomorphization"><a href="#单态化-monomorphization" class="headerlink" title="单态化 (monomorphization)"></a>单态化 (monomorphization)</h4><p>从一个泛型类型到多个非泛型类型的过程叫做单态化。当编译器开始优化代码时，就好像根本没有泛型！</p>
<ul>
<li>每个实例都是单独优化的，具有了所有的已知类型</li>
<li>所以 is_contained_in 方法调用的执行效率就如同 Trait 不存在一样</li>
<li>编译器对涉及的类型完全掌握，甚至可以将它进行 inline 实现</li>
</ul>
<p>但是单态化也是有代价的</p>
<ul>
<li>所有的实例需要单独编译，编译时间增加（如果不能优化编译）</li>
<li>每个单态化的函数会有自己的一段机器码，让程序更大</li>
<li>指令在泛型方法的不同实例间无法共享，CPU 的指令缓存效率降低，因为它需要持有相同指令的多个不同副本</li>
</ul>
<h3 id="动态分派-dynamic-dispatch"><a href="#动态分派-dynamic-dispatch" class="headerlink" title="动态分派 (dynamic dispatch)"></a>动态分派 (dynamic dispatch)</h3><p>动态分派，使代码可以调用泛型类型上的 trait 方法，而无需知道具体的类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">String</span> &#123;<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">contains</span>(&amp;<span class="hljs-keyword">self</span>,p &amp;<span class="hljs-keyword">dyn</span> Pattern) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>    p.<span class="hljs-title function_ invoke__">is_contained_in</span>(&amp;*<span class="hljs-keyword">self</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>它只要求调用者提供两个信息：</p>
<ol>
<li>Pattern 的地址</li>
<li>is_contained_in 的地址</li>
</ol>
<h4 id="vtable"><a href="#vtable" class="headerlink" title="vtable"></a>vtable</h4><p>调用者会提供指向一块内存的指针，它叫做虚方法表（virtual method table）或叫 vtable。它持上例该类型所有的 trait 方法实现的地址，其中一个就是 is_contained_in。</p>
<p>当代码想调用提供类型的一个 trait 方法时，就会从 vtable 查询 is_contained_in 方法的实现地址，并调用，这允许我们使用相同的函数体，而不关心调用者想要使用的类型。</p>
<p>每个 vtable 还包含具体类型的布局和对齐信息</p>
<h4 id="保证对象安全"><a href="#保证对象安全" class="headerlink" title="保证对象安全"></a>保证对象安全</h4><ul>
<li>trait 所有的方法都不能是泛型的，也不可以使用 Self</li>
<li>trait 不可拥有静态方法（我们无法知道在哪个实例上调用的方法）</li>
</ul>
<p>动态分派的优点是，编译时间减少提升 CPU 指令缓存效率。</p>
<p>缺点是，编译器无法对特定类型优化,只能通过 vtable 调用。<br>函数直接调用方法的开销增加。trait object 上的每次方法调用都需要查 vtable。</p>
<h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>在 library 中使用静态分派，因为无法知道用户的需求,这样用户可自行选择,如果使用动态分派，用户也就没有选择。</p>
<p>在 binary 中使用动态分派,  因为 binary 是最终代码，并且动态分派使代码更整洁（省去了泛型参数），编译更快,但是以边际性能为代价。</p>
<h2 id="Trait-泛型方式"><a href="#Trait-泛型方式" class="headerlink" title="Trait 泛型方式"></a>Trait 泛型方式</h2><p>有两种：</p>
<ul>
<li>泛型类型参数：<code>trait Foo&lt;T&gt;</code></li>
<li>关联类型：<code>trait Foo &#123;type Bar;&#125;</code></li>
</ul>
<p>区别</p>
<ul>
<li>使用关联类型：对于指定类型的 trait 只有一个实现</li>
<li>使用泛型类型参数：多个实现</li>
</ul>
<p>简单来说可以的话尽量使用关联类型。</p>
<h3 id="泛型-类型参数-Trait"><a href="#泛型-类型参数-Trait" class="headerlink" title="泛型 (类型参数) Trait"></a>泛型 (类型参数) Trait</h3><p>泛型 Trait 必须指定所有的泛型类型参数，并重复写这些参数的 Bound，维护较难。<br>如果添加泛型类型参数到某个 Trait，该 Trait 的所有用户必须都进行更新代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PartialEq</span>&lt;BookFormat&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Book</span><br>Fromlterator::&lt;U32&gt;::from_iter<br></code></pre></div></td></tr></table></figure>

<h3 id="关联类型-Trait"><a href="#关联类型-Trait" class="headerlink" title="关联类型 Trait"></a>关联类型 Trait</h3><p>编译器只需要知道实现 Trait 的类型。</p>
<p>Bound 可完全位于 Trait 本身，不必重复使用，未来再添加 关联类型 也不影响用户使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Contains</span> &#123;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">A</span>;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">B</span>;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">contains</span>(&amp;<span class="hljs-keyword">self</span>, _: &amp;<span class="hljs-keyword">Self</span>::A, _: &amp;<span class="hljs-keyword">Self</span>:B) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>具体的类型会决定 Trait 内关联类型的类型，无需使用消除歧义的函数。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Contains</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Container</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">A</span> = <span class="hljs-type">i32</span>;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">B</span> = <span class="hljs-type">i32</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">contains</span>(&amp;<span class="hljs-keyword">self</span>, num_1: &amp;<span class="hljs-type">i32</span>, num_2: &amp;<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        (&amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> == num_1) &amp;&amp; (&amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">1</span> == num_2)<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">first</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123; <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">last</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123; <span class="hljs-keyword">self</span>.<span class="hljs-number">1</span> &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>不可以对多个 Target 类型来实现 Deref</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Deref</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span>: ?<span class="hljs-built_in">Sized</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Target;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>不可以使用多个 Item 来实现 Iterator</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Interator</span> &#123;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="孤儿规则-orphan-rule"><a href="#孤儿规则-orphan-rule" class="headerlink" title="孤儿规则 (orphan rule)"></a>孤儿规则 (orphan rule)</h2><p>定义：对于给定的类型和方法，只会有一个正确的选择，用于该方法对该类型的实现。</p>
<p>只要 trait 或者 类型在你本地的 crate，那就可以为该类型实现该 trait。</p>
<p>可以为你的类型实现 Debug；可以为 bool 实现 MyTrait，不能为 bool 实现 Debug。</p>
<h3 id="Blanket-Implementation-一揽子的实施"><a href="#Blanket-Implementation-一揽子的实施" class="headerlink" title="Blanket Implementation (一揽子的实施)"></a>Blanket Implementation (一揽子的实施)</h3><p><code>impl&lt;T&gt;MyTrait for T where T：</code></p>
<p>例如：<code>impl&lt;T: Display&gt; ToString for T｛｝</code></p>
<p><code>where T</code>实现一系列的类型,不局限于一个特定的类型，而是应用于更广泛的类型。<br>只有定义 trait 的 crate 允许使用 Blanket Implementation。</p>
<p>注意：添加 Blanket Implementation 到现有 trait 属于破坏性变化。</p>
<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>目前包括，<code>&amp;</code>,<code>&amp;mut</code>,<code>Box</code>,它们被标记为<code>#[fundamental]</code>,并且因为太基础了，需要允许任何人在它们上实现 trait（即使违反孤儿规则）。因此在孤儿规则检查前，它们就会被抹除。</p>
<h3 id="Covered-Implementation-覆盖实施"><a href="#Covered-Implementation-覆盖实施" class="headerlink" title="Covered Implementation (覆盖实施)"></a>Covered Implementation (覆盖实施)</h3><p>有时需要为外部类型实现外部 trait。</p>
<p>例如：<code>impl From&lt;MyType&gt; for Vec&lt;i32&gt;</code></p>
<p>孤儿规则制定了一个狭窄的豁免：允许在非常特定的情况下为外来类型实现外来 trait。</p>
<p>例如：<code> impl&lt;Pi..=Pn&gt; ForeignTrait&lt;Ti..=Tn&gt; for T0</code></p>
<p>只在以下条件被允许：</p>
<ul>
<li>至少有一个 Ti 是本地类型。</li>
<li>没有 T 在第一个这样的 Ti 前（T 是指泛型类型 PI.&#x3D;Pn 中的一个）。</li>
<li>泛型类型参数 Ps 允许出现在 TO..Ti，只要它们被某种中间 （intermediate）类型所 cover。</li>
</ul>
<p>如果 T 作为其他类型（例 Vec<T>）的类型参数出现，那就说 T 被 cover 了。而 T 只作为本身，或者位于基础类型后（例 &amp;T），就无法被覆盖了。</p>
<p>例子：</p>
<ul>
<li>符合的：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;T&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyType</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;T&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyType</span>&lt;T&gt;<br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;MyType&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Vec</span>&lt;T&gt;<br><span class="hljs-keyword">impl</span>&lt;T&gt; ForeignTrait&lt;MyType, T&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Vec</span>&lt;T&gt;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>不符合的：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; ForeignTrait <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;T&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;<span class="hljs-type">Vec</span>&lt;T&gt;&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;MyType&lt;T&gt;&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;T&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Vec</span>&lt;T&gt;<br><span class="hljs-keyword">impl</span>&lt;T&gt; ForeignTrait&lt;T, MyType&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Vec</span>&lt;T&gt;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>为现有 trait 添加新的实现，且至少包含一个新的本地类型，该本地类型<br>满足豁免条件，这就是非破坏性的变化</li>
<li>为现有 trait 添加的实现不满足上述要求，就是破坏性变化</li>
</ul>
<p>注意：</p>
<ul>
<li><p><code>impl&lt;T&gt; ForeignTrait&lt;LocalType, T&gt; for ForeignType</code>，本地类型出现在前面，是合法的。</p>
</li>
<li><p><code>impl&lt;T&gt;ForeignTrait&lt;T, LocalType&gt; for ForeignType</code>，T 出现在本地类型前面是非法的。</p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/rust/">rust</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/12/07/FEDAY/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">第七届-FEDAY</span>
                        <span class="visible-mobile">Vorheriger</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/03/%E5%A5%87%E9%97%A8%E9%81%81%E7%94%B2-%E6%8E%92%E7%9B%98/">
                        <span class="hidden-mobile">奇门遁甲-排盘</span>
                        <span class="visible-mobile">Nächster</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'waterbang/Comment');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Suchen</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">Stichwort</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>
  </div>
  

  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        闽ICP备18009949号-2
      </a>
    </span>
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?58e161bf4b884b2aa577f323f137ac0f";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
